# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2015, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-12-22 00:52+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr ""

#: reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""

#: reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""

#: reference/compound_stmts.rst:25
msgid ""
"Compound statements consist of one or more 'clauses.'  A clause consists of "
"a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""

#: reference/compound_stmts.rst:38
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""

#: reference/compound_stmts.rst:44
msgid "Summarizing:"
msgstr ""

#: reference/compound_stmts.rst:63
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""

#: reference/compound_stmts.rst:69
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""

#: reference/compound_stmts.rst:78
#, fuzzy
msgid "The :keyword:`if` statement"
msgstr "L'instruction :keyword:`if`"

#: reference/compound_stmts.rst:87
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ""

#: reference/compound_stmts.rst:94
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""

#: reference/compound_stmts.rst:104
msgid "The :keyword:`while` statement"
msgstr ""

#: reference/compound_stmts.rst:112
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""

#: reference/compound_stmts.rst:119
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`else` clause, if present, is executed and the "
"loop terminates."
msgstr ""

#: reference/compound_stmts.rst:128
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and goes "
"back to testing the expression."
msgstr ""

#: reference/compound_stmts.rst:137
msgid "The :keyword:`for` statement"
msgstr ""

#: reference/compound_stmts.rst:150
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""

#: reference/compound_stmts.rst:157
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"of ascending indices.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""

#: reference/compound_stmts.rst:170
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and "
"continues with the next item, or with the :keyword:`else` clause if there "
"was no next item."
msgstr ""

#: reference/compound_stmts.rst:176
msgid ""
"The suite may assign to the variable(s) in the target list; this does not "
"affect the next item assigned to it."
msgstr ""

#: reference/compound_stmts.rst:182
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, it will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""

#: reference/compound_stmts.rst:194
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, i.e. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""

#: reference/compound_stmts.rst:215
msgid "The :keyword:`try` statement"
msgstr ""

#: reference/compound_stmts.rst:223
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""

#: reference/compound_stmts.rst:236
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`try` suite, a search for "
"an exception handler is started.  This search inspects the except clauses in "
"turn until one is found that matches the exception.  An expression-less "
"except clause, if present, must be last; it matches any exception.  For an "
"except clause with an expression, that expression is evaluated, and the "
"clause matches the exception if the resulting object is \"compatible\" with "
"the exception.  An object is compatible with an exception if it is the class "
"or a base class of the exception object or a tuple containing an item "
"compatible with the exception."
msgstr ""

#: reference/compound_stmts.rst:247
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""

#: reference/compound_stmts.rst:250
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""

#: reference/compound_stmts.rst:255
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must "
"have an executable block.  When the end of this block is reached, execution "
"continues normally after the entire try statement.  (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""

#: reference/compound_stmts.rst:263
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""

#: reference/compound_stmts.rst:269
msgid "was translated to ::"
msgstr ""

#: reference/compound_stmts.rst:277
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""

#: reference/compound_stmts.rst:286
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"stored in the :mod:`sys` module and can be access via :func:`sys.exc_info`. :"
"func:`sys.exc_info` returns a 3-tuple consisting of the exception class, the "
"exception instance and a traceback object (see section :ref:`types`) "
"identifying the point in the program where the exception occurred.  :func:"
"`sys.exc_info` values are restored to their previous values (before the "
"call) when returning from a function that handled an exception."
msgstr ""

#: reference/compound_stmts.rst:300
msgid ""
"The optional :keyword:`else` clause is executed if and when control flows "
"off the end of the :keyword:`try` clause. [#]_ Exceptions in the :keyword:"
"`else` clause are not handled by the preceding :keyword:`except` clauses."
msgstr ""

#: reference/compound_stmts.rst:306
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`finally` clause.  If the :keyword:`finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`finally` clause executes a :keyword:`return` "
"or :keyword:`break` statement, the saved exception is discarded::"
msgstr ""

#: reference/compound_stmts.rst:325
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""

#: reference/compound_stmts.rst:333
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`try`...\\ :keyword:"
"`finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.' A :keyword:`continue` statement is illegal in the :keyword:"
"`finally` clause. (The reason is a problem with the current implementation "
"--- this restriction may be lifted in the future)."
msgstr ""

#: reference/compound_stmts.rst:340
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""

#: reference/compound_stmts.rst:349
msgid "The :keyword:`with` statement"
msgstr ""

#: reference/compound_stmts.rst:353
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""

#: reference/compound_stmts.rst:362
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""

#: reference/compound_stmts.rst:364
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""

#: reference/compound_stmts.rst:367
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""

#: reference/compound_stmts.rst:369
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr ""

#: reference/compound_stmts.rst:371
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""

#: reference/compound_stmts.rst:376
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""

#: reference/compound_stmts.rst:382
msgid "The suite is executed."
msgstr ""

#: reference/compound_stmts.rst:384
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""

#: reference/compound_stmts.rst:389
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""

#: reference/compound_stmts.rst:394
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""

#: reference/compound_stmts.rst:398
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""

#: reference/compound_stmts.rst:404 reference/compound_stmts.rst:479
#: reference/compound_stmts.rst:591 reference/compound_stmts.rst:613
msgid "is equivalent to ::"
msgstr ""

#: reference/compound_stmts.rst:410
msgid "Support for multiple context expressions."
msgstr ""

#: reference/compound_stmts.rst:416 reference/datamodel.rst:1997
msgid "PEP 0343 - The \"with\" statement"
msgstr ""

#: reference/compound_stmts.rst:416 reference/datamodel.rst:1997
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""

#: reference/compound_stmts.rst:427
msgid "Function definitions"
msgstr ""

#: reference/compound_stmts.rst:439
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""

#: reference/compound_stmts.rst:456
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""

#: reference/compound_stmts.rst:462
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""

#: reference/compound_stmts.rst:468
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""

#: reference/compound_stmts.rst:488
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""

#: reference/compound_stmts.rst:496
msgid ""
"**Default parameter values are evaluated when the function definition is "
"executed.** This means that the expression is evaluated once, when the "
"function is defined, and that the same \"pre-computed\" value is used for "
"each call.  This is especially important to understand when a default "
"parameter is a mutable object, such as a list or a dictionary: if the "
"function modifies the object (e.g. by appending an item to a list), the "
"default value is in effect modified. This is generally not what was "
"intended.  A way around this is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""

#: reference/compound_stmts.rst:515
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from position arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple.  If the form \"``**identifier``\" "
"is present, it is initialized to a new dictionary receiving any excess "
"keyword arguments, defaulting to a new empty dictionary. Parameters after "
"\"``*``\" or \"``*identifier``\" are keyword-only parameters and may only be "
"passed used keyword arguments."
msgstr ""

#: reference/compound_stmts.rst:527
msgid ""
"Parameters may have annotations of the form \"``: expression``\" following "
"the parameter name.  Any parameter may have an annotation even those of the "
"form ``*identifier`` or ``**identifier``.  Functions may have \"return\" "
"annotation of the form \"``-> expression``\" after the parameter list.  "
"These annotations can be any valid Python expression and are evaluated when "
"the function definition is executed.  Annotations may be evaluated in a "
"different order than they appear in the source code.  The presence of "
"annotations does not change the semantics of a function.  The annotation "
"values are available as values of a dictionary keyed by the parameters' "
"names in the :attr:`__annotations__` attribute of the function object."
msgstr ""

#: reference/compound_stmts.rst:540
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda forms, described "
"in section :ref:`lambda`.  Note that the lambda form is merely a shorthand "
"for a simplified function definition; a function defined in a \":keyword:"
"`def`\" statement can be passed around or assigned to another name just like "
"a function defined by a lambda form.  The \":keyword:`def`\" form is "
"actually more powerful since it allows the execution of multiple statements "
"and annotations."
msgstr ""

#: reference/compound_stmts.rst:548
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"form executed inside a function definition defines a local function that can "
"be returned or passed around.  Free variables used in the nested function "
"can access the local variables of the function containing the def.  See "
"section :ref:`naming` for details."
msgstr ""

#: reference/compound_stmts.rst:556
msgid "PEP 3107 - Function Annotations"
msgstr ""

#: reference/compound_stmts.rst:557
msgid "The original specification for function annotations."
msgstr ""

#: reference/compound_stmts.rst:563
msgid "Class definitions"
msgstr ""

#: reference/compound_stmts.rst:575
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""

#: reference/compound_stmts.rst:582
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""

#: reference/compound_stmts.rst:596
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""

#: reference/compound_stmts.rst:605
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""

#: reference/compound_stmts.rst:607
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""

#: reference/compound_stmts.rst:618
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result must be a class object, which is then bound "
"to the class name."
msgstr ""

#: reference/compound_stmts.rst:622
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""

#: reference/compound_stmts.rst:634
msgid ":pep:`3115` - Metaclasses in Python 3 :pep:`3129` - Class Decorators"
msgstr ""

#: reference/compound_stmts.rst:639 reference/datamodel.rst:2077
#: reference/executionmodel.rst:234 reference/expressions.rst:1332
msgid "Footnotes"
msgstr "Notes"

#: reference/compound_stmts.rst:640
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""

#: reference/compound_stmts.rst:644
msgid ""
"Currently, control \"flows off the end\" except in the case of an exception "
"or the execution of a :keyword:`return`, :keyword:`continue`, or :keyword:"
"`break` statement."
msgstr ""

#: reference/compound_stmts.rst:648
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""

#: reference/compound_stmts.rst:652
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""

#: reference/datamodel.rst:6
msgid "Data model"
msgstr ""

#: reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr ""

#: reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""

#: reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity (currently implemented as its address). An object's :dfn:`type` is "
"also unchangeable. [#]_ An object's type determines the operations that the "
"object supports (e.g., \"does it have a length?\") and also defines the "
"possible values for objects of that type.  The :func:`type` function returns "
"an object's type (which is an object itself).  The *value* of some objects "
"can change.  Objects whose value can change are said to be *mutable*; "
"objects whose value is unchangeable once they are created are called "
"*immutable*. (The value of an immutable container object that contains a "
"reference to a mutable object can change when the latter's value is changed; "
"however the container is still considered immutable, because the collection "
"of objects it contains cannot be changed.  So, immutability is not strictly "
"the same as having an unchangeable value, it is more subtle.) An object's "
"mutability is determined by its type; for instance, numbers, strings and "
"tuples are immutable, while dictionaries and lists are mutable."
msgstr ""

#: reference/datamodel.rst:58
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""

#: reference/datamodel.rst:66
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (ex: "
"always close files)."
msgstr ""

#: reference/datamodel.rst:75
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""

#: reference/datamodel.rst:80
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement and the ':keyword:`with`' statement provide convenient "
"ways to do this."
msgstr ""

#: reference/datamodel.rst:90
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""

#: reference/datamodel.rst:99
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""

#: reference/datamodel.rst:113
msgid "The standard type hierarchy"
msgstr ""

#: reference/datamodel.rst:122
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""

#: reference/datamodel.rst:133
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""

#: reference/datamodel.rst:143
msgid "None"
msgstr ""

#: reference/datamodel.rst:140
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""

#: reference/datamodel.rst:153
msgid "NotImplemented"
msgstr ""

#: reference/datamodel.rst:148
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods may return this value if they do "
"not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  Its truth value is true."
msgstr ""

#: reference/datamodel.rst:160
msgid "Ellipsis"
msgstr ""

#: reference/datamodel.rst:158
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""

#: reference/datamodel.rst:230
msgid "numbers.Number"
msgstr ""

#: reference/datamodel.rst:165
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""

#: reference/datamodel.rst:171
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr ""

#: reference/datamodel.rst:205
msgid "numbers.Integral"
msgstr ""

#: reference/datamodel.rst:177
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""

#: reference/datamodel.rst:180
msgid "There are two types of integers:"
msgstr ""

#: reference/datamodel.rst:182
msgid "Integers (:class:`int`)"
msgstr ""

#: reference/datamodel.rst:184
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""

#: reference/datamodel.rst:200
msgid "Booleans (bool)"
msgstr ""

#: reference/datamodel.rst:196
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values False and True are the only Boolean objects. The "
"Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or ``\"True"
"\"`` are returned, respectively."
msgstr ""

#: reference/datamodel.rst:204
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""

#: reference/datamodel.rst:220
msgid "numbers.Real (float)"
msgstr ""

#: reference/datamodel.rst:214
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these is "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""

#: reference/datamodel.rst:230
msgid "numbers.Complex (complex)"
msgstr ""

#: reference/datamodel.rst:227
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""

#: reference/datamodel.rst:346
msgid "Sequences"
msgstr ""

#: reference/datamodel.rst:240
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""

#: reference/datamodel.rst:247
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""

#: reference/datamodel.rst:252
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""

#: reference/datamodel.rst:256
msgid "Sequences are distinguished according to their mutability:"
msgstr ""

#: reference/datamodel.rst:310
msgid "Immutable sequences"
msgstr ""

#: reference/datamodel.rst:263
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""

#: reference/datamodel.rst:268
msgid "The following types are immutable sequences:"
msgstr ""

#: reference/datamodel.rst:288
msgid "Strings"
msgstr "Les chaînes de caractères"

#: reference/datamodel.rst:279
msgid ""
"The items of a string object are Unicode code units.  A Unicode code unit is "
"represented by a string object of one item and can hold either a 16-bit or "
"32-bit value representing a Unicode ordinal (the maximum value for the "
"ordinal is given in ``sys.maxunicode``, and depends on how Python is "
"configured at compile time).  Surrogate pairs may be present in the Unicode "
"object, and will be reported as two separate items.  The built-in functions :"
"func:`chr` and :func:`ord` convert between code units and nonnegative "
"integers representing the Unicode ordinals as defined in the Unicode "
"Standard 3.0. Conversion from and to other encodings are possible through "
"the string method :meth:`encode`."
msgstr ""

#: reference/datamodel.rst:301
msgid "Tuples"
msgstr ""

#: reference/datamodel.rst:296
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""

#: reference/datamodel.rst:310
msgid "Bytes"
msgstr ""

#: reference/datamodel.rst:306
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in function :func:`bytes` can be used to construct "
"bytes objects.  Also, bytes objects can be decoded to strings via the :meth:"
"`decode` method."
msgstr ""

#: reference/datamodel.rst:346
msgid "Mutable sequences"
msgstr ""

#: reference/datamodel.rst:322
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""

#: reference/datamodel.rst:326
msgid "There are currently two intrinsic mutable sequence types:"
msgstr ""

#: reference/datamodel.rst:333
msgid "Lists"
msgstr "Les listes"

#: reference/datamodel.rst:331
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""

#: reference/datamodel.rst:341
msgid "Byte Arrays"
msgstr ""

#: reference/datamodel.rst:338
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable bytes objects."
msgstr ""

#: reference/datamodel.rst:345
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""

#: reference/datamodel.rst:380
msgid "Set types"
msgstr ""

#: reference/datamodel.rst:353
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""

#: reference/datamodel.rst:360
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""

#: reference/datamodel.rst:365
msgid "There are currently two intrinsic set types:"
msgstr ""

#: reference/datamodel.rst:372
msgid "Sets"
msgstr "Les ensembles"

#: reference/datamodel.rst:370
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`add`."
msgstr ""

#: reference/datamodel.rst:380
msgid "Frozen sets"
msgstr ""

#: reference/datamodel.rst:377
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""

#: reference/datamodel.rst:417
msgid "Mappings"
msgstr ""

#: reference/datamodel.rst:388
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""

#: reference/datamodel.rst:394
msgid "There is currently a single intrinsic mapping type:"
msgstr ""

#: reference/datamodel.rst:417
msgid "Dictionaries"
msgstr "Dictionnaires"

#: reference/datamodel.rst:399
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""

#: reference/datamodel.rst:408
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr ""

#: reference/datamodel.rst:415
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""

#: reference/datamodel.rst:635
msgid "Callable types"
msgstr ""

#: reference/datamodel.rst:426
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""

#: reference/datamodel.rst:512
msgid "User-defined functions"
msgstr ""

#: reference/datamodel.rst:435
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""

#: reference/datamodel.rst:440
msgid "Special attributes:"
msgstr ""

#: reference/datamodel.rst:443
msgid "Attribute"
msgstr ""

#: reference/datamodel.rst:443 reference/lexical_analysis.rst:460
#: reference/lexical_analysis.rst:493
msgid "Meaning"
msgstr "Signification"

#: reference/datamodel.rst:445
msgid ":attr:`__doc__`"
msgstr ""

#: reference/datamodel.rst:445
msgid "The function's documentation string, or ``None`` if unavailable"
msgstr ""

#: reference/datamodel.rst:445 reference/datamodel.rst:449
#: reference/datamodel.rst:451 reference/datamodel.rst:455
#: reference/datamodel.rst:461 reference/datamodel.rst:471
#: reference/datamodel.rst:479 reference/datamodel.rst:486
msgid "Writable"
msgstr ""

#: reference/datamodel.rst:449
msgid ":attr:`__name__`"
msgstr ""

#: reference/datamodel.rst:449
msgid "The function's name"
msgstr ""

#: reference/datamodel.rst:451
msgid ":attr:`__module__`"
msgstr ""

#: reference/datamodel.rst:451
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""

#: reference/datamodel.rst:455
msgid ":attr:`__defaults__`"
msgstr ""

#: reference/datamodel.rst:455
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value"
msgstr ""

#: reference/datamodel.rst:461
msgid ":attr:`__code__`"
msgstr ""

#: reference/datamodel.rst:461
msgid "The code object representing the compiled function body."
msgstr ""

#: reference/datamodel.rst:464
msgid ":attr:`__globals__`"
msgstr ""

#: reference/datamodel.rst:464
msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr ""

#: reference/datamodel.rst:464 reference/datamodel.rst:475
msgid "Read-only"
msgstr ""

#: reference/datamodel.rst:471
msgid ":attr:`__dict__`"
msgstr ""

#: reference/datamodel.rst:471
msgid "The namespace supporting arbitrary function attributes."
msgstr ""

#: reference/datamodel.rst:475
msgid ":attr:`__closure__`"
msgstr ""

#: reference/datamodel.rst:475
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr ""

#: reference/datamodel.rst:479
msgid ":attr:`__annotations__`"
msgstr ""

#: reference/datamodel.rst:479
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are the "
"parameter names, or ``'return'`` for the return annotation, if provided."
msgstr ""

#: reference/datamodel.rst:486
msgid ":attr:`__kwdefaults__`"
msgstr ""

#: reference/datamodel.rst:486
msgid "A dict containing defaults for keyword-only parameters."
msgstr ""

#: reference/datamodel.rst:490
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr ""

#: reference/datamodel.rst:492
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""

#: reference/datamodel.rst:498
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr ""

#: reference/datamodel.rst:581
msgid "Instance methods"
msgstr ""

#: reference/datamodel.rst:520
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""

#: reference/datamodel.rst:530
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); :attr:`__name__` is "
"the method name (same as ``__func__.__name__``); :attr:`__module__` is the "
"name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""

#: reference/datamodel.rst:536
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""

#: reference/datamodel.rst:539
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object or a class method object."
msgstr ""

#: reference/datamodel.rst:543
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its :attr:`__self__` "
"attribute is the instance, and the method object is said to be bound.  The "
"new method's :attr:`__func__` attribute is the original function object."
msgstr ""

#: reference/datamodel.rst:549
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function "
"object, except that the :attr:`__func__` attribute of the new instance is "
"not the original method object but its :attr:`__func__` attribute."
msgstr ""

#: reference/datamodel.rst:555
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the class "
"itself, and its :attr:`__func__` attribute is the function object underlying "
"the class method."
msgstr ""

#: reference/datamodel.rst:560
msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`__func__`) is called, inserting the class instance (:attr:`__self__`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""

#: reference/datamodel.rst:567
msgid ""
"When an instance method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`__self__` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""

#: reference/datamodel.rst:572
msgid ""
"Note that the transformation from function object to instance method object "
"happens each time the attribute is retrieved from the instance.  In some "
"cases, a fruitful optimization is to assign the attribute to a local "
"variable and call that local variable. Also notice that this transformation "
"only happens for user-defined functions; other callable objects (and all non-"
"callable objects) are retrieved without transformation.  It is also "
"important to note that user-defined functions which are attributes of a "
"class instance are not converted to bound methods; this *only* happens when "
"the function is an attribute of the class."
msgstr ""

#: reference/datamodel.rst:596
msgid "Generator functions"
msgstr ""

#: reference/datamodel.rst:588
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`iterator__next__` "
"method will cause the function to execute until it provides a value using "
"the :keyword:`yield` statement.  When the function executes a :keyword:"
"`return` statement or falls off the end, a :exc:`StopIteration` exception is "
"raised and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ""

#: reference/datamodel.rst:611
msgid "Built-in functions"
msgstr ""

#: reference/datamodel.rst:604
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`__name__` is the function's name; :attr:`__self__` is set to ``None`` (but "
"see the next item); :attr:`__module__` is the name of the module the "
"function was defined in or ``None`` if unavailable."
msgstr ""

#: reference/datamodel.rst:623
msgid "Built-in methods"
msgstr ""

#: reference/datamodel.rst:619
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""

#: reference/datamodel.rst:630
msgid "Classes"
msgstr "Classes"

#: reference/datamodel.rst:626
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`__new__`.  The arguments of the call are passed to :meth:"
"`__new__` and, in the typical case, to :meth:`__init__` to initialize the "
"new instance."
msgstr ""

#: reference/datamodel.rst:635
msgid "Class Instances"
msgstr ""

#: reference/datamodel.rst:633
msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`__call__` method in their class."
msgstr ""

#: reference/datamodel.rst:678
msgid "Modules"
msgstr "Modules"

#: reference/datamodel.rst:642
msgid ""
"Modules are imported by the :keyword:`import` statement (see section :ref:"
"`import`). A module object has a namespace implemented by a dictionary "
"object (this is the dictionary referenced by the __globals__ attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x"
"\"]``. A module object does not contain the code object used to initialize "
"the module (since it isn't needed once the initialization is done)."
msgstr ""

#: reference/datamodel.rst:651
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""

#: reference/datamodel.rst:656
msgid ""
"Special read-only attribute: :attr:`__dict__` is the module's namespace as a "
"dictionary object."
msgstr ""

#: reference/datamodel.rst:661
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""

#: reference/datamodel.rst:672
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; :"
"attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute is not present for C modules that are statically linked into the "
"interpreter; for extension modules loaded dynamically from a shared library, "
"it is the pathname of the shared library file."
msgstr ""

#: reference/datamodel.rst:734
msgid "Custom classes"
msgstr ""

#: reference/datamodel.rst:681
msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found in the documentation accompanying the 2.3 release at http://www.python."
"org/download/releases/2.3/mro/."
msgstr ""

#: reference/datamodel.rst:705
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`__self__` attributes is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`__dict__`."
msgstr ""

#: reference/datamodel.rst:715
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""

#: reference/datamodel.rst:720
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""

#: reference/datamodel.rst:729
msgid ""
"Special attributes: :attr:`__name__` is the class name; :attr:`__module__` "
"is the module name in which the class was defined; :attr:`__dict__` is the "
"dictionary containing the class's namespace; :attr:`__bases__` is a tuple "
"(possibly empty or a singleton) containing the base classes, in the order of "
"their occurrence in the base class list; :attr:`__doc__` is the class's "
"documentation string, or None if undefined."
msgstr ""

#: reference/datamodel.rst:777
msgid "Class instances"
msgstr ""

#: reference/datamodel.rst:743
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`__self__` attribute is the instance.  Static "
"method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`__dict__`.  If no class "
"attribute is found, and the object's class has a :meth:`__getattr__` method, "
"that is called to satisfy the lookup."
msgstr ""

#: reference/datamodel.rst:759
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:"
"`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""

#: reference/datamodel.rst:769
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""

#: reference/datamodel.rst:776
msgid ""
"Special attributes: :attr:`__dict__` is the attribute dictionary; :attr:"
"`__class__` is the instance's class."
msgstr ""

#: reference/datamodel.rst:803
msgid "I/O objects (also known as file objects)"
msgstr ""

#: reference/datamodel.rst:793
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`makefile` method of "
"socket objects (and perhaps by other functions or methods provided by "
"extension modules)."
msgstr ""

#: reference/datamodel.rst:799
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""

#: reference/datamodel.rst:997
msgid "Internal types"
msgstr ""

#: reference/datamodel.rst:810
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""

#: reference/datamodel.rst:880
#, fuzzy
msgid "Code objects"
msgstr "Objets Code"

#: reference/datamodel.rst:819
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""

#: reference/datamodel.rst:844
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_argcount` is the number of positional arguments (including arguments "
"with default values); :attr:`co_nlocals` is the number of local variables "
"used by the function (including arguments); :attr:`co_varnames` is a tuple "
"containing the names of the local variables (starting with the argument "
"names); :attr:`co_cellvars` is a tuple containing the names of local "
"variables that are referenced by nested functions; :attr:`co_freevars` is a "
"tuple containing the names of free variables; :attr:`co_code` is a string "
"representing the sequence of bytecode instructions; :attr:`co_consts` is a "
"tuple containing the literals used by the bytecode; :attr:`co_names` is a "
"tuple containing the names used by the bytecode; :attr:`co_filename` is the "
"filename from which the code was compiled; :attr:`co_firstlineno` is the "
"first line number of the function; :attr:`co_lnotab` is a string encoding "
"the mapping from bytecode offsets to line numbers (for details see the "
"source code of the interpreter); :attr:`co_stacksize` is the required stack "
"size (including local variables); :attr:`co_flags` is an integer encoding a "
"number of flags for the interpreter."
msgstr ""

#: reference/datamodel.rst:863
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""

#: reference/datamodel.rst:869
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""

#: reference/datamodel.rst:875
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ""

#: reference/datamodel.rst:879
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""

#: reference/datamodel.rst:915
msgid "Frame objects"
msgstr ""

#: reference/datamodel.rst:887
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr ""

#: reference/datamodel.rst:898
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_lasti` gives the precise instruction (this is an index into "
"the bytecode string of the code object)."
msgstr ""

#: reference/datamodel.rst:910
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called at the start of each source code line (this is used by the "
"debugger); :attr:`f_lineno` is the current line number of the frame --- "
"writing to this from within a trace function jumps to the given line (only "
"for the bottom-most frame).  A debugger can implement a Jump command (aka "
"Set Next Statement) by writing to f_lineno."
msgstr ""

#: reference/datamodel.rst:953
msgid "Traceback objects"
msgstr ""

#: reference/datamodel.rst:928
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as the third item of the "
"tuple returned by ``sys.exc_info()``. When the program contains no suitable "
"handler, the stack trace is written (nicely formatted) to the standard error "
"stream; if the interpreter is interactive, it is also made available to the "
"user as ``sys.last_traceback``."
msgstr ""

#: reference/datamodel.rst:946
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level; :attr:`tb_frame` points to the execution frame of the "
"current level; :attr:`tb_lineno` gives the line number where the exception "
"occurred; :attr:`tb_lasti` indicates the precise instruction.  The line "
"number and last instruction in the traceback may differ from the line number "
"of its frame object if the exception occurred in a :keyword:`try` statement "
"with no matching except clause or with a finally clause."
msgstr ""

#: reference/datamodel.rst:979
msgid "Slice objects"
msgstr ""

#: reference/datamodel.rst:958
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` methods.  "
"They are also created by the built-in :func:`slice` function."
msgstr ""

#: reference/datamodel.rst:966
msgid ""
"Special read-only attributes: :attr:`start` is the lower bound; :attr:`stop` "
"is the upper bound; :attr:`step` is the step value; each is ``None`` if "
"omitted. These attributes can have any type."
msgstr ""

#: reference/datamodel.rst:970
msgid "Slice objects support one method:"
msgstr ""

#: reference/datamodel.rst:974
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""

#: reference/datamodel.rst:989
msgid "Static method objects"
msgstr ""

#: reference/datamodel.rst:982
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""

#: reference/datamodel.rst:997
msgid "Class method objects"
msgstr ""

#: reference/datamodel.rst:992
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""

#: reference/datamodel.rst:1002
msgid "Special method names"
msgstr ""

#: reference/datamodel.rst:1008
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is "
"roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""

#: reference/datamodel.rst:1018
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`NodeList` interface in the W3C's "
"Document Object Model.)"
msgstr ""

#: reference/datamodel.rst:1028
msgid "Basic customization"
msgstr ""

#: reference/datamodel.rst:1034
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""

#: reference/datamodel.rst:1041
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super(currentclass, cls)."
"__new__(cls[, ...])`` with appropriate arguments and then modifying the "
"newly-created instance as necessary before returning it."
msgstr ""

#: reference/datamodel.rst:1046
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's :"
"meth:`__init__` method will be invoked like ``__init__(self[, ...])``, where "
"*self* is the new instance and the remaining arguments are the same as were "
"passed to :meth:`__new__`."
msgstr ""

#: reference/datamodel.rst:1051
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""

#: reference/datamodel.rst:1054
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""

#: reference/datamodel.rst:1063
msgid ""
"Called when the instance is created.  The arguments are those passed to the "
"class constructor expression.  If a base class has an :meth:`__init__` "
"method, the derived class's :meth:`__init__` method, if any, must explicitly "
"call it to ensure proper initialization of the base class part of the "
"instance; for example: ``BaseClass.__init__(self, [args...])``.  As a "
"special constraint on constructors, no value may be returned; doing so will "
"cause a :exc:`TypeError` to be raised at runtime."
msgstr ""

#: reference/datamodel.rst:1078
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure "
"proper deletion of the base class part of the instance.  Note that it is "
"possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  It "
"may then be called at a later time when this new reference is deleted.  It "
"is not guaranteed that :meth:`__del__` methods are called for objects that "
"still exist when the interpreter exits."
msgstr ""

#: reference/datamodel.rst:1090
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree "
"data structure with parent and child pointers); a reference to the object on "
"the stack frame of a function that caught an exception (the traceback stored "
"in ``sys.exc_info()[2]`` keeps the stack frame alive); or a reference to the "
"object on the stack frame that raised an unhandled exception in interactive "
"mode (the traceback stored in ``sys.last_traceback`` keeps the stack frame "
"alive).  The first situation can only be remedied by explicitly breaking the "
"cycles; the latter two situations can be resolved by storing ``None`` in "
"``sys.last_traceback``. Circular references which are garbage are detected "
"when the option cycle detector is enabled (it's on by default), but can only "
"be cleaned up if there are no Python- level :meth:`__del__` methods "
"involved. Refer to the documentation for the :mod:`gc` module for more "
"information about how :meth:`__del__` methods are handled by the cycle "
"detector, particularly the description of the ``garbage`` value."
msgstr ""

#: reference/datamodel.rst:1112
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is "
"invoked in response to a module being deleted (e.g., when execution of the "
"program is done), other globals referenced by the :meth:`__del__` method may "
"already have been deleted or in the process of being torn down (e.g. the "
"import machinery shutting down).  For this reason, :meth:`__del__` methods "
"should do the absolute minimum needed to maintain external invariants.  "
"Starting with version 1.5, Python guarantees that globals whose name begins "
"with a single underscore are deleted from their module before other globals "
"are deleted; if no other references to such globals exist, this may help in "
"assuring that imported modules are still available at the time when the :"
"meth:`__del__` method is called."
msgstr ""

#: reference/datamodel.rst:1133
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""

#: reference/datamodel.rst:1142
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""

#: reference/datamodel.rst:1153
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions :func:"
"`format` and :func:`print` to compute the \"informal\" or nicely printable "
"string representation of an object.  The return value must be a :ref:`string "
"<typesseq>` object."
msgstr ""

#: reference/datamodel.rst:1158
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""

#: reference/datamodel.rst:1162
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""

#: reference/datamodel.rst:1172
msgid ""
"Called by :func:`bytes` to compute a byte-string representation of an "
"object. This should return a ``bytes`` object."
msgstr ""

#: reference/datamodel.rst:1183
msgid ""
"Called by the :func:`format` built-in function (and by extension, the :meth:"
"`str.format` method of class :class:`str`) to produce a \"formatted\" string "
"representation of an object. The ``format_spec`` argument is a string that "
"contains a description of the formatting options desired. The interpretation "
"of the ``format_spec`` argument is up to the type implementing :meth:"
"`__format__`, however most classes will either delegate formatting to one of "
"the built-in types, or use a similar formatting option syntax."
msgstr ""

#: reference/datamodel.rst:1192
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""

#: reference/datamodel.rst:1194
msgid "The return value must be a string object."
msgstr ""

#: reference/datamodel.rst:1208
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""

#: reference/datamodel.rst:1214
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""

#: reference/datamodel.rst:1221
msgid ""
"There are no implied relationships among the comparison operators. The truth "
"of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when "
"defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the "
"operators will behave as expected.  See the paragraph on :meth:`__hash__` "
"for some important notes on creating :term:`hashable` objects which support "
"custom comparison operations and are usable as dictionary keys."
msgstr ""

#: reference/datamodel.rst:1228
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection."
msgstr ""

#: reference/datamodel.rst:1234
msgid "Arguments to rich comparison methods are never coerced."
msgstr ""

#: reference/datamodel.rst:1236
msgid ""
"To automatically generate ordering operations from a single root operation, "
"see :func:`functools.total_ordering`."
msgstr ""

#: reference/datamodel.rst:1245
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  :meth:`__hash__` should return an integer.  The only required "
"property is that objects which compare equal have the same hash value; it is "
"advised to somehow mix together (e.g. using exclusive or) the hash values "
"for the components of the object that also play a part in comparison of "
"objects."
msgstr ""

#: reference/datamodel.rst:1252
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of hashable collections requires that a key's hash value is "
"immutable (if the object's hash value changes, it will be in the wrong hash "
"bucket)."
msgstr ""

#: reference/datamodel.rst:1262
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns ``id(x)``."
msgstr ""

#: reference/datamodel.rst:1266
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.Hashable``)."
msgstr ""

#: reference/datamodel.rst:1273
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""

#: reference/datamodel.rst:1277
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.Hashable)`` call."
msgstr ""

#: reference/datamodel.rst:1283
msgid "See also the :option:`-R` command-line option."
msgstr ""

#: reference/datamodel.rst:1290
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither :meth:"
"`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""

#: reference/datamodel.rst:1301
msgid "Customizing attribute access"
msgstr ""

#: reference/datamodel.rst:1303
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""

#: reference/datamodel.rst:1311
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class "
"tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""

#: reference/datamodel.rst:1316
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""

#: reference/datamodel.rst:1329
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""

#: reference/datamodel.rst:1340
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr ""

#: reference/datamodel.rst:1347
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""

#: reference/datamodel.rst:1351
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""

#: reference/datamodel.rst:1358
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""

#: reference/datamodel.rst:1364
msgid ""
"Called when :func:`dir` is called on the object.  A list must be returned."
msgstr ""

#: reference/datamodel.rst:1370
msgid "Implementing Descriptors"
msgstr ""

#: reference/datamodel.rst:1372
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the attribute"
"\" refers to the attribute whose name is the key of the property in the "
"owner class' :attr:`__dict__`."
msgstr ""

#: reference/datamodel.rst:1382
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr ""

#: reference/datamodel.rst:1392
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""

#: reference/datamodel.rst:1398
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""

#: reference/datamodel.rst:1404
msgid "Invoking Descriptors"
msgstr ""

#: reference/datamodel.rst:1406
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""

#: reference/datamodel.rst:1411
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""

#: reference/datamodel.rst:1416
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""

#: reference/datamodel.rst:1421
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""

#: reference/datamodel.rst:1426
msgid "Direct Call"
msgstr ""

#: reference/datamodel.rst:1425
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""

#: reference/datamodel.rst:1430
msgid "Instance Binding"
msgstr ""

#: reference/datamodel.rst:1429
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""

#: reference/datamodel.rst:1434
msgid "Class Binding"
msgstr ""

#: reference/datamodel.rst:1433
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""

#: reference/datamodel.rst:1440
msgid "Super Binding"
msgstr ""

#: reference/datamodel.rst:1437
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj)."
"m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""

#: reference/datamodel.rst:1442
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return "
"the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or :meth:"
"`__delete__`, it is a data descriptor; if it defines neither, it is a non-"
"data descriptor.  Normally, data descriptors define both :meth:`__get__` "
"and :meth:`__set__`, while non-data descriptors have just the :meth:"
"`__get__` method.  Data descriptors with :meth:`__set__` and :meth:`__get__` "
"defined always override a redefinition in an instance dictionary.  In "
"contrast, non-data descriptors can be overridden by instances."
msgstr ""

#: reference/datamodel.rst:1455
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors "
"that differ from other instances of the same class."
msgstr ""

#: reference/datamodel.rst:1460
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""

#: reference/datamodel.rst:1467
msgid "__slots__"
msgstr "__slots__"

#: reference/datamodel.rst:1469
msgid ""
"By default, instances of classes have a dictionary for attribute storage.  "
"This wastes space for objects having very few instance variables.  The space "
"consumption can become acute when creating large numbers of instances."
msgstr ""

#: reference/datamodel.rst:1473
msgid ""
"The default can be overridden by defining *__slots__* in a class definition. "
"The *__slots__* declaration takes a sequence of instance variables and "
"reserves just enough space in each instance to hold a value for each "
"variable.  Space is saved because *__dict__* is not created for each "
"instance."
msgstr ""

#: reference/datamodel.rst:1481
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  If defined in a class, "
"*__slots__* reserves space for the declared variables and prevents the "
"automatic creation of *__dict__* and *__weakref__* for each instance."
msgstr ""

#: reference/datamodel.rst:1488
msgid "Notes on using *__slots__*"
msgstr ""

#: reference/datamodel.rst:1490
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* attribute "
"of that class will always be accessible, so a *__slots__* definition in the "
"subclass is meaningless."
msgstr ""

#: reference/datamodel.rst:1494
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted "
"variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""

#: reference/datamodel.rst:1500
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""

#: reference/datamodel.rst:1505
msgid ""
"*__slots__* are implemented at the class level by creating descriptors (:ref:"
"`descriptors`) for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""

#: reference/datamodel.rst:1511
msgid ""
"The action of a *__slots__* declaration is limited to the class where it is "
"defined.  As a result, subclasses will have a *__dict__* unless they also "
"define *__slots__* (which must only contain names of any *additional* slots)."
msgstr ""

#: reference/datamodel.rst:1515
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""

#: reference/datamodel.rst:1520
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-length"
"\" built-in types such as :class:`int`, :class:`str` and :class:`tuple`."
msgstr ""

#: reference/datamodel.rst:1523
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be "
"used; however, in the future, special meaning may be assigned to the values "
"corresponding to each key."
msgstr ""

#: reference/datamodel.rst:1527
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr ""

#: reference/datamodel.rst:1533
msgid "Customizing class creation"
msgstr ""

#: reference/datamodel.rst:1535
msgid ""
"By default, classes are constructed using :func:`type`. A class definition "
"is read into a separate namespace and the value of class name is bound to "
"the result of ``type(name, bases, dict)``."
msgstr ""

#: reference/datamodel.rst:1539
msgid ""
"When the class definition is read, if a callable ``metaclass`` keyword "
"argument is passed after the bases in the class definition, the callable "
"given will be called instead of :func:`type`.  If other keyword arguments "
"are passed, they will also be passed to the metaclass.  This allows classes "
"or functions to be written which monitor or alter the class creation process:"
msgstr ""

#: reference/datamodel.rst:1545
msgid "Modifying the class dictionary prior to the class being created."
msgstr ""

#: reference/datamodel.rst:1547
msgid ""
"Returning an instance of another class -- essentially performing the role of "
"a factory function."
msgstr ""

#: reference/datamodel.rst:1550
msgid ""
"These steps will have to be performed in the metaclass's :meth:`__new__` "
"method -- :meth:`type.__new__` can then be called from this method to create "
"a class with different properties.  This example adds a new element to the "
"class dictionary before creating the class::"
msgstr ""

#: reference/datamodel.rst:1560
msgid ""
"You can of course also override other class methods (or add new methods); "
"for example defining a custom :meth:`__call__` method in the metaclass "
"allows custom behavior when the class is called, e.g. not always creating a "
"new instance."
msgstr ""

#: reference/datamodel.rst:1564
msgid ""
"If the metaclass has a :meth:`__prepare__` attribute (usually implemented as "
"a class or static method), it is called before the class body is evaluated "
"with the name of the class and a tuple of its bases for arguments.  It "
"should return an object that supports the mapping interface that will be "
"used to store the namespace of the class.  The default is a plain "
"dictionary.  This could be used, for example, to keep track of the order "
"that class attributes are declared in by returning an ordered dictionary."
msgstr ""

#: reference/datamodel.rst:1572
msgid ""
"The appropriate metaclass is determined by the following precedence rules:"
msgstr ""

#: reference/datamodel.rst:1574
msgid ""
"If the ``metaclass`` keyword argument is passed with the bases, it is used."
msgstr ""

#: reference/datamodel.rst:1576
msgid "Otherwise, if there is at least one base class, its metaclass is used."
msgstr ""

#: reference/datamodel.rst:1578
msgid "Otherwise, the default metaclass (:class:`type`) is used."
msgstr ""

#: reference/datamodel.rst:1580
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored including logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""

#: reference/datamodel.rst:1585
msgid ""
"Here is an example of a metaclass that uses an :class:`collections."
"OrderedDict` to remember the order that class members were defined::"
msgstr ""

#: reference/datamodel.rst:1608
msgid ""
"When the class definition for *A* gets executed, the process begins with "
"calling the metaclass's :meth:`__prepare__` method which returns an empty :"
"class:`collections.OrderedDict`.  That mapping records the methods and "
"attributes of *A* as they are defined within the body of the class "
"statement. Once those definitions are executed, the ordered dictionary is "
"fully populated and the metaclass's :meth:`__new__` method gets invoked.  "
"That method builds the new type and it saves the ordered dictionary keys in "
"an attribute called ``members``."
msgstr ""

#: reference/datamodel.rst:1619
msgid "Customizing instance and subclass checks"
msgstr ""

#: reference/datamodel.rst:1621
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""

#: reference/datamodel.rst:1624
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""

#: reference/datamodel.rst:1631
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""

#: reference/datamodel.rst:1638
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""

#: reference/datamodel.rst:1643
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""

#: reference/datamodel.rst:1654
msgid "PEP 3119 - Introducing Abstract Base Classes"
msgstr ""

#: reference/datamodel.rst:1651
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`__instancecheck__` and :meth:"
"`__subclasscheck__`, with motivation for this functionality in the context "
"of adding Abstract Base Classes (see the :mod:`abc` module) to the language."
msgstr ""

#: reference/datamodel.rst:1661
msgid "Emulating callable objects"
msgstr ""

#: reference/datamodel.rst:1668
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, "
"arg2, ...)``."
msgstr ""

#: reference/datamodel.rst:1675
msgid "Emulating container types"
msgstr ""

#: reference/datamodel.rst:1677
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like "
"dictionaries), but can represent other containers as well.  The first set of "
"methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or "
"slice objects, which define a range of items.  It is also recommended that "
"mappings provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :"
"meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:"
"`popitem`, :meth:`copy`, and :meth:`update` behaving similar to those for "
"Python's standard dictionary objects.  The :mod:`collections` module "
"provides a :class:`MutableMapping` abstract base class to help create those "
"methods from a base set of :meth:`__getitem__`, :meth:`__setitem__`, :meth:"
"`__delitem__`, and :meth:`keys`. Mutable sequences should provide methods :"
"meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, :meth:"
"`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` and :meth:`sort`, "
"like Python standard list objects.  Finally, sequence types should implement "
"addition (meaning concatenation) and multiplication (meaning repetition) by "
"defining the methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :"
"meth:`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; they "
"should not define other numerical operators.  It is recommended that both "
"mappings and sequences implement the :meth:`__contains__` method to allow "
"efficient use of the ``in`` operator; for mappings, ``in`` should search the "
"mapping's keys; for sequences, it should search through the values.  It is "
"further recommended that both mappings and sequences implement the :meth:"
"`__iter__` method to allow efficient iteration through the container; for "
"mappings, :meth:`__iter__` should be the same as :meth:`keys`; for "
"sequences, it should iterate through the values."
msgstr ""

#: reference/datamodel.rst:1711
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__bool__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""

#: reference/datamodel.rst:1719
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr ""

#: reference/datamodel.rst:1723
msgid "is translated to ::"
msgstr ""

#: reference/datamodel.rst:1727
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr ""

#: reference/datamodel.rst:1734
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""

#: reference/datamodel.rst:1745
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""

#: reference/datamodel.rst:1751
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""

#: reference/datamodel.rst:1760
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""

#: reference/datamodel.rst:1769
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container, and should also be made available as the method :meth:`keys`."
msgstr ""

#: reference/datamodel.rst:1774
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see :ref:"
"`typeiter`."
msgstr ""

#: reference/datamodel.rst:1780
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""

#: reference/datamodel.rst:1784
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""

#: reference/datamodel.rst:1791
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr ""

#: reference/datamodel.rst:1798
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""

#: reference/datamodel.rst:1802
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""

#: reference/datamodel.rst:1811
msgid "Emulating numeric types"
msgstr ""

#: reference/datamodel.rst:1813
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""

#: reference/datamodel.rst:1838
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, "
"``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an :meth:"
"`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method "
"should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; "
"it should not be related to :meth:`__truediv__`.  Note that :meth:`__pow__` "
"should be defined to accept an optional third argument if the ternary "
"version of the built-in :func:`pow` function is to be supported."
msgstr ""

#: reference/datamodel.rst:1848
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""

#: reference/datamodel.rst:1870
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, "
"``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands. These functions are only called if the left operand does not "
"support the corresponding operation and the operands are of different types. "
"[#]_  For instance, to evaluate the expression ``x - y``, where *y* is an "
"instance of a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` "
"is called if ``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""

#: reference/datamodel.rst:1881
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""

#: reference/datamodel.rst:1886
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr ""

#: reference/datamodel.rst:1905
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, "
"``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation "
"in-place (modifying *self*) and return the result (which could be, but does "
"not have to be, *self*).  If a specific method is not defined, the augmented "
"assignment falls back to the normal methods.  For instance, to execute the "
"statement ``x += y``, where *x* is an instance of a class that has an :meth:"
"`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance of a "
"class that does not define a :meth:`__iadd__` method, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``."
msgstr ""

#: reference/datamodel.rst:1924
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""

#: reference/datamodel.rst:1939
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, :"
"func:`float` and :func:`round`.  Should return a value of the appropriate "
"type."
msgstr ""

#: reference/datamodel.rst:1946
msgid ""
"Called to implement :func:`operator.index`.  Also called whenever Python "
"needs an integer object (such as in slicing, or in the built-in :func:"
"`bin`, :func:`hex` and :func:`oct` functions). Must return an integer."
msgstr ""

#: reference/datamodel.rst:1954
msgid "With Statement Context Managers"
msgstr ""

#: reference/datamodel.rst:1956
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""

#: reference/datamodel.rst:1967
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""

#: reference/datamodel.rst:1970
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""

#: reference/datamodel.rst:1975
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`as` clause of the statement, if any."
msgstr ""

#: reference/datamodel.rst:1982
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""

#: reference/datamodel.rst:1986
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""

#: reference/datamodel.rst:1990
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""

#: reference/datamodel.rst:2004
msgid "Special method lookup"
msgstr ""

#: reference/datamodel.rst:2006
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""

#: reference/datamodel.rst:2021
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""

#: reference/datamodel.rst:2034
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""

#: reference/datamodel.rst:2043
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""

#: reference/datamodel.rst:2069
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""

#: reference/datamodel.rst:2078
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""

#: reference/datamodel.rst:2082
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which "
"is why the reflected method is not called."
msgstr ""

#: reference/executionmodel.rst:6
msgid "Execution model"
msgstr ""

#: reference/executionmodel.rst:14
msgid "Naming and binding"
msgstr ""

#: reference/executionmodel.rst:25
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations. Each occurrence of a name in the program text refers to the :dfn:"
"`binding` of that name established in the innermost function block "
"containing the use."
msgstr ""

#: reference/executionmodel.rst:31
msgid ""
"A :dfn:`block` is a piece of Python program text that is executed as a unit. "
"The following are blocks: a module, a function body, and a class definition. "
"Each command typed interactively is a block.  A script file (a file given as "
"standard input to the interpreter or specified on the interpreter command "
"line the first argument) is a code block.  A script command (a command "
"specified on the interpreter command line with the '**-c**' option) is a "
"code block.  The string argument passed to the built-in functions :func:"
"`eval` and :func:`exec` is a code block."
msgstr ""

#: reference/executionmodel.rst:42
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""

#: reference/executionmodel.rst:48
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name.  The scope of names defined in a class block "
"is limited to the class block; it does not extend to the code blocks of "
"methods -- this includes comprehensions and generator expressions since they "
"are implemented using a function scope.  This means that the following will "
"fail::"
msgstr ""

#: reference/executionmodel.rst:63
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""

#: reference/executionmodel.rst:69
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal`.  If a name is bound at the module level, it "
"is a global variable.  (The variables of the module code block are local and "
"global.)  If a variable is used in a code block but not defined there, it is "
"a :dfn:`free variable`."
msgstr ""

#: reference/executionmodel.rst:79
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised.  If "
"the name refers to a local variable that has not been bound, a :exc:"
"`UnboundLocalError` exception is raised.  :exc:`UnboundLocalError` is a "
"subclass of :exc:`NameError`."
msgstr ""

#: reference/executionmodel.rst:86
msgid ""
"The following constructs bind names: formal parameters to functions, :"
"keyword:`import` statements, class and function definitions (these bind the "
"class or function name in the defining block), and targets that are "
"identifiers if occurring in an assignment, :keyword:`for` loop header, or "
"after :keyword:`as` in a :keyword:`with` statement or :keyword:`except` "
"clause. The :keyword:`import` statement of the form ``from ... import *`` "
"binds all names defined in the imported module, except those beginning with "
"an underscore.  This form may only be used at the module level."
msgstr ""

#: reference/executionmodel.rst:96
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""

#: reference/executionmodel.rst:99
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""

#: reference/executionmodel.rst:102
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations."
msgstr ""

#: reference/executionmodel.rst:109
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"name specified in the statement refer to the binding of that name in the top-"
"level namespace.  Names are resolved in the top-level namespace by searching "
"the global namespace, i.e. the namespace of the module containing the code "
"block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the name is not "
"found there, the builtins namespace is searched.  The global statement must "
"precede all uses of the name."
msgstr ""

#: reference/executionmodel.rst:121
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself.  ``__builtins__`` can be set to a user-created "
"dictionary to create a weak form of restricted execution."
msgstr ""

#: reference/executionmodel.rst:132
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""

#: reference/executionmodel.rst:139
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""

#: reference/executionmodel.rst:142
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""

#: reference/executionmodel.rst:146
msgid ""
"A class definition is an executable statement that may use and define names. "
"These references follow the normal rules for name resolution.  The namespace "
"of the class definition becomes the attribute dictionary of the class.  "
"Names defined at the class scope are not visible in methods."
msgstr ""

#: reference/executionmodel.rst:155
msgid "Interaction with dynamic features"
msgstr ""

#: reference/executionmodel.rst:157
msgid ""
"There are several cases where Python statements are illegal when used in "
"conjunction with nested scopes that contain free variables."
msgstr ""

#: reference/executionmodel.rst:160
msgid ""
"If a variable is referenced in an enclosing scope, it is illegal to delete "
"the name.  An error will be reported at compile time."
msgstr ""

#: reference/executionmodel.rst:163
msgid ""
"If the wild card form of import --- ``import *`` --- is used in a function "
"and the function contains or is a nested block with free variables, the "
"compiler will raise a :exc:`SyntaxError`."
msgstr ""

#: reference/executionmodel.rst:169
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""

#: reference/executionmodel.rst:180
msgid "Exceptions"
msgstr "Les exceptions"

#: reference/executionmodel.rst:191
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""

#: reference/executionmodel.rst:197
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""

#: reference/executionmodel.rst:207
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""

#: reference/executionmodel.rst:214
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack backtrace, except when the exception is :exc:"
"`SystemExit`."
msgstr ""

#: reference/executionmodel.rst:218
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a base class thereof.  The instance can be received "
"by the handler and can carry additional information about the exceptional "
"condition."
msgstr ""

#: reference/executionmodel.rst:225
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""

#: reference/executionmodel.rst:229
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""

#: reference/executionmodel.rst:235
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""

#: reference/expressions.rst:6
msgid "Expressions"
msgstr ""

#: reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""

#: reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""

#: reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""

#: reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr ""

#: reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" this means that the "
"operator implementation for built-in types works that way:"
msgstr ""

#: reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""

#: reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""

#: reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""

#: reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""

#: reference/expressions.rst:48
msgid "Atoms"
msgstr ""

#: reference/expressions.rst:52
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""

#: reference/expressions.rst:65
msgid "Identifiers (Names)"
msgstr ""

#: reference/expressions.rst:69
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""

#: reference/expressions.rst:75
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""

#: reference/expressions.rst:83
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name in front of "
"the name, with leading underscores removed, and a single underscore inserted "
"in front of the class name.  For example, the identifier ``__spam`` "
"occurring in a class named ``Ham`` will be transformed to ``_Ham__spam``.  "
"This transformation is independent of the syntactical context in which the "
"identifier is used.  If the transformed name is extremely long (longer than "
"255 characters), implementation defined truncation may happen.  If the class "
"name consists only of underscores, no transformation is done."
msgstr ""

#: reference/expressions.rst:100 reference/lexical_analysis.rst:386
msgid "Literals"
msgstr ""

#: reference/expressions.rst:104
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""

#: reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: reference/expressions.rst:119
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""

#: reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr ""

#: reference/expressions.rst:133
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""

#: reference/expressions.rst:138
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""

#: reference/expressions.rst:144
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the rules for literals apply (i.e., two occurrences of the empty "
"tuple may or may not yield the same object)."
msgstr ""

#: reference/expressions.rst:152
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""

#: reference/expressions.rst:161
msgid "Displays for lists, sets and dictionaries"
msgstr ""

#: reference/expressions.rst:163
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""

#: reference/expressions.rst:166
msgid "either the container contents are listed explicitly, or"
msgstr ""

#: reference/expressions.rst:168
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""

#: reference/expressions.rst:171
msgid "Common syntax elements for comprehensions are:"
msgstr ""

#: reference/expressions.rst:179
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if` "
"clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr ""

#: reference/expressions.rst:186
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr ""

#: reference/expressions.rst:193
msgid "List displays"
msgstr ""

#: reference/expressions.rst:201
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""

#: reference/expressions.rst:207
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""

#: reference/expressions.rst:217
msgid "Set displays"
msgstr ""

#: reference/expressions.rst:222
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""

#: reference/expressions.rst:228
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""

#: reference/expressions.rst:234
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""

#: reference/expressions.rst:241
msgid "Dictionary displays"
msgstr ""

#: reference/expressions.rst:247
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""

#: reference/expressions.rst:256
msgid "A dictionary display yields a new dictionary object."
msgstr ""

#: reference/expressions.rst:258
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""

#: reference/expressions.rst:264
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""

#: reference/expressions.rst:272
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""

#: reference/expressions.rst:282
#, fuzzy
msgid "Generator expressions"
msgstr "Expressions et générateurs"

#: reference/expressions.rst:287
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""

#: reference/expressions.rst:292
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""

#: reference/expressions.rst:296
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for generator object (in the "
"same fashion as normal generators).  However, the leftmost :keyword:`for` "
"clause is immediately evaluated, so that an error produced by it can be seen "
"before any other possible error in the code that handles the generator "
"expression. Subsequent :keyword:`for` clauses cannot be evaluated "
"immediately since they may depend on the previous :keyword:`for` loop. For "
"example: ``(x*y for x in range(10) for y in bar(x))``."
msgstr ""

#: reference/expressions.rst:305
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for the detail."
msgstr ""

#: reference/expressions.rst:312
msgid "Yield expressions"
msgstr ""

#: reference/expressions.rst:323
msgid ""
"The :keyword:`yield` expression is only used when defining a generator "
"function, and can only be used in the body of a function definition.  Using "
"a :keyword:`yield` expression in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""

#: reference/expressions.rst:328
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of a generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first :keyword:`yield` "
"expression, where it is suspended again, returning the value of :token:"
"`expression_list` to generator's caller.  By suspended we mean that all "
"local state is retained, including the current bindings of local variables, "
"the instruction pointer, and the internal evaluation stack.  When the "
"execution is resumed by calling one of the generator's methods, the function "
"can proceed exactly as if the :keyword:`yield` expression was just another "
"external call.  The value of the :keyword:`yield` expression after resuming "
"depends on the method which resumed the execution."
msgstr ""

#: reference/expressions.rst:343
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where should the execution continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""

#: reference/expressions.rst:349 reference/simple_stmts.rst:465
msgid ""
"The :keyword:`yield` statement is allowed in the :keyword:`try` clause of a :"
"keyword:`try` ...  :keyword:`finally` construct.  If the generator is not "
"resumed before it is finalized (by reaching a zero reference count or by "
"being garbage collected), the generator-iterator's :meth:`close` method will "
"be called, allowing any pending :keyword:`finally` clauses to execute."
msgstr ""

#: reference/expressions.rst:359
msgid "Generator-iterator methods"
msgstr ""

#: reference/expressions.rst:361
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""

#: reference/expressions.rst:364
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""

#: reference/expressions.rst:372
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed :keyword:`yield` expression.  When a generator function is resumed "
"with a :meth:`~generator.__next__` method, the current :keyword:`yield` "
"expression always evaluates to :const:`None`.  The execution then continues "
"to the next :keyword:`yield` expression, where the generator is suspended "
"again, and the value of the :token:`expression_list` is returned to :meth:"
"`next`'s caller. If the generator exits without yielding another value, a :"
"exc:`StopIteration` exception is raised."
msgstr ""

#: reference/expressions.rst:382
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""

#: reference/expressions.rst:388
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The ``value`` argument becomes the result of the current :keyword:`yield` "
"expression.  The :meth:`send` method returns the next value yielded by the "
"generator, or raises :exc:`StopIteration` if the generator exits without "
"yielding another value.  When :meth:`send` is called to start the generator, "
"it must be called with :const:`None` as the argument, because there is no :"
"keyword:`yield` expression that could receive the value."
msgstr ""

#: reference/expressions.rst:399
msgid ""
"Raises an exception of type ``type`` at the point where generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in "
"exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""

#: reference/expressions.rst:410
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then raises :exc:`StopIteration` (by "
"exiting normally, or due to already being closed) or :exc:`GeneratorExit` "
"(by not catching the exception), close returns to its caller.  If the "
"generator yields a value, a :exc:`RuntimeError` is raised.  If the generator "
"raises any other exception, it is propagated to the caller.  :meth:`close` "
"does nothing if the generator has already exited due to an exception or "
"normal exit."
msgstr ""

#: reference/expressions.rst:418
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""

#: reference/expressions.rst:449 reference/simple_stmts.rst:474
msgid "PEP 0255 - Simple Generators"
msgstr ""

#: reference/expressions.rst:449 reference/simple_stmts.rst:474
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""

#: reference/expressions.rst:452 reference/simple_stmts.rst:477
msgid "PEP 0342 - Coroutines via Enhanced Generators"
msgstr ""

#: reference/expressions.rst:452
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""

#: reference/expressions.rst:459
msgid "Primaries"
msgstr ""

#: reference/expressions.rst:463
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""

#: reference/expressions.rst:473
msgid "Attribute references"
msgstr ""

#: reference/expressions.rst:477
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""

#: reference/expressions.rst:487
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier (which can be customized by "
"overriding the :meth:`__getattr__` method).  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""

#: reference/expressions.rst:499
msgid "Subscriptions"
msgstr ""

#: reference/expressions.rst:512
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""

#: reference/expressions.rst:518
msgid ""
"The primary must evaluate to an object that supports subscription, e.g. a "
"list or dictionary.  User-defined objects can support subscription by "
"defining a :meth:`__getitem__` method."
msgstr ""

#: reference/expressions.rst:522
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr ""

#: reference/expressions.rst:524
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list "
"is a tuple except if it has exactly one item.)"
msgstr ""

#: reference/expressions.rst:529
msgid ""
"If the primary is a sequence, the expression (list) must evaluate to an "
"integer or a slice (as discussed in the following section)."
msgstr ""

#: reference/expressions.rst:532
msgid ""
"The formal syntax makes no special provision for negative indices in "
"sequences; however, built-in sequences all provide a :meth:`__getitem__` "
"method that interprets negative indices by adding the length of the sequence "
"to the index (so that ``x[-1]`` selects the last item of ``x``).  The "
"resulting value must be a nonnegative integer less than the number of items "
"in the sequence, and the subscription selects the item whose index is that "
"value (counting from zero). Since the support for negative indices and "
"slicing occurs in the object's :meth:`__getitem__` method, subclasses "
"overriding this method will need to explicitly add that support."
msgstr ""

#: reference/expressions.rst:546
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr ""

#: reference/expressions.rst:553
msgid "Slicings"
msgstr ""

#: reference/expressions.rst:565
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""

#: reference/expressions.rst:578
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""

#: reference/expressions.rst:590
msgid ""
"The semantics for a slicing are as follows.  The primary must evaluate to a "
"mapping object, and it is indexed (using the same :meth:`__getitem__` method "
"as normal subscription) with a key that is constructed from the slice list, "
"as follows.  If the slice list contains at least one comma, the key is a "
"tuple containing the conversion of the slice items; otherwise, the "
"conversion of the lone slice item is the key.  The conversion of a slice "
"item that is an expression is that expression.  The conversion of a proper "
"slice is a slice object (see section :ref:`types`) whose :attr:`start`, :"
"attr:`stop` and :attr:`step` attributes are the values of the expressions "
"given as lower bound, upper bound and stride, respectively, substituting "
"``None`` for missing expressions."
msgstr ""

#: reference/expressions.rst:611
msgid "Calls"
msgstr "Appels"

#: reference/expressions.rst:613
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""

#: reference/expressions.rst:629
msgid ""
"A trailing comma may be present after the positional and keyword arguments "
"but does not affect the semantics."
msgstr ""

#: reference/expressions.rst:635
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""

#: reference/expressions.rst:643
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""

#: reference/expressions.rst:663
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""

#: reference/expressions.rst:669
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""

#: reference/expressions.rst:675
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""

#: reference/expressions.rst:685
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an iterable.  Elements from this iterable are treated as if "
"they were additional positional arguments; if there are positional arguments "
"*x1*, ..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, "
"*y1*, ..., *yM*."
msgstr ""

#: reference/expressions.rst:692
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* some keyword arguments, it is processed *before* the keyword "
"arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""

#: reference/expressions.rst:708
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""

#: reference/expressions.rst:714
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a mapping, the contents of which are treated as additional "
"keyword arguments.  In the case of a keyword appearing in both "
"``expression`` and as an explicit keyword argument, a :exc:`TypeError` "
"exception is raised."
msgstr ""

#: reference/expressions.rst:719
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""

#: reference/expressions.rst:722
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""

#: reference/expressions.rst:726
msgid "If it is---"
msgstr ""

#: reference/expressions.rst:739
msgid "a user-defined function:"
msgstr ""

#: reference/expressions.rst:735
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""

#: reference/expressions.rst:753
msgid "a built-in function or method:"
msgstr ""

#: reference/expressions.rst:752
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""

#: reference/expressions.rst:760
msgid "a class object:"
msgstr ""

#: reference/expressions.rst:760
msgid "A new instance of that class is returned."
msgstr ""

#: reference/expressions.rst:770
msgid "a class instance method:"
msgstr ""

#: reference/expressions.rst:768
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""

#: reference/expressions.rst:779
msgid "a class instance:"
msgstr ""

#: reference/expressions.rst:777
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""

#: reference/expressions.rst:784
msgid "The power operator"
msgstr ""

#: reference/expressions.rst:786
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""

#: reference/expressions.rst:792
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""

#: reference/expressions.rst:796
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""

#: reference/expressions.rst:801
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""

#: reference/expressions.rst:806
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""

#: reference/expressions.rst:814
msgid "Unary arithmetic and bitwise operations"
msgstr ""

#: reference/expressions.rst:820
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""

#: reference/expressions.rst:829
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""

#: reference/expressions.rst:833
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""

#: reference/expressions.rst:838
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers."
msgstr ""

#: reference/expressions.rst:844
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""

#: reference/expressions.rst:851
msgid "Binary arithmetic operations"
msgstr ""

#: reference/expressions.rst:855
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""

#: reference/expressions.rst:867
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""

#: reference/expressions.rst:877
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Integer division yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""

#: reference/expressions.rst:886
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""

#: reference/expressions.rst:895
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""

#: reference/expressions.rst:900
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""

#: reference/expressions.rst:905
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: reference/expressions.rst:911
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both sequences of the same type.  "
"In the former case, the numbers are converted to a common type and then "
"added together.  In the latter case, the sequences are concatenated."
msgstr ""

#: reference/expressions.rst:918
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""

#: reference/expressions.rst:925
msgid "Shifting operations"
msgstr ""

#: reference/expressions.rst:929
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""

#: reference/expressions.rst:934
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""

#: reference/expressions.rst:939
msgid ""
"A right shift by *n* bits is defined as division by ``pow(2,n)``.  A left "
"shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""

#: reference/expressions.rst:944
msgid ""
"In the current implementation, the right-hand operand is required to be at "
"most :attr:`sys.maxsize`.  If the right-hand operand is larger than :attr:"
"`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""

#: reference/expressions.rst:951
msgid "Binary bitwise operations"
msgstr ""

#: reference/expressions.rst:955
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""

#: reference/expressions.rst:964
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers."
msgstr ""

#: reference/expressions.rst:971
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers."
msgstr ""

#: reference/expressions.rst:978
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers."
msgstr ""

#: reference/expressions.rst:989
msgid "Comparisons"
msgstr "Comparaisons"

#: reference/expressions.rst:995
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""

#: reference/expressions.rst:1005
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""

#: reference/expressions.rst:1009
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""

#: reference/expressions.rst:1013
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""

#: reference/expressions.rst:1018
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""

#: reference/expressions.rst:1022
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects need not have the same type. If both are "
"numbers, they are converted to a common type.  Otherwise, the ``==`` and ``!"
"=`` operators *always* consider objects of different types to be unequal, "
"while the ``<``, ``>``, ``>=`` and ``<=`` operators raise a :exc:`TypeError` "
"when comparing objects of different types that do not implement these "
"operators for the given pair of types.  You can control comparison behavior "
"of objects of non-built-in types by defining rich comparison methods like :"
"meth:`__gt__`, described in section :ref:`customization`."
msgstr ""

#: reference/expressions.rst:1032
msgid "Comparison of objects of the same type depends on the type:"
msgstr ""

#: reference/expressions.rst:1034
msgid "Numbers are compared arithmetically."
msgstr ""

#: reference/expressions.rst:1036
msgid ""
"The values :const:`float('NaN')` and :const:`Decimal('NaN')` are special. "
"The are identical to themselves, ``x is x`` but are not equal to themselves, "
"``x != x``.  Additionally, comparing any value to a not-a-number value will "
"return ``False``.  For example, both ``3 < float('NaN')`` and ``float('NaN') "
"< 3`` will return ``False``."
msgstr ""

#: reference/expressions.rst:1042
msgid ""
"Bytes objects are compared lexicographically using the numeric values of "
"their elements."
msgstr ""

#: reference/expressions.rst:1045
msgid ""
"Strings are compared lexicographically using the numeric equivalents (the "
"result of the built-in function :func:`ord`) of their characters. [#]_ "
"String and bytes object can't be compared!"
msgstr ""

#: reference/expressions.rst:1049
msgid ""
"Tuples and lists are compared lexicographically using comparison of "
"corresponding elements.  This means that to compare equal, each element must "
"compare equal and the two sequences must be of the same type and have the "
"same length."
msgstr ""

#: reference/expressions.rst:1054
msgid ""
"If not equal, the sequences are ordered the same as their first differing "
"elements.  For example, ``[1,2,x] <= [1,2,y]`` has the same value as ``x <= "
"y``.  If the corresponding element does not exist, the shorter sequence is "
"ordered first (for example, ``[1,2] < [1,2,3]``)."
msgstr ""

#: reference/expressions.rst:1059
msgid ""
"Mappings (dictionaries) compare equal if and only if they have the same "
"``(key, value)`` pairs. Order comparisons ``('<', '<=', '>=', '>')`` raise :"
"exc:`TypeError`."
msgstr ""

#: reference/expressions.rst:1063
msgid ""
"Sets and frozensets define comparison operators to mean subset and superset "
"tests.  Those relations do not define total orderings (the two sets ``{1,2}"
"`` and {2,3} are not equal, nor subsets of one another, nor supersets of one "
"another).  Accordingly, sets are not appropriate arguments for functions "
"which depend on total ordering.  For example, :func:`min`, :func:`max`, and :"
"func:`sorted` produce undefined results given a list of sets as inputs."
msgstr ""

#: reference/expressions.rst:1070
msgid ""
"Most other objects of built-in types compare unequal unless they are the "
"same object; the choice whether one object is considered smaller or larger "
"than another one is made arbitrarily but consistently within one execution "
"of a program."
msgstr ""

#: reference/expressions.rst:1075
msgid ""
"Comparison of objects of the differing types depends on whether either of "
"the types provide explicit support for the comparison.  Most numeric types "
"can be compared with one another.  When cross-type comparison is not "
"supported, the comparison method returns ``NotImplemented``."
msgstr ""

#: reference/expressions.rst:1082
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to true if *x* is a member of *s*, and false otherwise.  "
"``x not in s`` returns the negation of ``x in s``.  All built-in sequences "
"and set types support this as well as dictionary, for which :keyword:`in` "
"tests whether a the dictionary has a given key. For container types such as "
"list, tuple, set, frozenset, dict, or collections.deque, the expression ``x "
"in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""

#: reference/expressions.rst:1090
msgid ""
"For the string and bytes types, ``x in y`` is true if and only if *x* is a "
"substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty strings "
"are always considered to be a substring of any other string, so ``\"\" in "
"\"abc\"`` will return ``True``."
msgstr ""

#: reference/expressions.rst:1095
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` is true if and only if ``y.__contains__(x)`` is true."
msgstr ""

#: reference/expressions.rst:1098
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is true if some value ``z`` with ``x == "
"z`` is produced while iterating over ``y``.  If an exception is raised "
"during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""

#: reference/expressions.rst:1103
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is true if and only if there is a non-negative "
"integer index *i* such that ``x == y[i]``, and all lower integer indices do "
"not raise :exc:`IndexError` exception.  (If any other exception is raised, "
"it is as if :keyword:`in` raised that exception)."
msgstr ""

#: reference/expressions.rst:1115
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of :"
"keyword:`in`."
msgstr ""

#: reference/expressions.rst:1123
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr ""

#: reference/expressions.rst:1134
msgid "Boolean operations"
msgstr ""

#: reference/expressions.rst:1145
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""

#: reference/expressions.rst:1154
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""

#: reference/expressions.rst:1159
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: reference/expressions.rst:1164
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: reference/expressions.rst:1167
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"invent a value anyway, it does not bother to return a value of the same type "
"as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr ""

#: reference/expressions.rst:1177
msgid "Conditional expressions"
msgstr ""

#: reference/expressions.rst:1188
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""

#: reference/expressions.rst:1191
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* (*not* "
"*x*); if *C* is true, *x* is evaluated and its value is returned; otherwise, "
"*y* is evaluated and its value is returned."
msgstr ""

#: reference/expressions.rst:1195
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""

#: reference/expressions.rst:1202
msgid "Lambdas"
msgstr ""

#: reference/expressions.rst:1213
msgid ""
"Lambda forms (lambda expressions) have the same syntactic position as "
"expressions.  They are a shorthand to create anonymous functions; the "
"expression ``lambda arguments: expression`` yields a function object.  The "
"unnamed object behaves like a function object defined with ::"
msgstr ""

#: reference/expressions.rst:1221
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda forms cannot contain statements or annotations."
msgstr ""

#: reference/expressions.rst:1228
msgid "Expression lists"
msgstr ""

#: reference/expressions.rst:1237
msgid ""
"An expression list containing at least one comma yields a tuple.  The length "
"of the tuple is the number of expressions in the list.  The expressions are "
"evaluated from left to right."
msgstr ""

#: reference/expressions.rst:1243
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""

#: reference/expressions.rst:1253
msgid "Evaluation order"
msgstr ""

#: reference/expressions.rst:1257
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""

#: reference/expressions.rst:1260
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""

#: reference/expressions.rst:1274
msgid "Operator precedence"
msgstr ""

#: reference/expressions.rst:1278
msgid ""
"The following table summarizes the operator precedences in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for comparisons, including tests, which all have the "
"same precedence and chain from left to right --- see section :ref:"
"`comparisons` --- and exponentiation, which groups from right to left)."
msgstr ""

#: reference/expressions.rst:1288
msgid "Operator"
msgstr ""

#: reference/expressions.rst:1288
msgid "Description"
msgstr "Description"

#: reference/expressions.rst:1290
msgid ":keyword:`lambda`"
msgstr ""

#: reference/expressions.rst:1290
#, fuzzy
msgid "Lambda expression"
msgstr "Fonctions anonymes"

#: reference/expressions.rst:1292
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ""

#: reference/expressions.rst:1292
msgid "Conditional expression"
msgstr ""

#: reference/expressions.rst:1294
msgid ":keyword:`or`"
msgstr ""

#: reference/expressions.rst:1294
msgid "Boolean OR"
msgstr ""

#: reference/expressions.rst:1296
msgid ":keyword:`and`"
msgstr ""

#: reference/expressions.rst:1296
msgid "Boolean AND"
msgstr ""

#: reference/expressions.rst:1298
msgid ":keyword:`not` ``x``"
msgstr ""

#: reference/expressions.rst:1298
msgid "Boolean NOT"
msgstr ""

#: reference/expressions.rst:1300
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""

#: reference/expressions.rst:1300
msgid "Comparisons, including membership tests and identity tests,"
msgstr ""

#: reference/expressions.rst:1304
msgid "``|``"
msgstr ""

#: reference/expressions.rst:1304
msgid "Bitwise OR"
msgstr ""

#: reference/expressions.rst:1306
msgid "``^``"
msgstr ""

#: reference/expressions.rst:1306
msgid "Bitwise XOR"
msgstr ""

#: reference/expressions.rst:1308
msgid "``&``"
msgstr ""

#: reference/expressions.rst:1308
msgid "Bitwise AND"
msgstr ""

#: reference/expressions.rst:1310
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: reference/expressions.rst:1310
msgid "Shifts"
msgstr ""

#: reference/expressions.rst:1312
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: reference/expressions.rst:1312
msgid "Addition and subtraction"
msgstr ""

#: reference/expressions.rst:1314
msgid "``*``, ``/``, ``//``, ``%``"
msgstr ""

#: reference/expressions.rst:1314
msgid "Multiplication, division, remainder [#]_"
msgstr ""

#: reference/expressions.rst:1317
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: reference/expressions.rst:1317
msgid "Positive, negative, bitwise NOT"
msgstr ""

#: reference/expressions.rst:1319
msgid "``**``"
msgstr ""

#: reference/expressions.rst:1319
msgid "Exponentiation [#]_"
msgstr ""

#: reference/expressions.rst:1321
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""

#: reference/expressions.rst:1321
msgid "Subscription, slicing, call, attribute reference"
msgstr ""

#: reference/expressions.rst:1324
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"
msgstr ""

#: reference/expressions.rst:1324
msgid "Binding or tuple display, list display, dictionary display, set display"
msgstr ""

#: reference/expressions.rst:1333
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""

#: reference/expressions.rst:1342
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""

#: reference/expressions.rst:1347
msgid ""
"While comparisons between strings make sense at the byte level, they may be "
"counter-intuitive to users.  For example, the strings ``\"\\u00C7\"`` and ``"
"\"\\u0327\\u0043\"`` compare differently, even though they both represent "
"the same unicode character (LATIN CAPITAL LETTER C WITH CEDILLA).  To "
"compare strings in a human recognizable way, compare using :func:"
"`unicodedata.normalize`."
msgstr ""

#: reference/expressions.rst:1354
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""

#: reference/expressions.rst:1359
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""

#: reference/expressions.rst:1362
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""

#: reference/grammar.rst:2
msgid "Full Grammar specification"
msgstr ""

#: reference/grammar.rst:4
msgid ""
"This is the full Python grammar, as it is read by the parser generator and "
"used to parse Python source files:"
msgstr ""

#: reference/index.rst:5
msgid "The Python Language Reference"
msgstr ""

#: reference/index.rst:7
msgid ""
"This reference manual describes the syntax and \"core semantics\" of the "
"language. It is terse, but attempts to be exact and complete. The semantics "
"of non-essential built-in object types and of the built-in functions and "
"modules are described in :ref:`library-index`. For an informal introduction "
"to the language, see :ref:`tutorial-index`. For C or C++ programmers, two "
"additional manuals exist: :ref:`extending-index` describes the high-level "
"picture of how to write a Python extension module, and the :ref:`c-api-"
"index` describes the interfaces available to C/C++ programmers in detail."
msgstr ""

#: reference/introduction.rst:6
msgid "Introduction"
msgstr "Introduction"

#: reference/introduction.rst:8
msgid ""
"This reference manual describes the Python programming language. It is not "
"intended as a tutorial."
msgstr ""

#: reference/introduction.rst:11
msgid ""
"While I am trying to be as precise as possible, I chose to use English "
"rather than formal specifications for everything except syntax and lexical "
"analysis. This should make the document more understandable to the average "
"reader, but will leave room for ambiguities. Consequently, if you were "
"coming from Mars and tried to re-implement Python from this document alone, "
"you might have to guess things and in fact you would probably end up "
"implementing quite a different language. On the other hand, if you are using "
"Python and wonder what the precise rules about a particular area of the "
"language are, you should definitely be able to find them here. If you would "
"like to see a more formal definition of the language, maybe you could "
"volunteer your time --- or invent a cloning machine :-)."
msgstr ""

#: reference/introduction.rst:23
msgid ""
"It is dangerous to add too many implementation details to a language "
"reference document --- the implementation may change, and other "
"implementations of the same language may work differently.  On the other "
"hand, CPython is the one Python implementation in widespread use (although "
"alternate implementations continue to gain support), and its particular "
"quirks are sometimes worth being mentioned, especially where the "
"implementation imposes additional limitations. Therefore, you'll find short "
"\"implementation notes\" sprinkled throughout the text."
msgstr ""

#: reference/introduction.rst:32
msgid ""
"Every Python implementation comes with a number of built-in and standard "
"modules.  These are documented in :ref:`library-index`.  A few built-in "
"modules are mentioned when they interact in a significant way with the "
"language definition."
msgstr ""

#: reference/introduction.rst:41
msgid "Alternate Implementations"
msgstr ""

#: reference/introduction.rst:43
msgid ""
"Though there is one Python implementation which is by far the most popular, "
"there are some alternate implementations which are of particular interest to "
"different audiences."
msgstr ""

#: reference/introduction.rst:47
msgid "Known implementations include:"
msgstr ""

#: reference/introduction.rst:51
msgid "CPython"
msgstr "CPython"

#: reference/introduction.rst:50
msgid ""
"This is the original and most-maintained implementation of Python, written "
"in C. New language features generally appear here first."
msgstr ""

#: reference/introduction.rst:57
msgid "Jython"
msgstr ""

#: reference/introduction.rst:54
msgid ""
"Python implemented in Java.  This implementation can be used as a scripting "
"language for Java applications, or can be used to create applications using "
"the Java class libraries.  It is also often used to create tests for Java "
"libraries. More information can be found at `the Jython website <http://www."
"jython.org/>`_."
msgstr ""

#: reference/introduction.rst:63
msgid "Python for .NET"
msgstr ""

#: reference/introduction.rst:60
msgid ""
"This implementation actually uses the CPython implementation, but is a "
"managed .NET application and makes .NET libraries available.  It was created "
"by Brian Lloyd.  For more information, see the `Python for .NET home page "
"<http://pythonnet.sourceforge.net>`_."
msgstr ""

#: reference/introduction.rst:69
msgid "IronPython"
msgstr ""

#: reference/introduction.rst:66
msgid ""
"An alternate Python for .NET.  Unlike Python.NET, this is a complete Python "
"implementation that generates IL, and compiles Python code directly to .NET "
"assemblies.  It was created by Jim Hugunin, the original creator of Jython.  "
"For more information, see `the IronPython website <http://www.ironpython.net/"
">`_."
msgstr ""

#: reference/introduction.rst:77
msgid "PyPy"
msgstr ""

#: reference/introduction.rst:72
msgid ""
"An implementation of Python written completely in Python. It supports "
"several advanced features not found in other implementations like stackless "
"support and a Just in Time compiler. One of the goals of the project is to "
"encourage experimentation with the language itself by making it easier to "
"modify the interpreter (since it is written in Python).  Additional "
"information is available on `the PyPy project's home page <http://pypy.org/"
">`_."
msgstr ""

#: reference/introduction.rst:79
msgid ""
"Each of these implementations varies in some way from the language as "
"documented in this manual, or introduces specific information beyond what's "
"covered in the standard Python documentation.  Please refer to the "
"implementation-specific documentation to determine what else you need to "
"know about the specific implementation you're using."
msgstr ""

#: reference/introduction.rst:89
msgid "Notation"
msgstr ""

#: reference/introduction.rst:93
msgid ""
"The descriptions of lexical analysis and syntax use a modified BNF grammar "
"notation.  This uses the following style of definition:"
msgstr ""

#: reference/introduction.rst:100
msgid ""
"The first line says that a ``name`` is an ``lc_letter`` followed by a "
"sequence of zero or more ``lc_letter``\\ s and underscores.  An "
"``lc_letter`` in turn is any of the single characters ``'a'`` through "
"``'z'``.  (This rule is actually adhered to for the names defined in lexical "
"and grammar rules in this document.)"
msgstr ""

#: reference/introduction.rst:105
msgid ""
"Each rule begins with a name (which is the name defined by the rule) and ``::"
"=``.  A vertical bar (``|``) is used to separate alternatives; it is the "
"least binding operator in this notation.  A star (``*``) means zero or more "
"repetitions of the preceding item; likewise, a plus (``+``) means one or "
"more repetitions, and a phrase enclosed in square brackets (``[ ]``) means "
"zero or one occurrences (in other words, the enclosed phrase is optional).  "
"The ``*`` and ``+`` operators bind as tightly as possible; parentheses are "
"used for grouping.  Literal strings are enclosed in quotes.  White space is "
"only meaningful to separate tokens. Rules are normally contained on a single "
"line; rules with many alternatives may be formatted alternatively with each "
"line after the first beginning with a vertical bar."
msgstr ""

#: reference/introduction.rst:119
msgid ""
"In lexical definitions (as the example above), two more conventions are "
"used: Two literal characters separated by three dots mean a choice of any "
"single character in the given (inclusive) range of ASCII characters.  A "
"phrase between angular brackets (``<...>``) gives an informal description of "
"the symbol defined; e.g., this could be used to describe the notion of "
"'control character' if needed."
msgstr ""

#: reference/introduction.rst:126
msgid ""
"Even though the notation used is almost the same, there is a big difference "
"between the meaning of lexical and syntactic definitions: a lexical "
"definition operates on the individual characters of the input source, while "
"a syntax definition operates on the stream of tokens generated by the "
"lexical analysis. All uses of BNF in the next chapter (\"Lexical Analysis\") "
"are lexical definitions; uses in subsequent chapters are syntactic "
"definitions."
msgstr ""

#: reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr ""

#: reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""

#: reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""

#: reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr ""

#: reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr ""

#: reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr ""

#: reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""

#: reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr ""

#: reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files, any of the standard platform line termination "
"sequences can be used - the Unix form using ASCII LF (linefeed), the Windows "
"form using the ASCII sequence CR LF (return followed by linefeed), or the "
"old Macintosh form using the ASCII CR (return) character.  All of these "
"forms can be used equally, regardless of platform."
msgstr ""

#: reference/lexical_analysis.rst:56
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""

#: reference/lexical_analysis.rst:64
msgid "Comments"
msgstr ""

#: reference/lexical_analysis.rst:68
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax; they are not tokens."
msgstr ""

#: reference/lexical_analysis.rst:77
msgid "Encoding declarations"
msgstr ""

#: reference/lexical_analysis.rst:81
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The recommended forms of this expression "
"are ::"
msgstr ""

#: reference/lexical_analysis.rst:88
msgid "which is recognized also by GNU Emacs, and ::"
msgstr ""

#: reference/lexical_analysis.rst:92
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr ""

#: reference/lexical_analysis.rst:94
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""

#: reference/lexical_analysis.rst:99
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, including string literals, "
"comments and identifiers. The encoding declaration must appear on a line of "
"its own."
msgstr ""

#: reference/lexical_analysis.rst:109
msgid "Explicit line joining"
msgstr ""

#: reference/lexical_analysis.rst:113
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""

#: reference/lexical_analysis.rst:124
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""

#: reference/lexical_analysis.rst:134
msgid "Implicit line joining"
msgstr ""

#: reference/lexical_analysis.rst:136
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""

#: reference/lexical_analysis.rst:144
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""

#: reference/lexical_analysis.rst:154
msgid "Blank lines"
msgstr ""

#: reference/lexical_analysis.rst:158
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""

#: reference/lexical_analysis.rst:169
msgid "Indentation"
msgstr ""

#: reference/lexical_analysis.rst:173
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""

#: reference/lexical_analysis.rst:177
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""

#: reference/lexical_analysis.rst:185
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""

#: reference/lexical_analysis.rst:189
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""

#: reference/lexical_analysis.rst:194
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""

#: reference/lexical_analysis.rst:201
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""

#: reference/lexical_analysis.rst:204
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""

#: reference/lexical_analysis.rst:215
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""

#: reference/lexical_analysis.rst:230
msgid "The following example shows various indentation errors::"
msgstr ""

#: reference/lexical_analysis.rst:240
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""

#: reference/lexical_analysis.rst:248
msgid "Whitespace between tokens"
msgstr ""

#: reference/lexical_analysis.rst:250
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""

#: reference/lexical_analysis.rst:260
msgid "Other tokens"
msgstr ""

#: reference/lexical_analysis.rst:262
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""

#: reference/lexical_analysis.rst:272
msgid "Identifiers and keywords"
msgstr ""

#: reference/lexical_analysis.rst:276
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""

#: reference/lexical_analysis.rst:279
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""

#: reference/lexical_analysis.rst:283
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""

#: reference/lexical_analysis.rst:288
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""

#: reference/lexical_analysis.rst:292
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""

#: reference/lexical_analysis.rst:301
msgid "The Unicode category codes mentioned above stand for:"
msgstr ""

#: reference/lexical_analysis.rst:303
msgid "*Lu* - uppercase letters"
msgstr ""

#: reference/lexical_analysis.rst:304
msgid "*Ll* - lowercase letters"
msgstr ""

#: reference/lexical_analysis.rst:305
msgid "*Lt* - titlecase letters"
msgstr ""

#: reference/lexical_analysis.rst:306
msgid "*Lm* - modifier letters"
msgstr ""

#: reference/lexical_analysis.rst:307
msgid "*Lo* - other letters"
msgstr ""

#: reference/lexical_analysis.rst:308
msgid "*Nl* - letter numbers"
msgstr ""

#: reference/lexical_analysis.rst:309
msgid "*Mn* - nonspacing marks"
msgstr ""

#: reference/lexical_analysis.rst:310
msgid "*Mc* - spacing combining marks"
msgstr ""

#: reference/lexical_analysis.rst:311
msgid "*Nd* - decimal numbers"
msgstr ""

#: reference/lexical_analysis.rst:312
msgid "*Pc* - connector punctuations"
msgstr ""

#: reference/lexical_analysis.rst:313
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <http://"
"unicode.org/Public/UNIDATA/PropList.txt>`_ to support backwards compatibility"
msgstr ""

#: reference/lexical_analysis.rst:314
msgid "*Other_ID_Continue* - likewise"
msgstr ""

#: reference/lexical_analysis.rst:316
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""

#: reference/lexical_analysis.rst:319
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at http://www.dcl.hpi.uni-potsdam.de/home/loewis/"
"table-3131.html."
msgstr ""

#: reference/lexical_analysis.rst:327
msgid "Keywords"
msgstr ""

#: reference/lexical_analysis.rst:333
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""

#: reference/lexical_analysis.rst:350
msgid "Reserved classes of identifiers"
msgstr ""

#: reference/lexical_analysis.rst:352
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""

#: reference/lexical_analysis.rst:366
msgid "_*"
msgstr ""

#: reference/lexical_analysis.rst:357
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""

#: reference/lexical_analysis.rst:364
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""

#: reference/lexical_analysis.rst:374
msgid "__*__"
msgstr ""

#: reference/lexical_analysis.rst:369
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr ""

#: reference/lexical_analysis.rst:381
msgid "__*"
msgstr ""

#: reference/lexical_analysis.rst:377
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""

#: reference/lexical_analysis.rst:390
msgid "Literals are notations for constant values of some built-in types."
msgstr ""

#: reference/lexical_analysis.rst:396
msgid "String and Bytes literals"
msgstr ""

#: reference/lexical_analysis.rst:400
msgid "String literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:424
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or :token:"
"`bytesprefix` and the rest of the literal. The source character set is "
"defined by the encoding declaration; it is UTF-8 if no encoding declaration "
"is given in the source file; see section :ref:`encodings`."
msgstr ""

#: reference/lexical_analysis.rst:432
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""

#: reference/lexical_analysis.rst:439
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""

#: reference/lexical_analysis.rst:444
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially."
msgstr ""

#: reference/lexical_analysis.rst:449
msgid ""
"In triple-quoted strings, unescaped newlines and quotes are allowed (and are "
"retained), except that three unescaped quotes in a row terminate the "
"string.  (A \"quote\" is the character used to open the string, i.e. either "
"``'`` or ``\"``.)"
msgstr ""

#: reference/lexical_analysis.rst:455
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings "
"are interpreted according to rules similar to those used by Standard C.  The "
"recognized escape sequences are:"
msgstr ""

#: reference/lexical_analysis.rst:460 reference/lexical_analysis.rst:493
msgid "Escape Sequence"
msgstr ""

#: reference/lexical_analysis.rst:460 reference/lexical_analysis.rst:493
msgid "Notes"
msgstr "Notes"

#: reference/lexical_analysis.rst:462
msgid "``\\newline``"
msgstr "``\\newline``"

#: reference/lexical_analysis.rst:462
msgid "Backslash and newline ignored"
msgstr ""

#: reference/lexical_analysis.rst:464
msgid "``\\\\``"
msgstr ""

#: reference/lexical_analysis.rst:464
msgid "Backslash (``\\``)"
msgstr ""

#: reference/lexical_analysis.rst:466
msgid "``\\'``"
msgstr ""

#: reference/lexical_analysis.rst:466
msgid "Single quote (``'``)"
msgstr ""

#: reference/lexical_analysis.rst:468
msgid "``\\\"``"
msgstr ""

#: reference/lexical_analysis.rst:468
msgid "Double quote (``\"``)"
msgstr ""

#: reference/lexical_analysis.rst:470
msgid "``\\a``"
msgstr ""

#: reference/lexical_analysis.rst:470
msgid "ASCII Bell (BEL)"
msgstr ""

#: reference/lexical_analysis.rst:472
msgid "``\\b``"
msgstr "``\\b``"

#: reference/lexical_analysis.rst:472
msgid "ASCII Backspace (BS)"
msgstr ""

#: reference/lexical_analysis.rst:474
msgid "``\\f``"
msgstr ""

#: reference/lexical_analysis.rst:474
msgid "ASCII Formfeed (FF)"
msgstr ""

#: reference/lexical_analysis.rst:476
msgid "``\\n``"
msgstr "``\\n``"

#: reference/lexical_analysis.rst:476
msgid "ASCII Linefeed (LF)"
msgstr ""

#: reference/lexical_analysis.rst:478
msgid "``\\r``"
msgstr "``\\r``"

#: reference/lexical_analysis.rst:478
msgid "ASCII Carriage Return (CR)"
msgstr ""

#: reference/lexical_analysis.rst:480
msgid "``\\t``"
msgstr ""

#: reference/lexical_analysis.rst:480
msgid "ASCII Horizontal Tab (TAB)"
msgstr ""

#: reference/lexical_analysis.rst:482
msgid "``\\v``"
msgstr ""

#: reference/lexical_analysis.rst:482
msgid "ASCII Vertical Tab (VT)"
msgstr ""

#: reference/lexical_analysis.rst:484
msgid "``\\ooo``"
msgstr ""

#: reference/lexical_analysis.rst:484
msgid "Character with octal value *ooo*"
msgstr ""

#: reference/lexical_analysis.rst:484
msgid "(1,3)"
msgstr ""

#: reference/lexical_analysis.rst:487
msgid "``\\xhh``"
msgstr ""

#: reference/lexical_analysis.rst:487
msgid "Character with hex value *hh*"
msgstr ""

#: reference/lexical_analysis.rst:487
msgid "(2,3)"
msgstr ""

#: reference/lexical_analysis.rst:490
msgid "Escape sequences only recognized in string literals are:"
msgstr ""

#: reference/lexical_analysis.rst:495
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: reference/lexical_analysis.rst:495
msgid "Character named *name* in the Unicode database"
msgstr ""

#: reference/lexical_analysis.rst:498
msgid "``\\uxxxx``"
msgstr ""

#: reference/lexical_analysis.rst:498
msgid "Character with 16-bit hex value *xxxx*"
msgstr ""

#: reference/lexical_analysis.rst:498
msgid "\\(4)"
msgstr "\\(4)"

#: reference/lexical_analysis.rst:501
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: reference/lexical_analysis.rst:501
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr ""

#: reference/lexical_analysis.rst:501
msgid "\\(5)"
msgstr "\\(5)"

#: reference/lexical_analysis.rst:505
msgid "Notes:"
msgstr "Notes : "

#: reference/lexical_analysis.rst:508
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""

#: reference/lexical_analysis.rst:511
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""

#: reference/lexical_analysis.rst:514
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""

#: reference/lexical_analysis.rst:519
msgid ""
"Individual code units which form parts of a surrogate pair can be encoded "
"using this escape sequence.  Exactly four hex digits are required."
msgstr ""

#: reference/lexical_analysis.rst:523
msgid ""
"Any Unicode character can be encoded this way, but characters outside the "
"Basic Multilingual Plane (BMP) will be encoded using a surrogate pair if "
"Python is compiled to use 16-bit code units (the default).  Exactly eight "
"hex digits are required."
msgstr ""

#: reference/lexical_analysis.rst:531
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the string*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""

#: reference/lexical_analysis.rst:538
msgid ""
"Even in a raw string, string quotes can be escaped with a backslash, but the "
"backslash remains in the string; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw string cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the string, *not* as a line "
"continuation."
msgstr ""

#: reference/lexical_analysis.rst:551
msgid "String literal concatenation"
msgstr ""

#: reference/lexical_analysis.rst:553
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""

#: reference/lexical_analysis.rst:564
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings)."
msgstr ""

#: reference/lexical_analysis.rst:573
msgid "Numeric literals"
msgstr ""

#: reference/lexical_analysis.rst:579
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""

#: reference/lexical_analysis.rst:583
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""

#: reference/lexical_analysis.rst:591
msgid "Integer literals"
msgstr ""

#: reference/lexical_analysis.rst:593
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:607
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""

#: reference/lexical_analysis.rst:610
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""

#: reference/lexical_analysis.rst:614
msgid "Some examples of integer literals::"
msgstr ""

#: reference/lexical_analysis.rst:624
msgid "Floating point literals"
msgstr ""

#: reference/lexical_analysis.rst:626
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:636
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent. Some examples of floating point literals::"
msgstr ""

#: reference/lexical_analysis.rst:643
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator ``-`` and the literal "
"``1``."
msgstr ""

#: reference/lexical_analysis.rst:651
msgid "Imaginary literals"
msgstr ""

#: reference/lexical_analysis.rst:653
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:658
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""

#: reference/lexical_analysis.rst:670
msgid "Operators"
msgstr ""

#: reference/lexical_analysis.rst:674
msgid "The following tokens are operators::"
msgstr ""

#: reference/lexical_analysis.rst:684
msgid "Delimiters"
msgstr ""

#: reference/lexical_analysis.rst:688
msgid "The following tokens serve as delimiters in the grammar::"
msgstr ""

#: reference/lexical_analysis.rst:695
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""

#: reference/lexical_analysis.rst:700
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer::"
msgstr ""

#: reference/lexical_analysis.rst:705
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error::"
msgstr ""

#: reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr ""

#: reference/simple_stmts.rst:10
msgid ""
"Simple statements are comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""

#: reference/simple_stmts.rst:34
msgid "Expression statements"
msgstr ""

#: reference/simple_stmts.rst:41
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""

#: reference/simple_stmts.rst:50
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""

#: reference/simple_stmts.rst:62
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""

#: reference/simple_stmts.rst:70
msgid "Assignment statements"
msgstr ""

#: reference/simple_stmts.rst:79
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""

#: reference/simple_stmts.rst:93 reference/simple_stmts.rst:273
msgid ""
"(See section :ref:`primaries` for the syntax definitions for the last three "
"symbols.)"
msgstr ""

#: reference/simple_stmts.rst:96
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""

#: reference/simple_stmts.rst:105
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""

#: reference/simple_stmts.rst:114
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""

#: reference/simple_stmts.rst:117
msgid ""
"If the target list is a single target: The object is assigned to that target."
msgstr ""

#: reference/simple_stmts.rst:119
msgid ""
"If the target list is a comma-separated list of targets: The object must be "
"an iterable with the same number of items as there are targets in the target "
"list, and the items are assigned, from left to right, to the corresponding "
"targets."
msgstr ""

#: reference/simple_stmts.rst:123
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be a sequence with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the sequence are assigned, from left to right, to the targets before the "
"starred target.  The final items of the sequence are assigned to the targets "
"after the starred target.  A list of the remaining items in the sequence is "
"then assigned to the starred target (the list can be empty)."
msgstr ""

#: reference/simple_stmts.rst:131
msgid ""
"Else: The object must be a sequence with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""

#: reference/simple_stmts.rst:135
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""

#: reference/simple_stmts.rst:137
msgid "If the target is an identifier (name):"
msgstr ""

#: reference/simple_stmts.rst:139
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""

#: reference/simple_stmts.rst:143
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""

#: reference/simple_stmts.rst:148
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""

#: reference/simple_stmts.rst:152
msgid ""
"If the target is a target list enclosed in parentheses or in square "
"brackets: The object must be an iterable with the same number of items as "
"there are targets in the target list, and its items are assigned, from left "
"to right, to the corresponding targets."
msgstr ""

#: reference/simple_stmts.rst:159
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""

#: reference/simple_stmts.rst:168
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the RHS expression, ``a.x`` can "
"access either an instance attribute or (if no instance attribute exists) a "
"class attribute.  The LHS target ``a.x`` is always set as an instance "
"attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` "
"do not necessarily refer to the same attribute: if the RHS expression refers "
"to a class attribute, the LHS creates a new instance attribute as the target "
"of the assignment::"
msgstr ""

#: reference/simple_stmts.rst:182
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""

#: reference/simple_stmts.rst:189
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""

#: reference/simple_stmts.rst:198
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""

#: reference/simple_stmts.rst:209
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""

#: reference/simple_stmts.rst:215
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""

#: reference/simple_stmts.rst:220
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the object allows it."
msgstr ""

#: reference/simple_stmts.rst:234
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""

#: reference/simple_stmts.rst:238
msgid ""
"WARNING: Although the definition of assignment implies that overlaps between "
"the left-hand side and the right-hand side are 'safe' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables are not safe!  For instance, the following program prints ``[0, "
"2]``::"
msgstr ""

#: reference/simple_stmts.rst:251
msgid "PEP 3132 - Extended Iterable Unpacking"
msgstr ""

#: reference/simple_stmts.rst:252
msgid "The specification for the ``*target`` feature."
msgstr ""

#: reference/simple_stmts.rst:258
msgid "Augmented assignment statements"
msgstr ""

#: reference/simple_stmts.rst:264
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""

#: reference/simple_stmts.rst:276
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""

#: reference/simple_stmts.rst:281
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""

#: reference/simple_stmts.rst:287
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""

#: reference/simple_stmts.rst:293
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""

#: reference/simple_stmts.rst:300
msgid "The :keyword:`assert` statement"
msgstr ""

#: reference/simple_stmts.rst:306
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""

#: reference/simple_stmts.rst:312
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr ""

#: reference/simple_stmts.rst:317
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""

#: reference/simple_stmts.rst:326
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option -O).  The current code generator emits no code for an assert "
"statement when optimization is requested at compile time.  Note that it is "
"unnecessary to include the source code for the expression that failed in the "
"error message; it will be displayed as part of the stack trace."
msgstr ""

#: reference/simple_stmts.rst:335
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""

#: reference/simple_stmts.rst:342
msgid "The :keyword:`pass` statement"
msgstr ""

#: reference/simple_stmts.rst:352
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""

#: reference/simple_stmts.rst:364
msgid "The :keyword:`del` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/simple_stmts.rst:374
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""

#: reference/simple_stmts.rst:377
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""

#: reference/simple_stmts.rst:383
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""

#: reference/simple_stmts.rst:390
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""

#: reference/simple_stmts.rst:395
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""

#: reference/simple_stmts.rst:403
msgid "The :keyword:`return` statement"
msgstr ""

#: reference/simple_stmts.rst:413
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""

#: reference/simple_stmts.rst:416
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""

#: reference/simple_stmts.rst:418
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""

#: reference/simple_stmts.rst:423
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the function."
msgstr ""

#: reference/simple_stmts.rst:427
msgid ""
"In a generator function, the :keyword:`return` statement is not allowed to "
"include an :token:`expression_list`.  In that context, a bare :keyword:"
"`return` indicates that the generator is done and will cause :exc:"
"`StopIteration` to be raised."
msgstr ""

#: reference/simple_stmts.rst:436
#, fuzzy
msgid "The :keyword:`yield` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/simple_stmts.rst:448
msgid ""
"The :keyword:`yield` statement is only used when defining a generator "
"function, and is only used in the body of the generator function. Using a :"
"keyword:`yield` statement in a function definition is sufficient to cause "
"that definition to create a generator function instead of a normal function. "
"When a generator function is called, it returns an iterator known as a "
"generator iterator, or more commonly, a generator.  The body of the "
"generator function is executed by calling the :func:`next` function on the "
"generator repeatedly until it raises an exception."
msgstr ""

#: reference/simple_stmts.rst:457
msgid ""
"When a :keyword:`yield` statement is executed, the state of the generator is "
"frozen and the value of :token:`expression_list` is returned to :meth:"
"`next`'s caller.  By \"frozen\" we mean that all local state is retained, "
"including the current bindings of local variables, the instruction pointer, "
"and the internal evaluation stack: enough information is saved so that the "
"next time :func:`next` is invoked, the function can proceed exactly as if "
"the :keyword:`yield` statement were just another external call."
msgstr ""

#: reference/simple_stmts.rst:477
msgid ""
"The proposal that, among other generator enhancements, proposed allowing :"
"keyword:`yield` to appear inside a :keyword:`try` ... :keyword:`finally` "
"block."
msgstr ""

#: reference/simple_stmts.rst:484
msgid "The :keyword:`raise` statement"
msgstr ""

#: reference/simple_stmts.rst:495
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception "
"that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`RuntimeError` exception is raised indicating that "
"this is an error."
msgstr ""

#: reference/simple_stmts.rst:500
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""

#: reference/simple_stmts.rst:505
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""

#: reference/simple_stmts.rst:510
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step "
"using the :meth:`with_traceback` exception method (which returns the same "
"exception instance, with its traceback set to its argument), like so::"
msgstr ""

#: reference/simple_stmts.rst:522
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance, which will then be "
"attached to the raised exception as the :attr:`__cause__` attribute (which "
"is writable).  If the raised exception is not handled, both exceptions will "
"be printed::"
msgstr ""

#: reference/simple_stmts.rst:543
msgid ""
"A similar mechanism works implicitly if an exception is raised inside an "
"exception handler: the previous exception is then attached as the new "
"exception's :attr:`__context__` attribute::"
msgstr ""

#: reference/simple_stmts.rst:562
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""

#: reference/simple_stmts.rst:569
msgid "The :keyword:`break` statement"
msgstr ""

#: reference/simple_stmts.rst:580
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""

#: reference/simple_stmts.rst:587
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:"
"`else` clause if the loop has one."
msgstr ""

#: reference/simple_stmts.rst:590
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""

#: reference/simple_stmts.rst:595
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the loop."
msgstr ""

#: reference/simple_stmts.rst:603
msgid "The :keyword:`continue` statement"
msgstr ""

#: reference/simple_stmts.rst:615
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"or :keyword:`finally` clause within that loop.  It continues with the next "
"cycle of the nearest enclosing loop."
msgstr ""

#: reference/simple_stmts.rst:620
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really starting the next loop cycle."
msgstr ""

#: reference/simple_stmts.rst:629
msgid "The :keyword:`import` statement"
msgstr ""

#: reference/simple_stmts.rst:648
msgid ""
"Import statements are executed in two steps: (1) find a module, and "
"initialize it if necessary; (2) define a name or names in the local "
"namespace (of the scope where the :keyword:`import` statement occurs). The "
"statement comes in two forms differing on whether it uses the :keyword:"
"`from` keyword. The first form (without :keyword:`from`) repeats these steps "
"for each identifier in the list. The form with :keyword:`from` performs step "
"(1) once, and then performs step (2) repeatedly. For a reference "
"implementation of step (1), see the :mod:`importlib` module."
msgstr ""

#: reference/simple_stmts.rst:660
msgid ""
"To understand how step (1) occurs, one must first understand how Python "
"handles hierarchical naming of modules. To help organize modules and provide "
"a hierarchy in naming, Python has a concept of packages. A package can "
"contain other packages and modules while modules cannot contain other "
"modules or packages. From a file system perspective, packages are "
"directories and modules are files. The original `specification for packages "
"<http://www.python.org/doc/essays/packages.html>`_ is still available to "
"read, although minor details have changed since the writing of that document."
msgstr ""

#: reference/simple_stmts.rst:672
msgid ""
"Once the name of the module is known (unless otherwise specified, the term "
"\"module\" will refer to both packages and modules), searching for the "
"module or package can begin. The first place checked is :data:`sys.modules`, "
"the cache of all modules that have been imported previously. If the module "
"is found there then it is used in step (2) of import unless ``None`` is "
"found in :data:`sys.modules`, in which case :exc:`ImportError` is raised."
msgstr ""

#: reference/simple_stmts.rst:686
msgid ""
"If the module is not found in the cache, then :data:`sys.meta_path` is "
"searched (the specification for :data:`sys.meta_path` can be found in :pep:"
"`302`). The object is a list of :term:`finder` objects which are queried in "
"order as to whether they know how to load the module by calling their :meth:"
"`find_module` method with the name of the module. If the module happens to "
"be contained within a package (as denoted by the existence of a dot in the "
"name), then a second argument to :meth:`find_module` is given as the value "
"of the :attr:`__path__` attribute from the parent package (everything up to "
"the last dot in the name of the module being imported). If a finder can find "
"the module it returns a :term:`loader` (discussed later) or returns ``None``."
msgstr ""

#: reference/simple_stmts.rst:702
msgid ""
"If none of the finders on :data:`sys.meta_path` are able to find the module "
"then some implicitly defined finders are queried. Implementations of Python "
"vary in what implicit meta path finders are defined. The one they all do "
"define, though, is one that handles :data:`sys.path_hooks`, :data:`sys."
"path_importer_cache`, and :data:`sys.path`."
msgstr ""

#: reference/simple_stmts.rst:708
msgid ""
"The implicit finder searches for the requested module in the \"paths\" "
"specified in one of two places (\"paths\" do not have to be file system "
"paths). If the module being imported is supposed to be contained within a "
"package then the second argument passed to :meth:`find_module`, :attr:"
"`__path__` on the parent package, is used as the source of paths. If the "
"module is not contained in a package then :data:`sys.path` is used as the "
"source of paths."
msgstr ""

#: reference/simple_stmts.rst:715
msgid ""
"Once the source of paths is chosen it is iterated over to find a finder that "
"can handle that path. The dict at :data:`sys.path_importer_cache` caches "
"finders for paths and is checked for a finder. If the path does not have a "
"finder cached then :data:`sys.path_hooks` is searched by calling each object "
"in the list with a single argument of the path, returning a finder or "
"raises :exc:`ImportError`. If a finder is returned then it is cached in :"
"data:`sys.path_importer_cache` and then used for that path entry. If no "
"finder can be found but the path exists then a value of ``None`` is stored "
"in :data:`sys.path_importer_cache` to signify that an implicit, file-based "
"finder that handles modules stored as individual files should be used for "
"that path. If the path does not exist then a finder which always returns "
"``None`` is placed in the cache for the path."
msgstr ""

#: reference/simple_stmts.rst:733
msgid ""
"If no finder can find the module then :exc:`ImportError` is raised. "
"Otherwise some finder returned a loader whose :meth:`load_module` method is "
"called with the name of the module to load (see :pep:`302` for the original "
"definition of loaders). A loader has several responsibilities to perform on "
"a module it loads. First, if the module already exists in :data:`sys."
"modules` (a possibility if the loader is called outside of the import "
"machinery) then it is to use that module for initialization and not a new "
"module. But if the module does not exist in :data:`sys.modules` then it is "
"to be added to that dict before initialization begins. If an error occurs "
"during loading of the module and it was added to :data:`sys.modules` it is "
"to be removed from the dict. If an error occurs but the module was already "
"in :data:`sys.modules` it is left in the dict."
msgstr ""

#: reference/simple_stmts.rst:753
msgid ""
"The loader must set several attributes on the module. :data:`__name__` is to "
"be set to the name of the module. :data:`__file__` is to be the \"path\" to "
"the file unless the module is built-in (and thus listed in :data:`sys."
"builtin_module_names`) in which case the attribute is not set. If what is "
"being imported is a package then :data:`__path__` is to be set to a list of "
"paths to be searched when looking for modules and packages contained within "
"the package being imported. :data:`__package__` is optional but should be "
"set to the name of package that contains the module or package (the empty "
"string is used for module not contained in a package). :data:`__loader__` is "
"also optional but should be set to the loader object that is loading the "
"module."
msgstr ""

#: reference/simple_stmts.rst:768
msgid ""
"If an error occurs during loading then the loader raises :exc:`ImportError` "
"if some other exception is not already being propagated. Otherwise the "
"loader returns the module that was loaded and initialized."
msgstr ""

#: reference/simple_stmts.rst:772
msgid ""
"When step (1) finishes without raising an exception, step (2) can begin."
msgstr ""

#: reference/simple_stmts.rst:774
msgid ""
"The first form of :keyword:`import` statement binds the module name in the "
"local namespace to the module object, and then goes on to import the next "
"identifier, if any.  If the module name is followed by :keyword:`as`, the "
"name following :keyword:`as` is used as the local name for the module."
msgstr ""

#: reference/simple_stmts.rst:783
msgid ""
"The :keyword:`from` form does not bind the module name: it goes through the "
"list of identifiers, looks each one of them up in the module found in step "
"(1), and binds the name in the local namespace to the object thus found.  As "
"with the first form of :keyword:`import`, an alternate local name can be "
"supplied by specifying \":keyword:`as` localname\".  If a name is not "
"found, :exc:`ImportError` is raised.  If the list of identifiers is replaced "
"by a star (``'*'``), all public names defined in the module are bound in the "
"local namespace of the :keyword:`import` statement."
msgstr ""

#: reference/simple_stmts.rst:794
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``). ``__all__`` should contain the entire public API. It is "
"intended to avoid accidentally exporting items that are not part of the API "
"(such as library modules which were imported and used within the module)."
msgstr ""

#: reference/simple_stmts.rst:804
msgid ""
"The :keyword:`from` form with ``*`` may only occur in a module scope.  The "
"wild card form of import --- ``import *`` --- is only allowed at the module "
"level. Attempting to use it in class or function definitions will raise a :"
"exc:`SyntaxError`."
msgstr ""

#: reference/simple_stmts.rst:812
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained "
"within :pep:`328`."
msgstr ""

#: reference/simple_stmts.rst:825
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine which modules need to be loaded dynamically."
msgstr ""

#: reference/simple_stmts.rst:832
msgid "Future statements"
msgstr ""

#: reference/simple_stmts.rst:836
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python.  The future statement is intended "
"to ease migration to future versions of Python that introduce incompatible "
"changes to the language.  It allows use of the new features on a per-module "
"basis before the release in which the feature becomes standard."
msgstr ""

#: reference/simple_stmts.rst:851
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""

#: reference/simple_stmts.rst:854
msgid "the module docstring (if any),"
msgstr ""

#: reference/simple_stmts.rst:855
msgid "comments,"
msgstr ""

#: reference/simple_stmts.rst:856
msgid "blank lines, and"
msgstr ""

#: reference/simple_stmts.rst:857
msgid "other future statements."
msgstr ""

#: reference/simple_stmts.rst:861
msgid ""
"The features recognized by Python 3.0 are ``absolute_import``, ``division``, "
"``generators``, ``unicode_literals``, ``print_function``, ``nested_scopes`` "
"and ``with_statement``.  They are all redundant because they are always "
"enabled, and only kept for backwards compatibility."
msgstr ""

#: reference/simple_stmts.rst:866
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""

#: reference/simple_stmts.rst:873
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""

#: reference/simple_stmts.rst:877
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""

#: reference/simple_stmts.rst:881
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""

#: reference/simple_stmts.rst:884
msgid "Note that there is nothing special about the statement::"
msgstr ""

#: reference/simple_stmts.rst:888
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""

#: reference/simple_stmts.rst:891
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""

#: reference/simple_stmts.rst:897
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""

#: reference/simple_stmts.rst:905
msgid "PEP 236 - Back to the __future__"
msgstr "PEP 236 - Retour vers le __future__"

#: reference/simple_stmts.rst:906
msgid "The original proposal for the __future__ mechanism."
msgstr ""

#: reference/simple_stmts.rst:912
msgid "The :keyword:`global` statement"
msgstr ""

#: reference/simple_stmts.rst:921
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`global`, although free variables may refer to "
"globals without being declared global."
msgstr ""

#: reference/simple_stmts.rst:927
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`global` statement."
msgstr ""

#: reference/simple_stmts.rst:930
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, or :keyword:`import` statement."
msgstr ""

#: reference/simple_stmts.rst:936
msgid ""
"The current implementation does not enforce the latter two restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""

#: reference/simple_stmts.rst:945
msgid ""
"**Programmer's note:** the :keyword:`global` is a directive to the parser.  "
"It applies only to code parsed at the same time as the :keyword:`global` "
"statement. In particular, a :keyword:`global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""

#: reference/simple_stmts.rst:957
msgid "The :keyword:`nonlocal` statement"
msgstr ""

#: reference/simple_stmts.rst:968
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope.  This is "
"important because the default behavior for binding is to search the local "
"namespace first.  The statement allows encapsulated code to rebind variables "
"outside of the local scope besides the global (module) scope."
msgstr ""

#: reference/simple_stmts.rst:978
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike to those listed in "
"a :keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""

#: reference/simple_stmts.rst:983
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ""

#: reference/simple_stmts.rst:988
msgid "PEP 3104 - Access to Names in Outer Scopes"
msgstr ""

#: reference/simple_stmts.rst:989
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ""

#: reference/toplevel_components.rst:6
msgid "Top-level components"
msgstr ""

#: reference/toplevel_components.rst:10
msgid ""
"The Python interpreter can get its input from a number of sources: from a "
"script passed to it as standard input or as program argument, typed in "
"interactively, from a module source file, etc.  This chapter gives the "
"syntax used in these cases."
msgstr ""

#: reference/toplevel_components.rst:19
msgid "Complete Python programs"
msgstr ""

#: reference/toplevel_components.rst:28
msgid ""
"While a language specification need not prescribe how the language "
"interpreter is invoked, it is useful to have a notion of a complete Python "
"program.  A complete Python program is executed in a minimally initialized "
"environment: all built-in and standard modules are available, but none have "
"been initialized, except for :mod:`sys` (various system services), :mod:"
"`builtins` (built-in functions, exceptions and ``None``) and :mod:"
"`__main__`.  The latter is used to provide the local and global namespace "
"for execution of the complete program."
msgstr ""

#: reference/toplevel_components.rst:36
msgid ""
"The syntax for a complete Python program is that for file input, described "
"in the next section."
msgstr ""

#: reference/toplevel_components.rst:43
msgid ""
"The interpreter may also be invoked in interactive mode; in this case, it "
"does not read and execute a complete program but reads and executes one "
"statement (possibly compound) at a time.  The initial environment is "
"identical to that of a complete program; each statement is executed in the "
"namespace of :mod:`__main__`."
msgstr ""

#: reference/toplevel_components.rst:54
msgid ""
"Under Unix, a complete program can be passed to the interpreter in three "
"forms: with the :option:`-c` *string* command line option, as a file passed "
"as the first command line argument, or as standard input.  If the file or "
"standard input is a tty device, the interpreter enters interactive mode; "
"otherwise, it executes the file as a complete program."
msgstr ""

#: reference/toplevel_components.rst:64
msgid "File input"
msgstr ""

#: reference/toplevel_components.rst:66
msgid "All input read from non-interactive files has the same form:"
msgstr ""

#: reference/toplevel_components.rst:71
msgid "This syntax is used in the following situations:"
msgstr ""

#: reference/toplevel_components.rst:73
msgid "when parsing a complete Python program (from a file or from a string);"
msgstr ""

#: reference/toplevel_components.rst:75
msgid "when parsing a module;"
msgstr ""

#: reference/toplevel_components.rst:77
msgid "when parsing a string passed to the :func:`exec` function;"
msgstr ""

#: reference/toplevel_components.rst:83
msgid "Interactive input"
msgstr ""

#: reference/toplevel_components.rst:85
msgid "Input in interactive mode is parsed using the following grammar:"
msgstr ""

#: reference/toplevel_components.rst:90
msgid ""
"Note that a (top-level) compound statement must be followed by a blank line "
"in interactive mode; this is needed to help the parser detect the end of the "
"input."
msgstr ""

#: reference/toplevel_components.rst:97
msgid "Expression input"
msgstr ""

#: reference/toplevel_components.rst:103
msgid ""
"There are two forms of expression input.  Both ignore leading whitespace. "
"The string argument to :func:`eval` must have the following form:"
msgstr ""

#: reference/toplevel_components.rst:114
msgid ""
"Note: to read 'raw' input line without interpretation, you can use the :meth:"
"`readline` method of file objects, including ``sys.stdin``."
msgstr ""
