# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2010, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2010-06-30 14:00\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.7.0\n"

msgid "API Reference"
msgstr "Référence de l'API"

msgid ":mod:`distutils.core` --- Core Distutils functionality"
msgstr ""

msgid "The :mod:`distutils.core` module is the only module that needs to be installed to use the Distutils. It provides the :func:`setup` (which is called from the setup script). Indirectly provides the  :class:`distutils.dist.Distribution` and :class:`distutils.cmd.Command` class."
msgstr ""
"Le module :mod:`distutils.core` est le seul module qui a besoin d'être "
"installé pour utiliser Distutils. Il fournit le :func:`setup` (qui est "
"appelé par le script de setup). Il fournit indirectement les classes "
":class:`distutils.dist.Distribution` et :class:`distutils.cmd.Command`."

msgid "The basic do-everything function that does most everything you could ever ask for from a Distutils method. See XXXXX"
msgstr ""
"La fonction de base à tout faire qui fait presque tout ce dont vous pourriez "
"attendre d'une méthode Distutils. Voir XXXXX"

msgid "The setup function takes a large number of arguments. These are laid out in the following table."
msgstr ""
"La fonction setup prend un grand nombre d'arguments. Ils sont présentés dans "
"le tableau suivant."

msgid "argument name"
msgstr "nom de l'argument"

msgid "value"
msgstr "valeur"

msgid "type"
msgstr "type"

msgid "*name*"
msgstr "*name*"

# aconrad: package ? paquet ?
msgid "The name of the package"
msgstr "Le nom du paquet"

msgid "a string"
msgstr "une chaîne de caractères"

msgid "*version*"
msgstr "*version*"

msgid "The version number of the package"
msgstr "Le numéro de version du paquet"

msgid "See :mod:`distutils.version`"
msgstr "Voir :mod:`distutils.version`"

msgid "*description*"
msgstr "*description*"

msgid "A single line describing the package"
msgstr "Une ligne unique décrivant le paquet"

msgid "*long_description*"
msgstr "*long_description*"

msgid "Longer description of the package"
msgstr "Une description plus longue du paquet"

msgid "*author*"
msgstr "*author*"

msgid "The name of the package author"
msgstr "Le nom de l'auteur du paquet"

msgid "*author_email*"
msgstr "*author_email*"

msgid "The email address of the package author"
msgstr "L'adresse e-mail de l'auteur du paquet"

msgid "*maintainer*"
msgstr "*maintainer*"

msgid "The name of the current maintainer, if different from the author"
msgstr "Le nom du mainteneur actuel, si différent de l'auteur"

msgid "*maintainer_email*"
msgstr "*maintainer_email*"

msgid "The email address of the current maintainer, if different from the author"
msgstr "L'adresse email de l'actuel mainteneur, si différent de l'auteur"

msgid "*url*"
msgstr "*url*"

msgid "A URL for the package (homepage)"
msgstr "Une URL pour le paquet (page d'accueil)"

msgid "a URL"
msgstr "une URL"

msgid "*download_url*"
msgstr "*download_url*"

msgid "A URL to download the package"
msgstr "Une URL pour télécharger le paquet"

msgid "*packages*"
msgstr "*packages*"

msgid "A list of Python packages that distutils will manipulate"
msgstr "Une liste des paquets Python que distutils va manipuler"

msgid "a list of strings"
msgstr "une liste de chaînes"

msgid "*py_modules*"
msgstr "*py_modules*"

msgid "A list of Python modules that distutils will manipulate"
msgstr "Une liste de modules Python que distutils va manipuler"

msgid "*scripts*"
msgstr "*scripts*"

msgid "A list of standalone script files to be built and installed"
msgstr "Une liste de scripts autonomes à construire et à installer"

msgid "*ext_modules*"
msgstr "*ext_modules*"

msgid "A list of Python extensions to be built"
msgstr "Une liste des extensions Python à construire"

msgid "A list of  instances of :class:`distutils.core.Extension`"
msgstr "Une liste d'instances de :class:`distutils.core.Extension'"

msgid "*classifiers*"
msgstr "*classifiers*"

msgid "A list of categories for the package"
msgstr "Une liste de catégories pour le paquet"

msgid "The list of available categorizations is at http://pypi.python.org/pypi?:action=list_classifiers."
msgstr ""
"La liste des catégorisations est disponibles sur "
"http://pypi.python.org/pypi?:action=list_classifiers."

msgid "*distclass*"
msgstr "*distclass*"

msgid "the :class:`Distribution` class to use"
msgstr "la classe :class:`Distribution` à utiliser"

msgid "A subclass of :class:`distutils.core.Distribution`"
msgstr "Une sous classe de :class:`distutils.core.Distribution`"

msgid "*script_name*"
msgstr "*script_name*"

msgid "The name of the setup.py script - defaults to ``sys.argv[0]``"
msgstr ""

msgid "*script_args*"
msgstr "*script_args*"

msgid "Arguments to supply to the setup script"
msgstr "Arguments à fournir au script d'installation"

msgid "*options*"
msgstr "*options*"

msgid "default options for the setup script"
msgstr "options par défaut pour le script d'installation"

msgid "*license*"
msgstr "*license*"

msgid "The license for the package"
msgstr "La licence pour le paquet"

msgid "*keywords*"
msgstr "*keywords*"

msgid "Descriptive meta-data, see :pep:`314`"
msgstr "Méta-données descriptives, voir :pep:`314`"

msgid "*platforms*"
msgstr "*platforms*"

msgid "*cmdclass*"
msgstr "*cmdclass*"

msgid "A mapping of command names to :class:`Command` subclasses"
msgstr "Un mapping des noms de commandes et des sous-classes :class:`Command`"

msgid "a dictionary"
msgstr "un dictionnaire"

msgid "*data_files*"
msgstr "*data_files*"

msgid "A list of data files to install"
msgstr "Une liste de fichiers de données à installer"

msgid "a list"
msgstr "une liste"

msgid "*package_dir*"
msgstr "*package_dir*"

msgid "A mapping of package to directory names"
msgstr "Un mapping des paquets et des noms de dossiers"

msgid "Run a setup script in a somewhat controlled environment, and return  the :class:`distutils.dist.Distribution` instance that drives things.   This is useful if you need to find out the distribution meta-data  (passed as keyword args from *script* to :func:`setup`), or  the contents of the config files or command-line."
msgstr ""

msgid "*script_name* is a file that will be read and run with :func:`exec`.  ``sys.argv[0]`` will be replaced with *script* for the duration of the call.  *script_args* is a list of strings; if supplied, ``sys.argv[1:]`` will be replaced by *script_args* for the duration  of the call."
msgstr ""
"*script_name* est un fichier qui sera lu et exécuté avec :func:`exec`. "
"``sys.argv[0]`` sera remplacé par *script* par la durée de l'appel. "
"*script_args* est une liste de chaînes; si fourni, ``sys.argv[1:]`` sera "
"remplacé par *script_args* pour la durée de l'appel."

msgid "*stop_after* tells :func:`setup` when to stop processing; possible  values:"
msgstr "*stop_after* dit à :func:`setup` quand s'arrêter; valeurs possibles:"

msgid "description"
msgstr "description"

msgid "*init*"
msgstr "*init*"

msgid "Stop after the :class:`Distribution` instance has been created  and populated with the keyword arguments to :func:`setup`"
msgstr ""
"S'arrête une fois que l'instance :class:`Distribution` a été créée et "
"renseignée avec les arguments-clés de :func:`setup`"

msgid "*config*"
msgstr "*config*"

msgid "Stop after config files have been parsed (and their data stored in the :class:`Distribution` instance)"
msgstr ""
"S'arrête une fois que les fichiers de configuration ont été parcouru (et que "
"leurs données ont été stockées dans l'instance :class:`Distribution`)"

msgid "*commandline*"
msgstr "*commandline*"

msgid "Stop after the command-line (``sys.argv[1:]`` or  *script_args*) have been parsed (and the data stored in the :class:`Distribution` instance.)"
msgstr ""
"S'arrête une fois que la ligne de commande (``sys.argv[1:]`` ou "
"*script_args*) a été parcouru (et les données stockées dans l'instance "
":class:`Distribution`)"

msgid "*run*"
msgstr "*run*"

msgid "Stop after all commands have been run (the same as  if :func:`setup` had been called in the usual way). This is the default value."
msgstr ""
"S'arrête une fois que toutes les commandes ont été exécutées (comme si "
":func:`setup` fût appelé de la manière habituelle). Ceci est la valeur par "
"défaut."

msgid "In addition, the :mod:`distutils.core` module exposed a number of  classes that live elsewhere."
msgstr ""
"De plus, le module :mod:`distutils.core` a exposé un nombre de classe qui "
"existent ailleurs."

msgid ":class:`Extension` from :mod:`distutils.extension`"
msgstr ":class:`Extension` de :mod:`distutils.extension`"

msgid ":class:`Command` from :mod:`distutils.cmd`"
msgstr ":class:`Command` de :mod:`distutils.cmd`"

msgid ":class:`Distribution` from :mod:`distutils.dist`"
msgstr ":class:`Distribution` de :mod:`distutils.dist`"

msgid "A short description of each of these follows, but see the relevant module for the full reference."
msgstr ""
"Une courte description de chacune d'elle suit, mais consultez le module "
"concerné pour une référence complète."

msgid "The Extension class describes a single C or C++extension module in a setup script. It accepts the following keyword arguments in its constructor"
msgstr ""
"La class Extension décrit un seul module d'extension C ou C++ dans un script "
"d'installation. Elle accepte dans son constructeur les arguments-clés "
"suivants"

msgid "the full name of the extension, including any packages --- ie. *not* a filename or pathname, but Python dotted name"
msgstr ""
"le nom complet de l'extension, incluant n'importe quel paquet --- c-à-d "
"*pas* un nom de fichier ou de chemin mais un nom Python séparé par des "
"points"

msgid "string"
msgstr ""

msgid "*sources*"
msgstr "*sources*"

msgid "list of source filenames, relative to the distribution root (where the setup script lives), in Unix form (slash- separated) for portability. Source files may be C, C++, SWIG (.i), platform-specific resource files, or whatever else is recognized by the :command:`build_ext` command as source for a Python extension."
msgstr ""
"listes des noms de fichier des sources, relatifs à la racine de la "
"distribution (où est placé le script setup), dans un format Unix (séparé par "
"des slashs) dans un souci de portabilité. Les fichiers de code source "
"peuvent être du C, C++, SWIG (.i), des fichiers de ressources spécifiques à "
"la plateforme ou tout autre reconnu par la commande :command:`build_ext` "
"comme source d'une extension Python"

msgid "*include_dirs*"
msgstr ""

msgid "list of directories to search for C/C++ header files (in Unix form for portability)"
msgstr ""
"liste des répertoires où chercher les fichiers d'entêtes C/C++ (en format "
"Unix dans un souci de portabilité)"

msgid "*define_macros*"
msgstr "*define_macros*"

msgid "list of macros to define; each macro is defined using a 2-tuple ``(name, value)``, where *value* is either the string to define it to or ``None`` to define it without a particular value (equivalent of ``#define FOO`` in source or :option:`-DFOO` on Unix C compiler command line)"
msgstr ""

msgid "(string, string) tuple or (name, ``None``)"
msgstr ""

msgid "*undef_macros*"
msgstr "*undef_macros*"

msgid "list of macros to undefine explicitly"
msgstr ""

msgid "*library_dirs*"
msgstr ""

msgid "list of directories to search for C/C++ libraries at link time"
msgstr ""

msgid "*libraries*"
msgstr ""

msgid "list of library names (not filenames or paths) to link against"
msgstr ""

msgid "*runtime_library_dirs*"
msgstr ""

msgid "list of directories to search for C/C++ libraries at run time (for shared extensions, this is when the extension is loaded)"
msgstr ""

msgid "*extra_objects*"
msgstr ""

msgid "list of extra files to link with (eg. object files not implied by 'sources', static library that must be explicitly specified, binary resource files, etc.)"
msgstr ""

msgid "*extra_compile_args*"
msgstr ""

msgid "any extra platform- and compiler-specific information to use when compiling the source files in 'sources'. For platforms and compilers where a command line makes sense, this is typically a list of command-line arguments, but for other platforms it could be anything."
msgstr ""

msgid "*extra_link_args*"
msgstr ""

msgid "any extra platform- and compiler-specific information to use when linking object files together to create the extension (or to create a new static Python interpreter). Similar interpretation as for 'extra_compile_args'."
msgstr ""

msgid "*export_symbols*"
msgstr ""

msgid "list of symbols to be exported from a shared extension. Not used on all platforms, and not generally necessary for Python extensions, which typically export exactly one symbol: ``init`` + extension_name."
msgstr ""

msgid "*depends*"
msgstr ""

msgid "list of files that the extension depends on"
msgstr "liste des fichiers dont dépend l'extension"

msgid "*language*"
msgstr ""

msgid "extension language (i.e. ``'c'``, ``'c++'``, ``'objc'``). Will be detected from the source extensions if not provided."
msgstr ""
"langage de l'extension (par exemple ``'c'``, ``'c++'``, ``'objc'``). Il sera "
"détecté selon l'extension de la source s'il n'est pas précisé."

msgid "A :class:`Distribution` describes how to build, install and package up a Python software package."
msgstr ""

msgid "See the :func:`setup` function for a list of keyword arguments accepted  by the Distribution constructor. :func:`setup` creates a Distribution instance."
msgstr ""

msgid "A :class:`Command` class (or rather, an instance of one of its subclasses) implement a single distutils command."
msgstr ""

msgid ":mod:`distutils.ccompiler` --- CCompiler base class"
msgstr ""

msgid "This module provides the abstract base class for the :class:`CCompiler` classes.  A :class:`CCompiler` instance can be used for all the compile  and link steps needed to build a single project. Methods are provided to  set options for the compiler --- macro definitions, include directories,  link path, libraries and the like."
msgstr ""

msgid "This module provides the following functions."
msgstr "Ce module fournit les fonctions suivantes."

msgid "Generate linker options for searching library directories and linking with specific libraries.  *libraries* and *library_dirs* are, respectively, lists of library names (not filenames!) and search directories.  Returns a list of command-line options suitable for use with some compiler (depending on the two format strings passed in)."
msgstr ""

msgid "Generate C pre-processor options (:option:`-D`, :option:`-U`, :option:`-I`) as used by at least two types of compilers: the typical Unix compiler and Visual C++. *macros* is the usual thing, a list of 1- or 2-tuples, where ``(name,)`` means undefine (:option:`-U`) macro *name*, and ``(name, value)`` means define (:option:`-D`) macro *name* to *value*.  *include_dirs* is just a list of directory names to be added to the header file search path (:option:`-I`). Returns a list of command-line options suitable for either Unix compilers or Visual C++."
msgstr ""

msgid "Determine the default compiler to use for the given platform."
msgstr ""
"Détermine le compilateur par défaut a utiliser par une plateforme donnée"

msgid "*osname* should be one of the standard Python OS names (i.e. the ones returned by ``os.name``) and *platform* the common value returned by ``sys.platform`` for the platform in question."
msgstr ""

msgid "The default values are ``os.name`` and ``sys.platform`` in case the parameters are not given."
msgstr ""
"Les valeurs par défaut sont ``os.name`` et ``sys.platform`` si les "
"paramètres ne sont pas fournis."

msgid "Factory function to generate an instance of some CCompiler subclass for the supplied platform/compiler combination. *plat* defaults to ``os.name`` (eg. ``'posix'``, ``'nt'``), and *compiler*  defaults to the default compiler for that platform. Currently only ``'posix'`` and ``'nt'`` are supported, and the default compilers are \"traditional Unix interface\" (:class:`UnixCCompiler` class) and Visual C++ (:class:`MSVCCompiler` class).  Note that it's perfectly possible to ask for a Unix compiler object under Windows, and a Microsoft compiler object under Unix---if you supply a value for *compiler*, *plat* is ignored."
msgstr ""

msgid "Print list of available compilers (used by the :option:`--help-compiler` options to :command:`build`, :command:`build_ext`, :command:`build_clib`)."
msgstr ""

msgid "The abstract base class :class:`CCompiler` defines the interface that  must be implemented by real compiler classes.  The class also has  some utility methods used by several compiler classes."
msgstr ""

msgid "The basic idea behind a compiler abstraction class is that each instance can be used for all the compile/link steps in building a single project.  Thus, attributes common to all of those compile and link steps --- include directories, macros to define, libraries to link against, etc. --- are attributes of the compiler instance.  To allow for variability in how individual files are treated, most of those attributes may be varied on a per-compilation or per-link basis."
msgstr ""

msgid "The constructor for each subclass creates an instance of the Compiler object. Flags are *verbose* (show verbose output), *dry_run* (don't actually execute the steps) and *force* (rebuild everything, regardless of dependencies). All of these flags default to ``0`` (off). Note that you probably don't want to instantiate :class:`CCompiler` or one of its subclasses directly - use the :func:`distutils.CCompiler.new_compiler` factory function instead."
msgstr ""

msgid "The following methods allow you to manually alter compiler options for  the instance of the Compiler class."
msgstr ""

msgid "Add *dir* to the list of directories that will be searched for header files. The compiler is instructed to search directories in the order in which they are supplied by successive calls to :meth:`add_include_dir`."
msgstr ""

msgid "Set the list of directories that will be searched to *dirs* (a list of strings). Overrides any preceding calls to :meth:`add_include_dir`; subsequent calls to :meth:`add_include_dir` add to the list passed to :meth:`set_include_dirs`. This does not affect any list of standard include directories that the compiler may search by default."
msgstr ""

msgid "Add *libname* to the list of libraries that will be included in all links driven by this compiler object.  Note that *libname* should \\*not\\* be the name of a file containing a library, but the name of the library itself: the actual filename will be inferred by the linker, the compiler, or the compiler class (depending on the platform)."
msgstr ""

msgid "The linker will be instructed to link against libraries in the order they were supplied to :meth:`add_library` and/or :meth:`set_libraries`.  It is perfectly valid to duplicate library names; the linker will be instructed to link against libraries as many times as they are mentioned."
msgstr ""

msgid "Set the list of libraries to be included in all links driven by this compiler object to *libnames* (a list of strings).  This does not affect any standard system libraries that the linker may include by default."
msgstr ""

msgid "Add *dir* to the list of directories that will be searched for libraries specified to :meth:`add_library` and :meth:`set_libraries`.  The linker will be instructed to search for libraries in the order they are supplied to :meth:`add_library_dir` and/or :meth:`set_library_dirs`."
msgstr ""

msgid "Set the list of library search directories to *dirs* (a list of strings).  This does not affect any standard library search path that the linker may search by default."
msgstr ""

msgid "Add *dir* to the list of directories that will be searched for shared libraries at runtime."
msgstr ""

msgid "Set the list of directories to search for shared libraries at runtime to *dirs* (a list of strings).  This does not affect any standard search path that the runtime linker may search by default."
msgstr ""

msgid "Define a preprocessor macro for all compilations driven by this compiler object. The optional parameter *value* should be a string; if it is not supplied, then the macro will be defined without an explicit value and the exact outcome depends on the compiler used (XXX true? does ANSI say anything about this?)"
msgstr ""

msgid "Undefine a preprocessor macro for all compilations driven by this compiler object.  If the same macro is defined by :meth:`define_macro` and undefined by :meth:`undefine_macro` the last call takes precedence (including multiple redefinitions or undefinitions).  If the macro is redefined/undefined on a per-compilation basis (ie. in the call to :meth:`compile`), then that takes precedence."
msgstr ""

msgid "Add *object* to the list of object files (or analogues, such as explicitly named library files or the output of \"resource compilers\") to be included in every link driven by this compiler object."
msgstr ""

msgid "Set the list of object files (or analogues) to be included in every link to *objects*.  This does not affect any standard object files that the linker may include by default (such as system libraries)."
msgstr ""

msgid "The following methods implement methods for autodetection of compiler  options, providing some functionality similar to GNU :program:`autoconf`."
msgstr ""

msgid "Detect the language of a given file, or list of files. Uses the  instance attributes :attr:`language_map` (a dictionary), and  :attr:`language_order` (a list) to do the job."
msgstr ""

msgid "Search the specified list of directories for a static or shared library file *lib* and return the full path to that file.  If *debug* is true, look for a debugging version (if that makes sense on the current platform).  Return ``None`` if *lib* wasn't found in any of the specified directories."
msgstr ""

msgid "Return a boolean indicating whether *funcname* is supported on the current platform.  The optional arguments can be used to augment the compilation environment by providing additional include files and paths and libraries and paths."
msgstr ""

msgid "Return the compiler option to add *dir* to the list of directories searched for libraries."
msgstr ""

msgid "Return the compiler option to add *dir* to the list of libraries linked into the shared library or executable."
msgstr ""

msgid "Return the compiler option to add *dir* to the list of directories searched for runtime libraries."
msgstr ""

msgid "Define the executables (and options for them) that will be run to perform the various stages of compilation.  The exact set of executables that may be specified here depends on the compiler class (via the 'executables' class attribute), but most will have:"
msgstr ""

msgid "attribute"
msgstr ""

msgid "*compiler*"
msgstr ""

msgid "the C/C++ compiler"
msgstr ""

msgid "*linker_so*"
msgstr ""

msgid "linker used to create shared objects and libraries"
msgstr ""

msgid "*linker_exe*"
msgstr ""

msgid "linker used to create binary executables"
msgstr ""

msgid "*archiver*"
msgstr ""

msgid "static library creator"
msgstr ""

msgid "On platforms with a command-line (Unix, DOS/Windows), each of these is a string that will be split into executable name and (optional) list of arguments. (Splitting the string is done similarly to how Unix shells operate: words are delimited by spaces, but quotes and backslashes can override this.  See :func:`distutils.util.split_quoted`.)"
msgstr ""

msgid "The following methods invoke stages in the build process."
msgstr ""

msgid "Compile one or more source files. Generates object files (e.g.  transforms a :file:`.c` file to a :file:`.o` file.)"
msgstr ""

msgid "*sources* must be a list of filenames, most likely C/C++ files, but in reality anything that can be handled by a particular compiler and compiler class (eg. :class:`MSVCCompiler` can handle resource files in *sources*).  Return a list of object filenames, one per source filename in *sources*.  Depending on the implementation, not all source files will necessarily be compiled, but all corresponding object filenames will be returned."
msgstr ""

msgid "If *output_dir* is given, object files will be put under it, while retaining their original path component.  That is, :file:`foo/bar.c` normally compiles to :file:`foo/bar.o` (for a Unix implementation); if *output_dir* is *build*, then it would compile to :file:`build/foo/bar.o`."
msgstr ""

msgid "*macros*, if given, must be a list of macro definitions.  A macro definition is either a ``(name, value)`` 2-tuple or a ``(name,)`` 1-tuple. The former defines a macro; if the value is ``None``, the macro is defined without an explicit value.  The 1-tuple case undefines a macro.  Later definitions/redefinitions/undefinitions take precedence."
msgstr ""

msgid "*include_dirs*, if given, must be a list of strings, the directories to add to the default include file search path for this compilation only."
msgstr ""

msgid "*debug* is a boolean; if true, the compiler will be instructed to output debug symbols in (or alongside) the object file(s)."
msgstr ""

msgid "*extra_preargs* and *extra_postargs* are implementation-dependent. On platforms that have the notion of a command-line (e.g. Unix, DOS/Windows), they are most likely lists of strings: extra command-line arguments to prepend/append to the compiler command line.  On other platforms, consult the implementation class documentation.  In any event, they are intended as an escape hatch for those occasions when the abstract compiler framework doesn't cut the mustard."
msgstr ""

msgid "*depends*, if given, is a list of filenames that all targets depend on.  If a source file is older than any file in depends, then the source file will be recompiled.  This supports dependency tracking, but only at a coarse granularity."
msgstr ""

msgid "Raises :exc:`CompileError` on failure."
msgstr ""

msgid "Link a bunch of stuff together to create a static library file. The \"bunch of stuff\" consists of the list of object files supplied as *objects*, the extra object files supplied to :meth:`add_link_object` and/or :meth:`set_link_objects`, the libraries supplied to :meth:`add_library` and/or :meth:`set_libraries`, and the libraries supplied as *libraries* (if any)."
msgstr ""

msgid "*output_libname* should be a library name, not a filename; the filename will be inferred from the library name.  *output_dir* is the directory where the library file will be put. XXX defaults to what?"
msgstr ""

msgid "*debug* is a boolean; if true, debugging information will be included in the library (note that on most platforms, it is the compile step where this matters: the *debug* flag is included here just for consistency)."
msgstr ""

msgid "*target_lang* is the target language for which the given objects are being compiled. This allows specific linkage time treatment of certain languages."
msgstr ""

msgid "Raises :exc:`LibError` on failure."
msgstr ""

msgid "Link a bunch of stuff together to create an executable or shared library file."
msgstr ""

msgid "The \"bunch of stuff\" consists of the list of object files supplied as *objects*. *output_filename* should be a filename.  If *output_dir* is supplied, *output_filename* is relative to it (i.e. *output_filename* can provide directory components if needed)."
msgstr ""

msgid "*libraries* is a list of libraries to link against.  These are library names, not filenames, since they're translated into filenames in a platform-specific way (eg. *foo* becomes :file:`libfoo.a` on Unix and :file:`foo.lib` on DOS/Windows).  However, they can include a directory component, which means the linker will look in that specific directory rather than searching all the normal locations."
msgstr ""

msgid "*library_dirs*, if supplied, should be a list of directories to search for libraries that were specified as bare library names (ie. no directory component).  These are on top of the system default and those supplied to :meth:`add_library_dir` and/or :meth:`set_library_dirs`.  *runtime_library_dirs* is a list of directories that will be embedded into the shared library and used to search for other shared libraries that \\*it\\* depends on at run-time.  (This may only be relevant on Unix.)"
msgstr ""

msgid "*export_symbols* is a list of symbols that the shared library will export. (This appears to be relevant only on Windows.)"
msgstr ""

msgid "*debug* is as for :meth:`compile` and :meth:`create_static_lib`,  with the slight distinction that it actually matters on most platforms (as opposed to :meth:`create_static_lib`, which includes a *debug* flag mostly for form's sake)."
msgstr ""

msgid "*extra_preargs* and *extra_postargs* are as for :meth:`compile`  (except of course that they supply command-line arguments for the particular linker being used)."
msgstr ""

msgid "Raises :exc:`LinkError` on failure."
msgstr ""

msgid "Link an executable.  *output_progname* is the name of the file executable, while *objects* are a list of object filenames to link in. Other arguments  are as for the :meth:`link` method."
msgstr ""

msgid "Link a shared library. *output_libname* is the name of the output  library, while *objects* is a list of object filenames to link in.  Other arguments are as for the :meth:`link` method."
msgstr ""

msgid "Link a shared object. *output_filename* is the name of the shared object that will be created, while *objects* is a list of object filenames  to link in. Other arguments are as for the :meth:`link` method."
msgstr ""

msgid "Preprocess a single C/C++ source file, named in *source*. Output will be written to file named *output_file*, or *stdout* if *output_file* not supplied. *macros* is a list of macro definitions as for :meth:`compile`, which will augment the macros set with :meth:`define_macro` and :meth:`undefine_macro`. *include_dirs* is a list of directory names that will be added to the  default list, in the same way as :meth:`add_include_dir`."
msgstr ""

msgid "Raises :exc:`PreprocessError` on failure."
msgstr ""

msgid "The following utility methods are defined by the :class:`CCompiler` class, for use by the various concrete subclasses."
msgstr ""

msgid "Returns the filename of the executable for the given *basename*.  Typically for non-Windows platforms this is the same as the basename,  while Windows will get a :file:`.exe` added."
msgstr ""

msgid "Returns the filename for the given library name on the current platform. On Unix a library with *lib_type* of ``'static'`` will typically  be of the form :file:`liblibname.a`, while a *lib_type* of ``'dynamic'``  will be of the form :file:`liblibname.so`."
msgstr ""

msgid "Returns the name of the object files for the given source files. *source_filenames* should be a list of filenames."
msgstr ""

msgid "Returns the name of a shared object file for the given file name *basename*."
msgstr ""

msgid "Invokes :func:`distutils.util.execute` This method invokes a  Python function *func* with the given arguments *args*, after  logging and taking into account the *dry_run* flag. XXX see also."
msgstr ""

msgid "Invokes :func:`distutils.util.spawn`. This invokes an external  process to run the given command. XXX see also."
msgstr ""

msgid "Invokes :func:`distutils.dir_util.mkpath`. This creates a directory  and any missing ancestor directories. XXX see also."
msgstr ""

msgid "Invokes :meth:`distutils.file_util.move_file`. Renames *src* to  *dst*.  XXX see also."
msgstr ""

msgid "Write a message using :func:`distutils.log.debug`. XXX see also."
msgstr ""

msgid "Write a warning message *msg* to standard error."
msgstr ""

msgid "If the *debug* flag is set on this :class:`CCompiler` instance, print  *msg* to standard output, otherwise do nothing."
msgstr ""

msgid ":mod:`distutils.unixccompiler` --- Unix C Compiler"
msgstr ""

msgid "This module provides the :class:`UnixCCompiler` class, a subclass of :class:`CCompiler` that handles the typical Unix-style command-line  C compiler:"
msgstr ""

msgid "macros defined with :option:`-Dname[=value]`"
msgstr ""

msgid "macros undefined with :option:`-Uname`"
msgstr ""

msgid "include search directories specified with :option:`-Idir`"
msgstr ""

msgid "libraries specified with :option:`-llib`"
msgstr ""

msgid "library search directories specified with :option:`-Ldir`"
msgstr ""

msgid "compile handled by :program:`cc` (or similar) executable with :option:`-c` option: compiles :file:`.c` to :file:`.o`"
msgstr ""

msgid "link static library handled by :program:`ar` command (possibly with :program:`ranlib`)"
msgstr ""

msgid "link shared library handled by :program:`cc` :option:`-shared`"
msgstr ""

msgid ":mod:`distutils.msvccompiler` --- Microsoft Compiler"
msgstr ""

msgid "This module provides :class:`MSVCCompiler`, an implementation of the abstract :class:`CCompiler` class for Microsoft Visual Studio. Typically, extension modules need to be compiled with the same compiler that was used to compile Python. For Python 2.3 and earlier, the compiler was Visual Studio 6. For Python 2.4 and 2.5, the compiler is Visual Studio .NET 2003. The AMD64 and Itanium binaries are created using the Platform SDK."
msgstr ""

msgid ":class:`MSVCCompiler` will normally choose the right compiler, linker etc. on its own. To override this choice, the environment variables *DISTUTILS_USE_SDK* and *MSSdk* must be both set. *MSSdk* indicates that the current environment has been setup by the SDK's ``SetEnv.Cmd`` script, or that the environment variables had been registered when the SDK was installed; *DISTUTILS_USE_SDK* indicates that the distutils user has made an explicit choice to override the compiler selection by :class:`MSVCCompiler`."
msgstr ""

msgid ":mod:`distutils.bcppcompiler` --- Borland Compiler"
msgstr ""

msgid "This module provides :class:`BorlandCCompiler`, an subclass of the abstract :class:`CCompiler` class for the Borland C++ compiler."
msgstr ""

msgid ":mod:`distutils.cygwincompiler` --- Cygwin Compiler"
msgstr ""

msgid "This module provides the :class:`CygwinCCompiler` class, a subclass of :class:`UnixCCompiler` that handles the Cygwin port of the GNU C compiler to Windows.  It also contains the Mingw32CCompiler class which handles the mingw32 port of GCC (same as cygwin in no-cygwin mode)."
msgstr ""

msgid ":mod:`distutils.emxccompiler` --- OS/2 EMX Compiler"
msgstr ""

msgid "This module provides the EMXCCompiler class, a subclass of :class:`UnixCCompiler` that handles the EMX port of the GNU C compiler to OS/2."
msgstr ""

msgid ":mod:`distutils.archive_util` ---  Archiving utilities"
msgstr ""

msgid "This module provides a few functions for creating archive files, such as tarballs or zipfiles."
msgstr ""

msgid "Create an archive file (eg. ``zip`` or ``tar``).  *base_name*  is the name of the file to create, minus any format-specific extension;  *format* is the archive format: one of ``zip``, ``tar``,  ``ztar``, or ``gztar``. *root_dir* is a directory that will be the root directory of the archive; ie. we typically ``chdir`` into *root_dir* before  creating the archive.  *base_dir* is the directory where we start  archiving from; ie. *base_dir* will be the common prefix of all files and directories in the archive.  *root_dir* and *base_dir* both default to the current directory.  Returns the name of the archive file."
msgstr ""

msgid "'Create an (optional compressed) archive as a tar file from all files in and under *base_dir*. *compress* must be ``'gzip'`` (the default),  ``'compress'``, ``'bzip2'``, or ``None``.  Both :program:`tar` and the compression utility named by *compress* must be on the  default program search path, so this is probably Unix-specific.  The  output tar file will be named :file:`base_dir.tar`, possibly plus the appropriate compression extension (:file:`.gz`, :file:`.bz2` or :file:`.Z`).  Return the output filename."
msgstr ""

msgid "Create a zip file from all files in and under *base_dir*.  The output zip file will be named *base_dir* + :file:`.zip`.  Uses either the  :mod:`zipfile` Python module (if available) or the InfoZIP :file:`zip`  utility (if installed and found on the default search path).  If neither  tool is available, raises :exc:`DistutilsExecError`.   Returns the name of the output zip file."
msgstr ""

msgid ":mod:`distutils.dep_util` --- Dependency checking"
msgstr ""

msgid "This module provides functions for performing simple, timestamp-based dependency of files and groups of files; also, functions based entirely  on such timestamp dependency analysis."
msgstr ""

msgid "Return true if *source* exists and is more recently modified than *target*, or if *source* exists and *target* doesn't. Return false if both exist and *target* is the same age or newer  than *source*. Raise :exc:`DistutilsFileError` if *source* does not exist."
msgstr ""

msgid "Walk two filename lists in parallel, testing if each source is newer than its corresponding target.  Return a pair of lists (*sources*, *targets*) where source is newer than target, according to the semantics of :func:`newer`"
msgstr ""

msgid "Return true if *target* is out-of-date with respect to any file listed in *sources*  In other words, if *target* exists and is newer than every file in *sources*, return false; otherwise return true. *missing* controls what we do when a source file is missing; the default (``'error'``) is to blow up with an :exc:`OSError` from  inside :func:`os.stat`; if it is ``'ignore'``, we silently drop any missing source files; if it is ``'newer'``, any missing source files make us assume that *target* is out-of-date (this is handy in \"dry-run\" mode: it'll make you pretend to carry out commands that wouldn't work because inputs are missing, but that doesn't matter because you're not actually going to run the commands)."
msgstr ""

msgid ":mod:`distutils.dir_util` --- Directory tree operations"
msgstr ""

msgid "This module provides functions for operating on directories and trees of directories."
msgstr ""

msgid "Create a directory and any missing ancestor directories.  If the directory already exists (or if *name* is the empty string, which means the current directory, which of course exists), then do nothing.  Raise :exc:`DistutilsFileError` if unable to create some directory along the way (eg. some sub-path exists, but is a file rather than a directory).  If *verbose* is true, print a one-line summary of each mkdir to stdout.  Return the list of directories actually created."
msgstr ""

msgid "Create all the empty directories under *base_dir* needed to put *files* there. *base_dir* is just the a name of a directory which doesn't necessarily exist yet; *files* is a list of filenames to be interpreted relative to *base_dir*. *base_dir* + the directory portion of every file in *files* will be created if it doesn't already exist.  *mode*, *verbose* and *dry_run* flags  are as for :func:`mkpath`."
msgstr ""

msgid "Copy an entire directory tree *src* to a new location *dst*.  Both *src* and *dst* must be directory names.  If *src* is not a directory, raise :exc:`DistutilsFileError`.  If *dst* does  not exist, it is created with :func:`mkpath`.  The end result of the  copy is that every file in *src* is copied to *dst*, and  directories under *src* are recursively copied to *dst*. Return the list of files that were copied or might have been copied, using their output name. The return value is unaffected by *update* or *dry_run*: it is simply the list of all files under *src*, with the names changed to be under *dst*."
msgstr ""

msgid "*preserve_mode* and *preserve_times* are the same as for :func:`copy_file` in :mod:`distutils.file_util`; note that they only apply to regular files, not to directories.  If *preserve_symlinks* is true, symlinks will be copied as symlinks (on platforms that support them!); otherwise (the default), the destination of the symlink will be copied.  *update* and *verbose* are the same as for :func:`copy_file`."
msgstr ""

msgid "Recursively remove *directory* and all files and directories underneath it. Any errors are ignored (apart from being reported to ``sys.stdout`` if *verbose* is true)."
msgstr ""

msgid "**\\*\\*** Some of this could be replaced with the shutil module? **\\*\\***"
msgstr ""

msgid ":mod:`distutils.file_util` --- Single file operations"
msgstr ""

msgid "This module contains some utility functions for operating on individual files."
msgstr ""

msgid "Copy file *src* to *dst*. If *dst* is a directory, then *src* is copied there with the same name; otherwise, it must be a filename. (If the file exists, it will be ruthlessly clobbered.) If *preserve_mode* is true (the default), the file's mode (type and permission bits, or whatever is analogous on the current platform) is copied. If *preserve_times* is true (the default), the last-modified and last-access times are copied as well. If *update* is true, *src* will only be copied if *dst* does not exist, or if *dst* does exist but is older than *src*."
msgstr ""

msgid "*link* allows you to make hard links (using :func:`os.link`) or symbolic links (using :func:`os.symlink`) instead of copying: set it to ``'hard'`` or ``'sym'``; if it is ``None`` (the default), files are copied. Don't set *link* on systems that don't support it: :func:`copy_file` doesn't check if hard or symbolic linking is available.  It uses :func:`_copy_file_contents` to copy file contents."
msgstr ""

msgid "Return a tuple ``(dest_name, copied)``: *dest_name* is the actual  name of the output file, and *copied* is true if the file was copied  (or would have been copied, if *dry_run* true)."
msgstr ""

msgid "Move file *src* to *dst*. If *dst* is a directory, the file will be moved into it with the same name; otherwise, *src* is just renamed to *dst*.  Returns the new full name of the file."
msgstr ""

msgid "Handles cross-device moves on Unix using :func:`copy_file`.  What about other systems?"
msgstr ""

msgid "Create a file called *filename* and write *contents* (a sequence of strings without line terminators) to it."
msgstr ""

msgid ":mod:`distutils.util` --- Miscellaneous other utility functions"
msgstr ""

msgid "This module contains other assorted bits and pieces that don't fit into  any other utility module."
msgstr ""

msgid "Return a string that identifies the current platform.  This is used mainly to distinguish platform-specific build directories and platform-specific built distributions.  Typically includes the OS name and version and the architecture (as supplied by 'os.uname()'), although the exact information included depends on the OS; eg. for IRIX the architecture isn't particularly important (IRIX only runs on SGI hardware), but for Linux the kernel version isn't particularly important."
msgstr ""

msgid "Examples of returned values:"
msgstr ""

msgid "``linux-i586``"
msgstr ""

msgid "``linux-alpha``"
msgstr ""

msgid "``solaris-2.6-sun4u``"
msgstr ""

msgid "``irix-5.3``"
msgstr ""

msgid "``irix64-6.2``"
msgstr ""

msgid "For non-POSIX platforms, currently just returns ``sys.platform``."
msgstr ""

msgid "For Mac OS X systems the OS version reflects the minimal version on which binaries will run (that is, the value of ``MACOSX_DEPLOYMENT_TARGET`` during the build of Python), not the OS version of the current system."
msgstr ""

msgid "For universal binary builds on Mac OS X the architecture value reflects the univeral binary status instead of the architecture of the current processor. For 32-bit universal binaries the architecture is ``fat``, for 64-bit universal binaries the architecture is ``fat64``, and for 4-way universal binaries the architecture is ``universal``. Starting from Python 2.7 and Python 3.2 the architecture ``fat3`` is used for a 3-way universal build (ppc, i386, x86_64) and ``intel`` is used for a univeral build with the i386 and x86_64 architectures"
msgstr ""

msgid "Examples of returned values on Mac OS X:"
msgstr ""

msgid "``macosx-10.3-ppc``"
msgstr ""

msgid "``macosx-10.3-fat``"
msgstr ""

msgid "``macosx-10.5-universal``"
msgstr ""

msgid "``macosx-10.6-intel``"
msgstr ""

msgid "Return 'pathname' as a name that will work on the native filesystem, i.e. split it on '/' and put it back together again using the current directory separator. Needed because filenames in the setup script are always supplied in Unix style, and have to be converted to the local convention before we can actually use them in the filesystem.  Raises :exc:`ValueError` on non-Unix-ish systems if *pathname* either  starts or ends with a slash."
msgstr ""

msgid "Return *pathname* with *new_root* prepended.  If *pathname* is relative, this is equivalent to ``os.path.join(new_root,pathname)`` Otherwise, it requires making *pathname* relative and then joining the two, which is tricky on DOS/Windows."
msgstr ""

msgid "Ensure that 'os.environ' has all the environment variables we guarantee that users can use in config files, command-line options, etc.  Currently this includes:"
msgstr ""

msgid ":envvar:`HOME` - user's home directory (Unix only)"
msgstr ""

msgid ":envvar:`PLAT` - description of the current platform, including hardware and OS (see :func:`get_platform`)"
msgstr ""

msgid "Perform shell/Perl-style variable substitution on *s*.  Every occurrence of ``$`` followed by a name is considered a variable, and variable is substituted by the value found in the *local_vars* dictionary, or in ``os.environ`` if it's not in *local_vars*. *os.environ* is first checked/augmented to guarantee that it contains certain values: see :func:`check_environ`.  Raise :exc:`ValueError` for any variables not found in either *local_vars* or ``os.environ``."
msgstr ""

msgid "Note that this is not a fully-fledged string interpolation function. A valid ``$variable`` can consist only of upper and lower case letters, numbers and an underscore. No { } or ( ) style quoting is available."
msgstr ""

msgid "Generate a useful error message from an :exc:`EnvironmentError`  (:exc:`IOError` or :exc:`OSError`) exception object.   Handles Python 1.5.1 and later styles, and does what it can to deal with  exception objects that don't have a filename (which happens when the error  is due to a two-file operation, such as :func:`rename` or  :func:`link`).  Returns the error message as a string prefixed  with *prefix*."
msgstr ""

msgid "Split a string up according to Unix shell-like rules for quotes and backslashes. In short: words are delimited by spaces, as long as those spaces are not escaped by a backslash, or inside a quoted string. Single and double quotes are equivalent, and the quote characters can be backslash-escaped.  The backslash is stripped from any two-character escape sequence, leaving only the escaped character.  The quote characters are stripped from any quoted string.  Returns a list of words."
msgstr ""

msgid "Perform some action that affects the outside world (for instance, writing to the filesystem).  Such actions are special because they are disabled by the *dry_run* flag.  This method takes  care of all that bureaucracy for you; all you have to do is supply the function to call and an argument tuple for it (to embody the \"external action\" being performed), and an optional message to print."
msgstr ""

msgid "Convert a string representation of truth to true (1) or false (0)."
msgstr ""

msgid "True values are ``y``, ``yes``, ``t``, ``true``, ``on``  and ``1``; false values are ``n``, ``no``, ``f``, ``false``,  ``off`` and ``0``.  Raises :exc:`ValueError` if *val*  is anything else."
msgstr ""

msgid "Byte-compile a collection of Python source files to either :file:`.pyc` or :file:`.pyo` files in the same directory.  *py_files* is a list of files to compile; any files that don't end in :file:`.py` are silently skipped. *optimize* must be one of the following:"
msgstr ""

msgid "``0`` - don't optimize (generate :file:`.pyc`)"
msgstr ""

msgid "``1`` - normal optimization (like ``python -O``)"
msgstr ""

msgid "``2`` - extra optimization (like ``python -OO``)"
msgstr ""

msgid "If *force* is true, all files are recompiled regardless of timestamps."
msgstr ""

msgid "The source filename encoded in each :term:`bytecode` file defaults to the filenames listed in *py_files*; you can modify these with *prefix* and *basedir*. *prefix* is a string that will be stripped off of each source filename, and *base_dir* is a directory name that will be prepended (after *prefix* is stripped).  You can supply either or both (or neither) of *prefix* and *base_dir*, as you wish."
msgstr ""

msgid "If *dry_run* is true, doesn't actually do anything that would affect the filesystem."
msgstr ""

msgid "Byte-compilation is either done directly in this interpreter process with the standard :mod:`py_compile` module, or indirectly by writing a temporary script and executing it.  Normally, you should let :func:`byte_compile` figure out to use direct compilation or not (see the source for details).  The *direct* flag is used by the script generated in indirect mode; unless you know what you're doing, leave it set to ``None``."
msgstr ""

msgid "Return a version of *header* escaped for inclusion in an :rfc:`822` header, by ensuring there are 8 spaces space after each newline. Note that it does no other modification of the string."
msgstr ""

msgid ":mod:`distutils.dist` --- The Distribution class"
msgstr ""

msgid "This module provides the :class:`Distribution` class, which represents the module distribution being built/installed/distributed."
msgstr ""

msgid ":mod:`distutils.extension` --- The Extension class"
msgstr ""

msgid "This module provides the :class:`Extension` class, used to describe C/C++ extension modules in setup scripts."
msgstr ""

msgid ":mod:`distutils.debug` --- Distutils debug mode"
msgstr ""

msgid "This module provides the DEBUG flag."
msgstr ""

msgid ":mod:`distutils.errors` --- Distutils exceptions"
msgstr ""

msgid "Provides exceptions used by the Distutils modules.  Note that Distutils modules may raise standard exceptions; in particular, SystemExit is usually raised for errors that are obviously the end-user's fault (eg. bad command-line arguments)."
msgstr ""

msgid "This module is safe to use in ``from ... import *`` mode; it only exports symbols whose names start with ``Distutils`` and end with ``Error``."
msgstr ""

msgid ":mod:`distutils.fancy_getopt` --- Wrapper around the standard getopt module"
msgstr ""

msgid "This module provides a wrapper around the standard :mod:`getopt`  module that provides the following additional features:"
msgstr ""

msgid "short and long options are tied together"
msgstr ""

msgid "options have help strings, so :func:`fancy_getopt` could potentially  create a complete usage summary"
msgstr ""

msgid "options set attributes of a passed-in object"
msgstr ""

msgid "boolean options can have \"negative aliases\" --- eg. if :option:`--quiet` is the \"negative alias\" of :option:`--verbose`, then :option:`--quiet` on the command line sets *verbose* to false."
msgstr ""

msgid "**\\*\\*** Should be replaced with :mod:`optik` (which is also now known as :mod:`optparse` in Python 2.3 and later). **\\*\\***"
msgstr ""

msgid "Wrapper function. *options* is a list of ``(long_option, short_option, help_string)`` 3-tuples as described in the constructor for :class:`FancyGetopt`. *negative_opt* should be a dictionary mapping option names to option names, both the key and value should be in the *options* list. *object* is an object which will be used to store values (see the :meth:`getopt` method of the :class:`FancyGetopt` class). *args* is the argument list. Will use ``sys.argv[1:]`` if you  pass ``None`` as *args*."
msgstr ""

msgid "Wraps *text* to less than *width* wide."
msgstr ""

msgid "The option_table is a list of 3-tuples: ``(long_option, short_option, help_string)``"
msgstr ""

msgid "If an option takes an argument, its *long_option* should have ``'='`` appended; *short_option* should just be a single character, no ``':'`` in any case. *short_option* should be ``None`` if a *long_option*  doesn't have a corresponding *short_option*. All option tuples must have long options."
msgstr ""

msgid "The :class:`FancyGetopt` class provides the following methods:"
msgstr ""

msgid "Parse command-line options in args. Store as attributes on *object*."
msgstr ""

msgid "If *args* is ``None`` or not supplied, uses ``sys.argv[1:]``.  If *object* is ``None`` or not supplied, creates a new :class:`OptionDummy` instance, stores option values there, and returns a tuple ``(args, object)``.  If *object* is supplied, it is modified in place and :func:`getopt` just returns *args*; in both cases, the returned *args* is a modified copy of the passed-in *args* list, which is left untouched."
msgstr ""

msgid "Returns the list of ``(option, value)`` tuples processed by the previous run of :meth:`getopt`  Raises :exc:`RuntimeError` if :meth:`getopt` hasn't been called yet."
msgstr ""

msgid "Generate help text (a list of strings, one per suggested line of output) from the option table for this :class:`FancyGetopt` object."
msgstr ""

msgid "If supplied, prints the supplied *header* at the top of the help."
msgstr ""

msgid ":mod:`distutils.filelist` --- The FileList class"
msgstr ""

msgid "This module provides the :class:`FileList` class, used for poking about the filesystem and building lists of files."
msgstr ""

msgid ":mod:`distutils.log` --- Simple PEP 282-style logging"
msgstr ""

msgid ":mod:`distutils.spawn` --- Spawn a sub-process"
msgstr ""

msgid "This module provides the :func:`spawn` function, a front-end to  various platform-specific functions for launching another program in a  sub-process. Also provides :func:`find_executable` to search the path for a given executable name."
msgstr ""

msgid ":mod:`distutils.sysconfig` --- System configuration information"
msgstr ""

msgid "The :mod:`distutils.sysconfig` module provides access to Python's low-level configuration information.  The specific configuration variables available depend heavily on the platform and configuration. The specific variables depend on the build process for the specific version of Python being run; the variables are those found in the :file:`Makefile` and configuration header that are installed with Python on Unix systems.  The configuration header is called :file:`pyconfig.h` for Python versions starting with 2.2, and :file:`config.h` for earlier versions of Python."
msgstr ""

msgid "Some additional functions are provided which perform some useful manipulations for other parts of the :mod:`distutils` package."
msgstr ""

msgid "The result of ``os.path.normpath(sys.prefix)``."
msgstr ""

msgid "The result of ``os.path.normpath(sys.exec_prefix)``."
msgstr ""

msgid "Return the value of a single variable.  This is equivalent to ``get_config_vars().get(name)``."
msgstr ""

msgid "Return a set of variable definitions.  If there are no arguments, this returns a dictionary mapping names of configuration variables to values.  If arguments are provided, they should be strings, and the return value will be a sequence giving the associated values. If a given name does not have a corresponding value, ``None`` will be included for that variable."
msgstr ""

msgid "Return the full path name of the configuration header.  For Unix, this will be the header generated by the :program:`configure` script; for other platforms the header will have been supplied directly by the Python source distribution.  The file is a platform-specific text file."
msgstr ""

msgid "Return the full path name of the :file:`Makefile` used to build Python.  For Unix, this will be a file generated by the :program:`configure` script; the meaning for other platforms will vary.  The file is a platform-specific text file, if it exists. This function is only useful on POSIX platforms."
msgstr ""

msgid "Return the directory for either the general or platform-dependent C include files.  If *plat_specific* is true, the platform-dependent include directory is returned; if false or omitted, the platform-independent directory is returned. If *prefix* is given, it is used as either the prefix instead of :const:`PREFIX`, or as the exec-prefix instead of :const:`EXEC_PREFIX` if *plat_specific* is true."
msgstr ""

msgid "Return the directory for either the general or platform-dependent library installation.  If *plat_specific* is true, the platform-dependent include directory is returned; if false or omitted, the platform-independent directory is returned.  If *prefix* is given, it is used as either the prefix instead of :const:`PREFIX`, or as the exec-prefix instead of :const:`EXEC_PREFIX` if *plat_specific* is true.  If *standard_lib* is true, the directory for the standard library is returned rather than the directory for the installation of third-party extensions."
msgstr ""

msgid "The following function is only intended for use within the :mod:`distutils` package."
msgstr ""

msgid "Do any platform-specific customization of a :class:`distutils.ccompiler.CCompiler` instance."
msgstr ""

msgid "This function is only needed on Unix at this time, but should be called consistently to support forward-compatibility.  It inserts the information that varies across Unix flavors and is stored in Python's :file:`Makefile`.  This information includes the selected compiler, compiler and linker options, and the extension used by the linker for shared objects."
msgstr ""

msgid "This function is even more special-purpose, and should only be used from Python's own build procedures."
msgstr ""

msgid "Inform the :mod:`distutils.sysconfig` module that it is being used as part of the build process for Python.  This changes a lot of relative locations for files, allowing them to be located in the build area rather than in an installed Python."
msgstr ""

msgid ":mod:`distutils.text_file` --- The TextFile class"
msgstr ""

msgid "This module provides the :class:`TextFile` class, which gives an interface  to text files that (optionally) takes care of stripping comments, ignoring  blank lines, and joining lines with backslashes."
msgstr ""

msgid "This class provides a file-like object that takes care of all  the things you commonly want to do when processing a text file  that has some line-by-line syntax: strip comments (as long as ``#``  is your comment character), skip blank lines, join adjacent lines by escaping the newline (ie. backslash at end of line), strip leading and/or trailing whitespace.  All of these are optional and independently controllable."
msgstr ""

msgid "The class provides a :meth:`warn` method so you can generate  warning messages that report physical line number, even if the  logical line in question spans multiple physical lines.  Also  provides :meth:`unreadline` for implementing line-at-a-time lookahead."
msgstr ""

msgid ":class:`TextFile` instances are create with either *filename*, *file*, or both. :exc:`RuntimeError` is raised if both are ``None``. *filename* should be a string, and *file* a file object (or something that provides :meth:`readline` and :meth:`close`  methods).  It is recommended that you supply at least *filename*,  so that :class:`TextFile` can include it in warning messages.  If *file* is not supplied, :class:`TextFile` creates its own using the :func:`open` built-in function."
msgstr ""

msgid "The options are all boolean, and affect the values returned by :meth:`readline`"
msgstr ""

msgid "option name"
msgstr ""

msgid "default"
msgstr ""

msgid "*strip_comments*"
msgstr ""

msgid "strip from ``'#'`` to end-of- line, as well as any whitespace leading up to the ``'#'``\\ ---unless it is escaped by a backslash"
msgstr ""

msgid "true"
msgstr ""

msgid "*lstrip_ws*"
msgstr ""

msgid "strip leading whitespace from each line before returning it"
msgstr ""

msgid "false"
msgstr ""

msgid "*rstrip_ws*"
msgstr ""

msgid "strip trailing whitespace (including line terminator!) from each line before returning it."
msgstr ""

msgid "*skip_blanks*"
msgstr ""

msgid "skip lines that are empty \\*after\\* stripping comments and whitespace.  (If both lstrip_ws and rstrip_ws are false, then some lines may consist of solely whitespace: these will \\*not\\* be skipped, even if *skip_blanks* is true.)"
msgstr ""

msgid "*join_lines*"
msgstr ""

msgid "if a backslash is the last non-newline character on a line after stripping comments and whitespace, join the following line to it to form one logical line; if N consecutive lines end with a backslash, then N+1 physical lines will be joined to form one logical line."
msgstr ""

msgid "*collapse_join*"
msgstr ""

msgid "strip leading whitespace from lines that are joined to their predecessor; only matters if ``(join_lines and not lstrip_ws)``"
msgstr ""

msgid "Note that since *rstrip_ws* can strip the trailing newline, the semantics of :meth:`readline` must differ from those of the built-in file object's :meth:`readline` method!  In particular, :meth:`readline`  returns ``None`` for end-of-file: an empty string might just be a  blank line (or an all-whitespace line), if *rstrip_ws* is true  but *skip_blanks* is not."
msgstr ""

msgid "Open a new file *filename*.  This overrides any *file* or *filename* constructor arguments."
msgstr ""

msgid "Close the current file and forget everything we know about it (including the filename and the current line number)."
msgstr ""

msgid "Print (to stderr) a warning message tied to the current logical line in the current file.  If the current logical line in the file spans multiple physical lines, the warning refers to the whole range, such as ``\"lines 3-5\"``.  If *line* is supplied,  it overrides the current line number; it may be a list or tuple  to indicate a range of physical lines, or an integer for a  single physical line."
msgstr ""

msgid "Read and return a single logical line from the current file (or from an internal buffer if lines have previously been \"unread\" with :meth:`unreadline`).  If the *join_lines* option  is true, this may involve reading multiple physical lines concatenated into a single string.  Updates the current line number,  so calling :meth:`warn` after :meth:`readline` emits a warning  about the physical line(s) just read.  Returns ``None`` on end-of-file,  since the empty string can occur if *rstrip_ws* is true but  *strip_blanks* is not."
msgstr ""

msgid "Read and return the list of all logical lines remaining in the current file. This updates the current line number to the last line of the file."
msgstr ""

msgid "Push *line* (a string) onto an internal buffer that will be checked by future :meth:`readline` calls.  Handy for implementing a parser with line-at-a-time lookahead. Note that lines that are \"unread\" with :meth:`unreadline` are not subsequently re-cleansed (whitespace  stripped, or whatever) when read with :meth:`readline`. If multiple calls are made to :meth:`unreadline` before a call to :meth:`readline`, the lines will be returned most in most recent first order."
msgstr ""

msgid ":mod:`distutils.version` --- Version number classes"
msgstr ""

msgid ":mod:`distutils.cmd` --- Abstract base class for Distutils commands"
msgstr ""

msgid "This module supplies the abstract base class :class:`Command`."
msgstr ""

msgid "Abstract base class for defining command classes, the \"worker bees\" of the Distutils.  A useful analogy for command classes is to think of them as subroutines with local variables called *options*.  The options are declared in :meth:`initialize_options` and defined (given their final values) in :meth:`finalize_options`, both of which must be defined by every command class. The distinction between the two is necessary because option values might come from the outside world (command line, config file, ...), and any options dependent on other options must be computed after these outside influences have been processed --- hence :meth:`finalize_options`.  The body of the subroutine, where it does all its work based on the values of its options, is the :meth:`run` method, which must also be implemented by every command class."
msgstr ""

msgid "The class constructor takes a single argument *dist*, a  :class:`Distribution` instance."
msgstr ""

msgid ":mod:`distutils.command` --- Individual Distutils commands"
msgstr ""

msgid ":mod:`distutils.command.bdist` --- Build a binary installer"
msgstr ""

msgid ":mod:`distutils.command.bdist_packager` --- Abstract base class for packagers"
msgstr ""

msgid ":mod:`distutils.command.bdist_dumb` --- Build a \"dumb\" installer"
msgstr ""

msgid ":mod:`distutils.command.bdist_msi` --- Build a Microsoft Installer binary package"
msgstr ""

msgid "Builds a `Windows Installer`_ (.msi) binary package."
msgstr ""

msgid "In most cases, the ``bdist_msi`` installer is a better choice than the ``bdist_wininst`` installer, because it provides better support for Win64 platforms, allows administrators to perform non-interactive installations, and allows installation through group policies."
msgstr ""

msgid ":mod:`distutils.command.bdist_rpm` --- Build a binary distribution as a Redhat RPM and SRPM"
msgstr ""

msgid ":mod:`distutils.command.bdist_wininst` --- Build a Windows installer"
msgstr ""

msgid ":mod:`distutils.command.sdist` --- Build a source distribution"
msgstr ""

msgid ":mod:`distutils.command.build` --- Build all files of a package"
msgstr ""

msgid ":mod:`distutils.command.build_clib` --- Build any C libraries in a package"
msgstr ""

msgid ":mod:`distutils.command.build_ext` --- Build any extensions in a package"
msgstr ""

msgid ":mod:`distutils.command.build_py` --- Build the .py/.pyc files of a package"
msgstr ""

msgid "Alternative implementation of build_py which also runs the 2to3 conversion library on each .py file that is going to be installed. To use this in a setup.py file for a distribution that is designed to run with both Python 2.x and 3.x, add::"
msgstr ""

msgid "try:    from distutils.command.build_py import build_py_2to3 as build_py except ImportError:    from distutils.command.build_py import build_py"
msgstr ""

msgid "to your setup.py, and later::"
msgstr ""

msgid "cmdclass = {'build_py':build_py}"
msgstr ""

msgid "to the invocation of setup()."
msgstr ""

msgid ":mod:`distutils.command.build_scripts` --- Build the scripts of a package"
msgstr ""

msgid ":mod:`distutils.command.clean` --- Clean a package build area"
msgstr ""

msgid ":mod:`distutils.command.config` --- Perform package configuration"
msgstr ""

msgid ":mod:`distutils.command.install` --- Install a package"
msgstr ""

msgid ":mod:`distutils.command.install_data` --- Install data files from a package"
msgstr ""

msgid ":mod:`distutils.command.install_headers` --- Install C/C++ header files from a package"
msgstr ""

msgid ":mod:`distutils.command.install_lib` --- Install library files from a package"
msgstr ""

msgid ":mod:`distutils.command.install_scripts` --- Install script files from a package"
msgstr ""

msgid ":mod:`distutils.command.register` --- Register a module with the Python Package Index"
msgstr ""

msgid "The ``register`` command registers the package with the Python Package  Index. This is described in more detail in :pep:`301`."
msgstr ""

msgid "Creating a new Distutils command"
msgstr ""

msgid "This section outlines the steps to create a new Distutils command."
msgstr ""

msgid "A new command lives in a module in the :mod:`distutils.command` package. There is a sample template in that directory called  :file:`command_template`. Copy this file to a new module with the same name as the new command you're implementing. This module should implement a class with the same name as the module (and the command). So, for instance, to create the command ``peel_banana`` (so that users can run ``setup.py peel_banana``), you'd copy :file:`command_template`  to :file:`distutils/command/peel_banana.py`, then edit it so that it's implementing the class :class:`peel_banana`, a subclass of :class:`distutils.cmd.Command`."
msgstr ""

msgid "Subclasses of :class:`Command` must define the following methods."
msgstr ""

msgid "Set default values for all the options that this command supports.  Note that these defaults may be overridden by other commands, by the setup script, by config files, or by the command-line.  Thus, this is not the place to code dependencies between options; generally, :meth:`initialize_options` implementations are just a bunch of ``self.foo = None`` assignments."
msgstr ""

msgid "Set final values for all the options that this command supports. This is always called as late as possible, ie.  after any option assignments from the command-line or from other commands have been done.  Thus, this is the place to to code option dependencies: if *foo* depends on *bar*, then it is safe to set *foo* from *bar* as long as *foo* still has the same value it was assigned in :meth:`initialize_options`."
msgstr ""

msgid "A command's raison d'etre: carry out the action it exists to perform, controlled by the options initialized in :meth:`initialize_options`, customized by other commands, the setup script, the command-line, and config files, and finalized in :meth:`finalize_options`.  All terminal output and filesystem interaction should be done by :meth:`run`."
msgstr ""

msgid "*sub_commands* formalizes the notion of a \"family\" of commands, eg. ``install`` as the parent with sub-commands ``install_lib``, ``install_headers``, etc.  The parent of a family of commands defines *sub_commands* as a class attribute; it's a list of 2-tuples ``(command_name, predicate)``, with *command_name* a string and *predicate* a function, a string or None. *predicate* is a method of the parent command that determines whether the corresponding command is applicable in the current situation.  (Eg. we ``install_headers`` is only applicable if we have any C header files to install.)  If *predicate* is None, that command is always applicable."
msgstr ""

msgid "*sub_commands* is usually defined at the \\*end\\* of a class, because predicates can be methods of the class, so they must already have been defined.  The canonical example is the :command:`install` command."
msgstr ""

msgid "Creating Built Distributions"
msgstr ""

msgid "A \"built distribution\" is what you're probably used to thinking of either as a \"binary package\" or an \"installer\" (depending on your background).  It's not necessarily binary, though, because it might contain only Python source code and/or byte-code; and we don't call it a package, because that word is already spoken for in Python.  (And \"installer\" is a term specific to the world of mainstream desktop systems.)"
msgstr ""

msgid "A built distribution is how you make life as easy as possible for installers of your module distribution: for users of RPM-based Linux systems, it's a binary RPM; for Windows users, it's an executable installer; for Debian-based Linux users, it's a Debian package; and so forth.  Obviously, no one person will be able to create built distributions for every platform under the sun, so the Distutils are designed to enable module developers to concentrate on their specialty---writing code and creating source distributions---while an intermediary species called *packagers* springs up to turn source distributions into built distributions for as many platforms as there are packagers."
msgstr ""

msgid "Of course, the module developer could be his own packager; or the packager could be a volunteer \"out there\" somewhere who has access to a platform which the original developer does not; or it could be software periodically grabbing new source distributions and turning them into built distributions for as many platforms as the software has access to.  Regardless of who they are, a packager uses the setup script and the :command:`bdist` command family to generate built distributions."
msgstr ""

msgid "As a simple example, if I run the following command in the Distutils source tree::"
msgstr ""

msgid "python setup.py bdist"
msgstr ""

msgid "then the Distutils builds my module distribution (the Distutils itself in this case), does a \"fake\" installation (also in the :file:`build` directory), and creates the default type of built distribution for my platform.  The default format for built distributions is a \"dumb\" tar file on Unix, and a simple executable installer on Windows.  (That tar file is considered \"dumb\" because it has to be unpacked in a specific location to work.)"
msgstr ""

msgid "Thus, the above command on a Unix system creates :file:`Distutils-1.0.{plat}.tar.gz`; unpacking this tarball from the right place installs the Distutils just as though you had downloaded the source distribution and run ``python setup.py install``.  (The \"right place\" is either the root of the filesystem or  Python's :file:`{prefix}` directory, depending on the options given to the :command:`bdist_dumb` command; the default is to make dumb distributions relative to :file:`{prefix}`.)"
msgstr ""

msgid "Obviously, for pure Python distributions, this isn't any simpler than just running ``python setup.py install``\\ ---but for non-pure distributions, which include extensions that would need to be compiled, it can mean the difference between someone being able to use your extensions or not.  And creating \"smart\" built distributions, such as an RPM package or an executable installer for Windows, is far more convenient for users even if your distribution doesn't include any extensions."
msgstr ""

msgid "The :command:`bdist` command has a :option:`--formats` option, similar to the :command:`sdist` command, which you can use to select the types of built distribution to generate: for example, ::"
msgstr ""

msgid "python setup.py bdist --format=zip"
msgstr ""

msgid "would, when run on a Unix system, create :file:`Distutils-1.0.{plat}.zip`\\ ---again, this archive would be unpacked from the root directory to install the Distutils."
msgstr ""

msgid "The available formats for built distributions are:"
msgstr ""

msgid "Format"
msgstr ""

msgid "Description"
msgstr ""

msgid "Notes"
msgstr ""

msgid "``gztar``"
msgstr ""

msgid "gzipped tar file (:file:`.tar.gz`)"
msgstr ""

msgid "(1),(3)"
msgstr ""

msgid "``ztar``"
msgstr ""

msgid "compressed tar file (:file:`.tar.Z`)"
msgstr ""

msgid "\\(3)"
msgstr ""

msgid "``tar``"
msgstr ""

msgid "tar file (:file:`.tar`)"
msgstr ""

msgid "``zip``"
msgstr ""

msgid "zip file (:file:`.zip`)"
msgstr ""

msgid "(2),(4)"
msgstr ""

msgid "``rpm``"
msgstr ""

msgid "RPM"
msgstr ""

msgid "\\(5)"
msgstr ""

msgid "``pkgtool``"
msgstr ""

msgid "Solaris :program:`pkgtool`"
msgstr ""

msgid "``sdux``"
msgstr ""

msgid "HP-UX :program:`swinstall`"
msgstr ""

msgid "``wininst``"
msgstr ""

msgid "self-extracting ZIP file for Windows"
msgstr ""

msgid "\\(4)"
msgstr ""

msgid "``msi``"
msgstr ""

msgid "Microsoft Installer."
msgstr ""

msgid "Notes:"
msgstr ""

msgid "default on Unix"
msgstr ""

msgid "default on Windows"
msgstr ""

msgid "requires external utilities: :program:`tar` and possibly one of :program:`gzip`, :program:`bzip2`, or :program:`compress`"
msgstr ""

msgid "requires either external :program:`zip` utility or :mod:`zipfile` module (part of the standard Python library since Python 1.6)"
msgstr ""

msgid "requires external :program:`rpm` utility, version 3.0.4 or better (use ``rpm --version`` to find out which version you have)"
msgstr ""

msgid "You don't have to use the :command:`bdist` command with the :option:`--formats` option; you can also use the command that directly implements the format you're interested in.  Some of these :command:`bdist` \"sub-commands\" actually generate several similar formats; for instance, the :command:`bdist_dumb` command generates all the \"dumb\" archive formats (``tar``, ``ztar``, ``gztar``, and ``zip``), and :command:`bdist_rpm` generates both binary and source RPMs.  The :command:`bdist` sub-commands, and the formats generated by each, are:"
msgstr ""

msgid "Command"
msgstr ""

msgid "Formats"
msgstr ""

msgid ":command:`bdist_dumb`"
msgstr ""

msgid "tar, ztar, gztar, zip"
msgstr ""

msgid ":command:`bdist_rpm`"
msgstr ""

msgid "rpm, srpm"
msgstr ""

msgid ":command:`bdist_wininst`"
msgstr ""

msgid "wininst"
msgstr ""

msgid ":command:`bdist_msi`"
msgstr ""

msgid "msi"
msgstr ""

msgid "The following sections give details on the individual :command:`bdist_\\*` commands."
msgstr ""

msgid "Creating dumb built distributions"
msgstr ""

msgid "**\\*\\*** Need to document absolute vs. prefix-relative packages here, but first I have to implement it! **\\*\\***"
msgstr ""

msgid "Creating RPM packages"
msgstr ""

msgid "The RPM format is used by many popular Linux distributions, including Red Hat, SuSE, and Mandrake.  If one of these (or any of the other RPM-based Linux distributions) is your usual environment, creating RPM packages for other users of that same distribution is trivial. Depending on the complexity of your module distribution and differences between Linux distributions, you may also be able to create RPMs that work on different RPM-based distributions."
msgstr ""

msgid "The usual way to create an RPM of your module distribution is to run the :command:`bdist_rpm` command::"
msgstr ""

msgid "python setup.py bdist_rpm"
msgstr ""

msgid "or the :command:`bdist` command with the :option:`--format` option::"
msgstr ""

msgid "python setup.py bdist --formats=rpm"
msgstr ""

msgid "The former allows you to specify RPM-specific options; the latter allows  you to easily specify multiple formats in one run.  If you need to do both, you can explicitly specify multiple :command:`bdist_\\*` commands and their options::"
msgstr ""

msgid "python setup.py bdist_rpm --packager=\"John Doe <jdoe@example.org>\" \\                 bdist_wininst --target_version=\"2.0\""
msgstr ""

msgid "Creating RPM packages is driven by a :file:`.spec` file, much as using the Distutils is driven by the setup script.  To make your life easier, the :command:`bdist_rpm` command normally creates a :file:`.spec` file based on the information you supply in the setup script, on the command line, and in any Distutils configuration files.  Various options and sections in the :file:`.spec` file are derived from options in the setup script as follows:"
msgstr ""

msgid "RPM :file:`.spec` file option or section"
msgstr ""

msgid "Distutils setup script option"
msgstr ""

msgid "Name"
msgstr ""

msgid ":option:`name`"
msgstr ""

msgid "Summary (in preamble)"
msgstr ""

msgid ":option:`description`"
msgstr ""

msgid "Version"
msgstr ""

msgid ":option:`version`"
msgstr ""

msgid "Vendor"
msgstr ""

msgid ":option:`author` and :option:`author_email`, or  --- & :option:`maintainer` and :option:`maintainer_email`"
msgstr ""

msgid "Copyright"
msgstr ""

msgid ":option:`license`"
msgstr ""

msgid "Url"
msgstr ""

msgid ":option:`url`"
msgstr ""

msgid "%description (section)"
msgstr ""

msgid ":option:`long_description`"
msgstr ""

msgid "Additionally, there are many options in :file:`.spec` files that don't have corresponding options in the setup script.  Most of these are handled through options to the :command:`bdist_rpm` command as follows:"
msgstr ""

msgid ":command:`bdist_rpm` option"
msgstr ""

msgid "default value"
msgstr ""

msgid "Release"
msgstr ""

msgid ":option:`release`"
msgstr ""

msgid "\"1\""
msgstr ""

msgid "Group"
msgstr ""

msgid ":option:`group`"
msgstr ""

msgid "\"Development/Libraries\""
msgstr ""

msgid ":option:`vendor`"
msgstr ""

msgid "(see above)"
msgstr ""

msgid "Packager"
msgstr ""

msgid ":option:`packager`"
msgstr ""

msgid "(none)"
msgstr ""

msgid "Provides"
msgstr ""

msgid ":option:`provides`"
msgstr ""

msgid "Requires"
msgstr ""

msgid ":option:`requires`"
msgstr ""

msgid "Conflicts"
msgstr ""

msgid ":option:`conflicts`"
msgstr ""

msgid "Obsoletes"
msgstr ""

msgid ":option:`obsoletes`"
msgstr ""

msgid "Distribution"
msgstr ""

msgid ":option:`distribution_name`"
msgstr ""

msgid "BuildRequires"
msgstr ""

msgid ":option:`build_requires`"
msgstr ""

msgid "Icon"
msgstr ""

msgid ":option:`icon`"
msgstr ""

msgid "Obviously, supplying even a few of these options on the command-line would be tedious and error-prone, so it's usually best to put them in the setup configuration file, :file:`setup.cfg`\\ ---see section :ref:`setup-config`.  If you distribute or package many Python module distributions, you might want to put options that apply to all of them in your personal Distutils configuration file (:file:`~/.pydistutils.cfg`).  If you want to temporarily disable this file, you can pass the --no-user-cfg option to setup.py."
msgstr ""

msgid "There are three steps to building a binary RPM package, all of which are handled automatically by the Distutils:"
msgstr ""

msgid "create a :file:`.spec` file, which describes the package (analogous  to the Distutils setup script; in fact, much of the information in the  setup script winds up in the :file:`.spec` file)"
msgstr ""

msgid "create the source RPM"
msgstr ""

msgid "create the \"binary\" RPM (which may or may not contain binary code, depending on whether your module distribution contains Python extensions)"
msgstr ""

msgid "Normally, RPM bundles the last two steps together; when you use the Distutils, all three steps are typically bundled together."
msgstr ""

msgid "If you wish, you can separate these three steps.  You can use the :option:`--spec-only` option to make :command:`bdist_rpm` just create the :file:`.spec` file and exit; in this case, the :file:`.spec` file will be written to the \"distribution directory\"---normally :file:`dist/`, but customizable with the :option:`--dist-dir` option.  (Normally, the :file:`.spec` file winds up deep in the \"build tree,\" in a temporary directory created by :command:`bdist_rpm`.)"
msgstr ""

msgid "Creating Windows Installers"
msgstr ""

msgid "Executable installers are the natural format for binary distributions on Windows.  They display a nice graphical user interface, display some information about the module distribution to be installed taken from the metadata in the setup script, let the user select a few options, and start or cancel the installation."
msgstr ""

msgid "Since the metadata is taken from the setup script, creating Windows installers is usually as easy as running::"
msgstr ""

msgid "python setup.py bdist_wininst"
msgstr ""

msgid "or the :command:`bdist` command with the :option:`--formats` option::"
msgstr ""

msgid "python setup.py bdist --formats=wininst"
msgstr ""

msgid "If you have a pure module distribution (only containing pure Python modules and packages), the resulting installer will be version independent and have a name like :file:`foo-1.0.win32.exe`.  These installers can even be created on Unix platforms or Mac OS X."
msgstr ""

msgid "If you have a non-pure distribution, the extensions can only be created on a Windows platform, and will be Python version dependent. The installer filename will reflect this and now has the form :file:`foo-1.0.win32-py2.0.exe`.  You have to create a separate installer for every Python version you want to support."
msgstr ""

msgid "The installer will try to compile pure modules into :term:`bytecode` after installation on the target system in normal and optimizing mode.  If you don't want this to happen for some reason, you can run the :command:`bdist_wininst` command with the :option:`--no-target-compile` and/or the :option:`--no-target-optimize` option."
msgstr ""

msgid "By default the installer will display the cool \"Python Powered\" logo when it is run, but you can also supply your own 152x261 bitmap which must be a Windows :file:`.bmp` file with the :option:`--bitmap` option."
msgstr ""

msgid "The installer will also display a large title on the desktop background window when it is run, which is constructed from the name of your distribution and the version number.  This can be changed to another text by using the :option:`--title` option."
msgstr ""

msgid "The installer file will be written to the \"distribution directory\" --- normally :file:`dist/`, but customizable with the :option:`--dist-dir` option."
msgstr ""

msgid "Cross-compiling on Windows"
msgstr ""

msgid "Starting with Python 2.6, distutils is capable of cross-compiling between Windows platforms.  In practice, this means that with the correct tools installed, you can use a 32bit version of Windows to create 64bit extensions and vice-versa."
msgstr ""

msgid "To build for an alternate platform, specify the :option:`--plat-name` option to the build command.  Valid values are currently 'win32', 'win-amd64' and 'win-ia64'.  For example, on a 32bit version of Windows, you could execute::"
msgstr ""

msgid "python setup.py build --plat-name=win-amd64"
msgstr ""

msgid "to build a 64bit version of your extension.  The Windows Installers also support this option, so the command::"
msgstr ""

msgid "python setup.py build --plat-name=win-amd64 bdist_wininst"
msgstr ""

msgid "would create a 64bit installation executable on your 32bit version of Windows."
msgstr ""

msgid "To cross-compile, you must download the Python source code and cross-compile Python itself for the platform you are targetting - it is not possible from a binary installtion of Python (as the .lib etc file for other platforms are not included.)  In practice, this means the user of a 32 bit operating system will need to use Visual Studio 2008 to open the :file:`PCBuild/PCbuild.sln` solution in the Python source tree and build the \"x64\" configuration of the 'pythoncore' project before cross-compiling extensions is possible."
msgstr ""

msgid "Note that by default, Visual Studio 2008 does not install 64bit compilers or tools.  You may need to reexecute the Visual Studio setup process and select these tools (using Control Panel->[Add/Remove] Programs is a convenient way to check or modify your existing install.)"
msgstr ""

msgid "The Postinstallation script"
msgstr ""

msgid "Starting with Python 2.3, a postinstallation script can be specified with the :option:`--install-script` option.  The basename of the script must be specified, and the script filename must also be listed in the scripts argument to the setup function."
msgstr ""

msgid "This script will be run at installation time on the target system after all the files have been copied, with ``argv[1]`` set to :option:`-install`, and again at uninstallation time before the files are removed with ``argv[1]`` set to :option:`-remove`."
msgstr ""

msgid "The installation script runs embedded in the windows installer, every output (``sys.stdout``, ``sys.stderr``) is redirected into a buffer and will be displayed in the GUI after the script has finished."
msgstr ""

msgid "Some functions especially useful in this context are available as additional built-in functions in the installation script."
msgstr ""

msgid "These functions should be called when a directory or file is created by the postinstall script at installation time.  It will register *path* with the uninstaller, so that it will be removed when the distribution is uninstalled. To be safe, directories are only removed if they are empty."
msgstr ""

msgid "This function can be used to retrieve special folder locations on Windows like the Start Menu or the Desktop.  It returns the full path to the folder. *csidl_string* must be one of the following strings::"
msgstr ""

msgid "\"CSIDL_APPDATA\"  \"CSIDL_COMMON_STARTMENU\" \"CSIDL_STARTMENU\"  \"CSIDL_COMMON_DESKTOPDIRECTORY\" \"CSIDL_DESKTOPDIRECTORY\"  \"CSIDL_COMMON_STARTUP\" \"CSIDL_STARTUP\"  \"CSIDL_COMMON_PROGRAMS\" \"CSIDL_PROGRAMS\"  \"CSIDL_FONTS\""
msgstr ""

msgid "If the folder cannot be retrieved, :exc:`OSError` is raised."
msgstr ""

msgid "Which folders are available depends on the exact Windows version, and probably also the configuration.  For details refer to Microsoft's documentation of the :cfunc:`SHGetSpecialFolderPath` function."
msgstr ""

msgid "This function creates a shortcut. *target* is the path to the program to be started by the shortcut. *description* is the description of the shortcut. *filename* is the title of the shortcut that the user will see. *arguments* specifies the command line arguments, if any. *workdir* is the working directory for the program. *iconpath* is the file containing the icon for the shortcut, and *iconindex* is the index of the icon in the file *iconpath*.  Again, for details consult the Microsoft documentation for the :class:`IShellLink` interface."
msgstr ""

msgid "Vista User Access Control (UAC)"
msgstr ""

msgid "Starting with Python 2.6, bdist_wininst supports a :option:`--user-access-control` option.  The default is 'none' (meaning no UAC handling is done), and other valid values are 'auto' (meaning prompt for UAC elevation if Python was installed for all users) and 'force' (meaning always prompt for elevation)."
msgstr ""

msgid "Command Reference"
msgstr ""

msgid "Installing modules: the :command:`install` command family"
msgstr ""

msgid "The install command ensures that the build commands have been run and then runs the subcommands :command:`install_lib`, :command:`install_data` and :command:`install_scripts`."
msgstr ""

msgid ":command:`install_data`"
msgstr ""

msgid "This command installs all data files provided with the distribution."
msgstr ""

msgid ":command:`install_scripts`"
msgstr ""

msgid "This command installs all (Python) scripts in the distribution."
msgstr ""

msgid "Writing the Setup Configuration File"
msgstr ""

msgid "Often, it's not possible to write down everything needed to build a distribution *a priori*: you may need to get some information from the user, or from the user's system, in order to proceed.  As long as that information is fairly simple---a list of directories to search for C header files or libraries, for example---then providing a configuration file, :file:`setup.cfg`, for users to edit is a cheap and easy way to solicit it.  Configuration files also let you provide default values for any command option, which the installer can then override either on the command-line or by editing the config file."
msgstr ""

msgid "The setup configuration file is a useful middle-ground between the setup script ---which, ideally, would be opaque to installers [#]_---and the command-line to the setup script, which is outside of your control and entirely up to the installer.  In fact, :file:`setup.cfg` (and any other Distutils configuration files present on the target system) are processed after the contents of the setup script, but before the command-line.  This has  several useful consequences:"
msgstr ""

msgid "installers can override some of what you put in :file:`setup.py` by editing :file:`setup.cfg`"
msgstr ""

msgid "you can provide non-standard defaults for options that are not easily set in :file:`setup.py`"
msgstr ""

msgid "installers can override anything in :file:`setup.cfg` using the command-line options to :file:`setup.py`"
msgstr ""

msgid "The basic syntax of the configuration file is simple::"
msgstr ""

msgid "[command] option=value ..."
msgstr ""

msgid "where *command* is one of the Distutils commands (e.g. :command:`build_py`, :command:`install`), and *option* is one of the options that command supports. Any number of options can be supplied for each command, and any number of command sections can be included in the file.  Blank lines are ignored, as are comments, which run from a ``'#'`` character until the end of the line.  Long option values can be split across multiple lines simply by indenting the continuation lines."
msgstr ""

msgid "You can find out the list of options supported by a particular command with the universal :option:`--help` option, e.g. ::"
msgstr ""

msgid "> python setup.py --help build_ext [...] Options for 'build_ext' command:   --build-lib (-b)     directory for compiled extension modules   --build-temp (-t)    directory for temporary files (build by-products)   --inplace (-i)       ignore build-lib and put compiled extensions into the                        source directory alongside your pure Python modules   --include-dirs (-I)  list of directories to search for header files   --define (-D)        C preprocessor macros to define   --undef (-U)         C preprocessor macros to undefine   --swig-opts          list of SWIG command line options [...]"
msgstr ""

msgid "Note that an option spelled :option:`--foo-bar` on the command-line  is spelled :option:`foo_bar` in configuration files."
msgstr ""

msgid "For example, say you want your extensions to be built \"in-place\"---that is, you have an extension :mod:`pkg.ext`, and you want the compiled extension file (:file:`ext.so` on Unix, say) to be put in the same source directory as your pure Python modules :mod:`pkg.mod1` and :mod:`pkg.mod2`.  You can always use the :option:`--inplace` option on the command-line to ensure this::"
msgstr ""

msgid "python setup.py build_ext --inplace"
msgstr ""

msgid "But this requires that you always specify the :command:`build_ext` command explicitly, and remember to provide :option:`--inplace`. An easier way is to \"set and forget\" this option, by encoding it in :file:`setup.cfg`, the configuration file for this distribution::"
msgstr ""

msgid "[build_ext] inplace=1"
msgstr ""

msgid "This will affect all builds of this module distribution, whether or not you explicitly specify :command:`build_ext`.  If you include :file:`setup.cfg` in your source distribution, it will also affect end-user builds---which is probably a bad idea for this option, since always building extensions in-place would break installation of the module distribution.  In certain peculiar cases, though, modules are built right in their installation directory, so this is conceivably a useful ability.  (Distributing extensions that expect to be built in their installation directory is almost always a bad idea, though.)"
msgstr ""

msgid "Another example: certain commands take a lot of options that don't change from run to run; for example, :command:`bdist_rpm` needs to know everything required to generate a \"spec\" file for creating an RPM distribution.  Some of this information comes from the setup script, and some is automatically generated by the Distutils (such as the list of files installed).  But some of it has to be supplied as options to :command:`bdist_rpm`, which would be very tedious to do on the command-line for every run.  Hence, here is a snippet from the Distutils' own :file:`setup.cfg`::"
msgstr ""

msgid "[bdist_rpm] release = 1 packager = Greg Ward <gward@python.net> doc_files = CHANGES.txt             README.txt             USAGE.txt             doc/             examples/"
msgstr ""

msgid "Note that the :option:`doc_files` option is simply a whitespace-separated string split across multiple lines for readability."
msgstr ""

msgid "See also"
msgstr ""

msgid "More information on the configuration files is available in the manual for system administrators."
msgstr ""

msgid "Footnotes"
msgstr ""

msgid "This ideal probably won't be achieved until auto-configuration is fully supported by the Distutils."
msgstr ""

msgid "Examples"
msgstr ""

msgid "This chapter provides a number of basic examples to help get started with distutils.  Additional information about using distutils can be found in the Distutils Cookbook."
msgstr ""

msgid "Collection of recipes showing how to achieve more control over distutils."
msgstr ""

msgid "Pure Python distribution (by module)"
msgstr ""

msgid "If you're just distributing a couple of modules, especially if they don't live in a particular package, you can specify them individually using the :option:`py_modules` option in the setup script."
msgstr ""

msgid "In the simplest case, you'll have two files to worry about: a setup script and the single module you're distributing, :file:`foo.py` in this example::"
msgstr ""

msgid "<root>/         setup.py         foo.py"
msgstr ""

msgid "(In all diagrams in this section, *<root>* will refer to the distribution root directory.)  A minimal setup script to describe this situation would be::"
msgstr ""

msgid "from distutils.core import setup setup(name='foo',       version='1.0',       py_modules=['foo'],       )"
msgstr ""

msgid "Note that the name of the distribution is specified independently with the :option:`name` option, and there's no rule that says it has to be the same as the name of the sole module in the distribution (although that's probably a good convention to follow).  However, the distribution name is used to generate filenames, so you should stick to letters, digits, underscores, and hyphens."
msgstr ""

msgid "Since :option:`py_modules` is a list, you can of course specify multiple modules, eg. if you're distributing modules :mod:`foo` and :mod:`bar`, your setup might look like this::"
msgstr ""

msgid "<root>/         setup.py         foo.py         bar.py"
msgstr ""

msgid "and the setup script might be  ::"
msgstr ""

msgid "from distutils.core import setup setup(name='foobar',       version='1.0',       py_modules=['foo', 'bar'],       )"
msgstr ""

msgid "You can put module source files into another directory, but if you have enough modules to do that, it's probably easier to specify modules by package rather than listing them individually."
msgstr ""

msgid "Pure Python distribution (by package)"
msgstr ""

msgid "If you have more than a couple of modules to distribute, especially if they are in multiple packages, it's probably easier to specify whole packages rather than individual modules.  This works even if your modules are not in a package; you can just tell the Distutils to process modules from the root package, and that works the same as any other package (except that you don't have to have an :file:`__init__.py` file)."
msgstr ""

msgid "The setup script from the last example could also be written as  ::"
msgstr ""

msgid "from distutils.core import setup setup(name='foobar',       version='1.0',       packages=[''],       )"
msgstr ""

msgid "(The empty string stands for the root package.)"
msgstr ""

msgid "If those two files are moved into a subdirectory, but remain in the root package, e.g.::"
msgstr ""

msgid "<root>/         setup.py         src/      foo.py                   bar.py"
msgstr ""

msgid "then you would still specify the root package, but you have to tell the Distutils where source files in the root package live::"
msgstr ""

msgid "from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'': 'src'},       packages=[''],       )"
msgstr ""

msgid "More typically, though, you will want to distribute multiple modules in the same package (or in sub-packages).  For example, if the :mod:`foo`  and :mod:`bar` modules belong in package :mod:`foobar`, one way to layout your source tree is ::"
msgstr ""

msgid "<root>/         setup.py         foobar/                  __init__.py                  foo.py                  bar.py"
msgstr ""

msgid "This is in fact the default layout expected by the Distutils, and the one that requires the least work to describe in your setup script::"
msgstr ""

msgid "from distutils.core import setup setup(name='foobar',       version='1.0',       packages=['foobar'],       )"
msgstr ""

msgid "If you want to put modules in directories not named for their package, then you need to use the :option:`package_dir` option again.  For example, if the :file:`src` directory holds modules in the :mod:`foobar` package::"
msgstr ""

msgid "<root>/         setup.py         src/                  __init__.py                  foo.py                  bar.py"
msgstr ""

msgid "an appropriate setup script would be  ::"
msgstr ""

msgid "from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'foobar': 'src'},       packages=['foobar'],       )"
msgstr ""

msgid "Or, you might put modules from your main package right in the distribution root::"
msgstr ""

msgid "<root>/         setup.py         __init__.py         foo.py         bar.py"
msgstr ""

msgid "in which case your setup script would be  ::"
msgstr ""

msgid "from distutils.core import setup setup(name='foobar',       version='1.0',       package_dir={'foobar': ''},       packages=['foobar'],       )"
msgstr ""

msgid "(The empty string also stands for the current directory.)"
msgstr ""

msgid "If you have sub-packages, they must be explicitly listed in :option:`packages`, but any entries in :option:`package_dir` automatically extend to sub-packages. (In other words, the Distutils does *not* scan your source tree, trying to figure out which directories correspond to Python packages by looking for :file:`__init__.py` files.)  Thus, if the default layout grows a sub-package::"
msgstr ""

msgid "<root>/         setup.py         foobar/                  __init__.py                  foo.py                  bar.py                  subfoo/                            __init__.py                            blah.py"
msgstr ""

msgid "then the corresponding setup script would be  ::"
msgstr ""

msgid "from distutils.core import setup setup(name='foobar',       version='1.0',       packages=['foobar', 'foobar.subfoo'],       )"
msgstr ""

msgid "(Again, the empty string in :option:`package_dir` stands for the current directory.)"
msgstr ""

msgid "Single extension module"
msgstr ""

msgid "Extension modules are specified using the :option:`ext_modules` option. :option:`package_dir` has no effect on where extension source files are found; it only affects the source for pure Python modules.  The simplest  case, a single extension module in a single C source file, is::"
msgstr ""

msgid "<root>/         setup.py         foo.c"
msgstr ""

msgid "If the :mod:`foo` extension belongs in the root package, the setup script for this could be  ::"
msgstr ""

msgid "from distutils.core import setup from distutils.extension import Extension setup(name='foobar',       version='1.0',       ext_modules=[Extension('foo', ['foo.c'])],       )"
msgstr ""

msgid "If the extension actually belongs in a package, say :mod:`foopkg`, then"
msgstr ""

msgid "With exactly the same source tree layout, this extension can be put in the :mod:`foopkg` package simply by changing the name of the extension::"
msgstr ""

msgid "from distutils.core import setup from distutils.extension import Extension setup(name='foobar',       version='1.0',       ext_modules=[Extension('foopkg.foo', ['foo.c'])],       )"
msgstr ""

msgid "Extending Distutils"
msgstr ""

msgid "Distutils can be extended in various ways.  Most extensions take the form of new commands or replacements for existing commands.  New commands may be written to support new types of platform-specific packaging, for example, while replacements for existing commands may be made to modify details of how the command operates on a package."
msgstr ""

msgid "Most extensions of the distutils are made within :file:`setup.py` scripts that want to modify existing commands; many simply add a few file extensions that should be copied into packages in addition to :file:`.py` files as a convenience."
msgstr ""

msgid "Most distutils command implementations are subclasses of the :class:`Command` class from :mod:`distutils.cmd`.  New commands may directly inherit from :class:`Command`, while replacements often derive from :class:`Command` indirectly, directly subclassing the command they are replacing.  Commands are required to derive from :class:`Command`."
msgstr ""

msgid "Integrating new commands"
msgstr ""

msgid "There are different ways to integrate new command implementations into distutils.  The most difficult is to lobby for the inclusion of the new features in distutils itself, and wait for (and require) a version of Python that provides that support.  This is really hard for many reasons."
msgstr ""

msgid "The most common, and possibly the most reasonable for most needs, is to include the new implementations with your :file:`setup.py` script, and cause the :func:`distutils.core.setup` function use them::"
msgstr ""

msgid "from distutils.command.build_py import build_py as _build_py from distutils.core import setup  class build_py(_build_py):     \"\"\"Specialized Python source builder.\"\"\"      # implement whatever needs to be different...  setup(cmdclass={'build_py': build_py},       ...)"
msgstr ""

msgid "This approach is most valuable if the new implementations must be used to use a particular package, as everyone interested in the package will need to have the new command implementation."
msgstr ""

msgid "Beginning with Python 2.4, a third option is available, intended to allow new commands to be added which can support existing :file:`setup.py` scripts without requiring modifications to the Python installation.  This is expected to allow third-party extensions to provide support for additional packaging systems, but the commands can be used for anything distutils commands can be used for.  A new configuration option, :option:`command_packages` (command-line option :option:`--command-packages`), can be used to specify additional packages to be searched for modules implementing commands.  Like all distutils options, this can be specified on the command line or in a configuration file.  This option can only be set in the ``[global]`` section of a configuration file, or before any commands on the command line.  If set in a configuration file, it can be overridden from the command line; setting it to an empty string on the command line causes the default to be used.  This should never be set in a configuration file provided with a package."
msgstr ""

msgid "This new option can be used to add any number of packages to the list of packages searched for command implementations; multiple package names should be separated by commas.  When not specified, the search is only performed in the :mod:`distutils.command` package.  When :file:`setup.py` is run with the option :option:`--command-packages` :option:`distcmds,buildcmds`, however, the packages :mod:`distutils.command`, :mod:`distcmds`, and :mod:`buildcmds` will be searched in that order.  New commands are expected to be implemented in modules of the same name as the command by classes sharing the same name.  Given the example command line option above, the command :command:`bdist_openpkg` could be implemented by the class :class:`distcmds.bdist_openpkg.bdist_openpkg` or :class:`buildcmds.bdist_openpkg.bdist_openpkg`."
msgstr ""

msgid "Adding new distribution types"
msgstr ""

msgid "Commands that create distributions (files in the :file:`dist/` directory) need to add ``(command, filename)`` pairs to ``self.distribution.dist_files`` so that :command:`upload` can upload it to PyPI.  The *filename* in the pair contains no path information, only the name of the file itself.  In dry-run mode, pairs should still be added to represent what would have been created."
msgstr ""

msgid "Distributing Python Modules"
msgstr ""

msgid "Authors"
msgstr ""

msgid "Greg Ward, Anthony Baxter"
msgstr ""

msgid "Email"
msgstr ""

msgid "distutils-sig@python.org"
msgstr ""

msgid "|version|"
msgstr ""

msgid "Date"
msgstr ""

msgid "|today|"
msgstr ""

msgid "This document describes the Python Distribution Utilities (\"Distutils\") from the module developer's point of view, describing how to use the Distutils to make Python modules and extensions easily available to a wider audience with very little overhead for build/release/install mechanics."
msgstr ""

msgid "An Introduction to Distutils"
msgstr ""

msgid "This document covers using the Distutils to distribute your Python modules, concentrating on the role of developer/distributor: if you're looking for information on installing Python modules, you should refer to the :ref:`install-index` chapter."
msgstr ""

msgid "Concepts & Terminology"
msgstr ""

msgid "Using the Distutils is quite simple, both for module developers and for users/administrators installing third-party modules.  As a developer, your responsibilities (apart from writing solid, well-documented and well-tested code, of course!) are:"
msgstr ""

msgid "write a setup script (:file:`setup.py` by convention)"
msgstr ""

msgid "(optional) write a setup configuration file"
msgstr ""

msgid "create a source distribution"
msgstr ""

msgid "(optional) create one or more built (binary) distributions"
msgstr ""

msgid "Each of these tasks is covered in this document."
msgstr ""

msgid "Not all module developers have access to a multitude of platforms, so it's not always feasible to expect them to create a multitude of built distributions.  It is hoped that a class of intermediaries, called *packagers*, will arise to address this need.  Packagers will take source distributions released by module developers, build them on one or more platforms, and release the resulting built distributions.  Thus, users on the most popular platforms will be able to install most popular Python module distributions in the most natural way for their platform, without having to run a single setup script or compile a line of code."
msgstr ""

msgid "A Simple Example"
msgstr ""

msgid "The setup script is usually quite simple, although since it's written in Python, there are no arbitrary limits to what you can do with it, though you should be careful about putting arbitrarily expensive operations in your setup script. Unlike, say, Autoconf-style configure scripts, the setup script may be run multiple times in the course of building and installing your module distribution."
msgstr ""

msgid "If all you want to do is distribute a module called :mod:`foo`, contained in a file :file:`foo.py`, then your setup script can be as simple as this::"
msgstr ""

msgid "Some observations:"
msgstr ""

msgid "most information that you supply to the Distutils is supplied as keyword arguments to the :func:`setup` function"
msgstr ""

msgid "those keyword arguments fall into two categories: package metadata (name, version number) and information about what's in the package (a list of pure Python modules, in this case)"
msgstr ""

msgid "modules are specified by module name, not filename (the same will hold true for packages and extensions)"
msgstr ""

msgid "it's recommended that you supply a little more metadata, in particular your name, email address and a URL for the project (see section :ref:`setup-script` for an example)"
msgstr ""

msgid "To create a source distribution for this module, you would create a setup script, :file:`setup.py`, containing the above code, and run::"
msgstr ""

msgid "python setup.py sdist"
msgstr ""

msgid "which will create an archive file (e.g., tarball on Unix, ZIP file on Windows) containing your setup script :file:`setup.py`, and your module :file:`foo.py`. The archive file will be named :file:`foo-1.0.tar.gz` (or :file:`.zip`), and will unpack into a directory :file:`foo-1.0`."
msgstr ""

msgid "If an end-user wishes to install your :mod:`foo` module, all she has to do is download :file:`foo-1.0.tar.gz` (or :file:`.zip`), unpack it, and---from the :file:`foo-1.0` directory---run ::"
msgstr ""

msgid "python setup.py install"
msgstr ""

msgid "which will ultimately copy :file:`foo.py` to the appropriate directory for third-party modules in their Python installation."
msgstr ""

msgid "This simple example demonstrates some fundamental concepts of the Distutils. First, both developers and installers have the same basic user interface, i.e. the setup script.  The difference is which Distutils *commands* they use: the :command:`sdist` command is almost exclusively for module developers, while :command:`install` is more often for installers (although most developers will want to install their own code occasionally)."
msgstr ""

msgid "If you want to make things really easy for your users, you can create one or more built distributions for them.  For instance, if you are running on a Windows machine, and want to make things easy for other Windows users, you can create an executable installer (the most appropriate type of built distribution for this platform) with the :command:`bdist_wininst` command.  For example::"
msgstr ""

msgid "will create an executable installer, :file:`foo-1.0.win32.exe`, in the current directory."
msgstr ""

msgid "Other useful built distribution formats are RPM, implemented by the :command:`bdist_rpm` command, Solaris :program:`pkgtool` (:command:`bdist_pkgtool`), and HP-UX :program:`swinstall` (:command:`bdist_sdux`).  For example, the following command will create an RPM file called :file:`foo-1.0.noarch.rpm`::"
msgstr ""

msgid "(The :command:`bdist_rpm` command uses the :command:`rpm` executable, therefore this has to be run on an RPM-based system such as Red Hat Linux, SuSE Linux, or Mandrake Linux.)"
msgstr ""

msgid "You can find out what distribution formats are available at any time by running ::"
msgstr ""

msgid "python setup.py bdist --help-formats"
msgstr ""

msgid "General Python terminology"
msgstr ""

msgid "If you're reading this document, you probably have a good idea of what modules, extensions, and so forth are.  Nevertheless, just to be sure that everyone is operating from a common starting point, we offer the following glossary of common Python terms:"
msgstr ""

msgid "the basic unit of code reusability in Python: a block of code imported by some other code.  Three types of modules concern us here: pure Python modules, extension modules, and packages."
msgstr ""

msgid "a module written in Python and contained in a single :file:`.py` file (and possibly associated :file:`.pyc` and/or :file:`.pyo` files).  Sometimes referred to as a \"pure module.\""
msgstr ""

msgid "a module written in the low-level language of the Python implementation: C/C++ for Python, Java for Jython. Typically contained in a single dynamically loadable pre-compiled file, e.g. a shared object (:file:`.so`) file for Python extensions on Unix, a DLL (given the :file:`.pyd` extension) for Python extensions on Windows, or a Java class file for Jython extensions.  (Note that currently, the Distutils only handles C/C++ extensions for Python.)"
msgstr ""

msgid "a module that contains other modules; typically contained in a directory in the filesystem and distinguished from other directories by the presence of a file :file:`__init__.py`."
msgstr ""

msgid "the root of the hierarchy of packages.  (This isn't really a package, since it doesn't have an :file:`__init__.py` file.  But we have to call it something.) The vast majority of the standard library is in the root package, as are many small, standalone third-party modules that don't belong to a larger module collection. Unlike regular packages, modules in the root package can be found in many directories: in fact, every directory listed in ``sys.path`` contributes modules to the root package."
msgstr ""

msgid "Distutils-specific terminology"
msgstr ""

msgid "The following terms apply more specifically to the domain of distributing Python modules using the Distutils:"
msgstr ""

msgid "a collection of Python modules distributed together as a single downloadable resource and meant to be installed *en masse*.  Examples of some well-known module distributions are Numeric Python, PyXML, PIL (the Python Imaging Library), or mxBase.  (This would be called a *package*, except that term is already taken in the Python context: a single module distribution may contain zero, one, or many Python packages.)"
msgstr ""

msgid "a module distribution that contains only pure Python modules and packages. Sometimes referred to as a \"pure distribution.\""
msgstr ""

msgid "a module distribution that contains at least one extension module.  Sometimes referred to as a \"non-pure distribution.\""
msgstr ""

msgid "the top-level directory of your source tree (or  source distribution); the directory where :file:`setup.py` exists.  Generally  :file:`setup.py` will be run from this directory."
msgstr ""

msgid "Registering with the Package Index"
msgstr ""

msgid "The Python Package Index (PyPI) holds meta-data describing distributions packaged with distutils. The distutils command :command:`register` is used to submit your distribution's meta-data to the index. It is invoked as follows::"
msgstr ""

msgid "python setup.py register"
msgstr ""

msgid "Distutils will respond with the following prompt::"
msgstr ""

msgid "running register We need to know who you are, so please choose either:     1. use your existing login,     2. register as a new user,     3. have the server generate a new password for you (and email it to you), or     4. quit Your selection [default 1]:"
msgstr ""

msgid "Note: if your username and password are saved locally, you will not see this menu."
msgstr ""

msgid "If you have not registered with PyPI, then you will need to do so now. You should choose option 2, and enter your details as required. Soon after submitting your details, you will receive an email which will be used to confirm your registration."
msgstr ""

msgid "Once you are registered, you may choose option 1 from the menu. You will be prompted for your PyPI username and password, and :command:`register` will then submit your meta-data to the index."
msgstr ""

msgid "You may submit any number of versions of your distribution to the index. If you alter the meta-data for a particular version, you may submit it again and the index will be updated."
msgstr ""

msgid "PyPI holds a record for each (name, version) combination submitted. The first user to submit information for a given name is designated the Owner of that name. They may submit changes through the :command:`register` command or through the web interface. They may also designate other users as Owners or Maintainers. Maintainers may edit the package information, but not designate other Owners or Maintainers."
msgstr ""

msgid "By default PyPI will list all versions of a given package. To hide certain versions, the Hidden property should be set to yes. This must be edited through the web interface."
msgstr ""

msgid "The .pypirc file"
msgstr ""

msgid "The format of the :file:`.pypirc` file is as follows::"
msgstr ""

msgid "[distutils] index-servers =     pypi  [pypi] repository: <repository-url> username: <username> password: <password>"
msgstr ""

msgid "The *distutils* section defines a *index-servers* variable that lists the name of all sections describing a repository."
msgstr ""

msgid "Each section describing a repository defines three variables:"
msgstr ""

msgid "``http://www.python.org/pypi``."
msgstr ""

msgid "*username*, which is the registered username on the PyPI server."
msgstr ""

msgid "will be prompt to type it when needed."
msgstr ""

msgid "If you want to define another server a new section can be created and listed in the *index-servers* variable::"
msgstr ""

msgid "[distutils] index-servers =     pypi     other  [pypi] repository: <repository-url> username: <username> password: <password>  [other] repository: http://example.com/pypi username: <username> password: <password>"
msgstr ""

msgid ":command:`register` can then be called with the -r option to point the repository to work with::"
msgstr ""

msgid "python setup.py register -r http://example.com/pypi"
msgstr ""

msgid "For convenience, the name of the section that describes the repository may also be used::"
msgstr ""

msgid "python setup.py register -r other"
msgstr ""

msgid "Writing the Setup Script"
msgstr ""

msgid "The setup script is the centre of all activity in building, distributing, and installing modules using the Distutils.  The main purpose of the setup script is to describe your module distribution to the Distutils, so that the various commands that operate on your modules do the right thing.  As we saw in section :ref:`distutils-simple-example` above, the setup script consists mainly of a call to :func:`setup`, and most information supplied to the Distutils by the module developer is supplied as keyword arguments to :func:`setup`."
msgstr ""

msgid "Here's a slightly more involved example, which we'll follow for the next couple of sections: the Distutils' own setup script.  (Keep in mind that although the Distutils are included with Python 1.6 and later, they also have an independent existence so that Python 1.5.2 users can use them to install other module distributions.  The Distutils' own setup script, shown here, is used to install the package into Python 1.5.2.) ::"
msgstr ""

msgid "#!/usr/bin/env python  from distutils.core import setup  setup(name='Distutils',       version='1.0',       description='Python Distribution Utilities',       author='Greg Ward',       author_email='gward@python.net',       url='http://www.python.org/sigs/distutils-sig/',       packages=['distutils', 'distutils.command'],      )"
msgstr ""

msgid "There are only two differences between this and the trivial one-file distribution presented in section :ref:`distutils-simple-example`: more metadata, and the specification of pure Python modules by package, rather than by module.  This is important since the Distutils consist of a couple of dozen modules split into (so far) two packages; an explicit list of every module would be tedious to generate and difficult to maintain.  For more information on the additional meta-data, see section :ref:`meta-data`."
msgstr ""

msgid "Note that any pathnames (files or directories) supplied in the setup script should be written using the Unix convention, i.e. slash-separated.  The Distutils will take care of converting this platform-neutral representation into whatever is appropriate on your current platform before actually using the pathname.  This makes your setup script portable across operating systems, which of course is one of the major goals of the Distutils.  In this spirit, all pathnames in this document are slash-separated."
msgstr ""

msgid "This, of course, only applies to pathnames given to Distutils functions.  If you, for example, use standard Python functions such as :func:`glob.glob` or :func:`os.listdir` to specify files, you should be careful to write portable code instead of hardcoding path separators::"
msgstr ""

msgid "glob.glob(os.path.join('mydir', 'subdir', '*.html')) os.listdir(os.path.join('mydir', 'subdir'))"
msgstr ""

msgid "Listing whole packages"
msgstr ""

msgid "The :option:`packages` option tells the Distutils to process (build, distribute, install, etc.) all pure Python modules found in each package mentioned in the :option:`packages` list.  In order to do this, of course, there has to be a correspondence between package names and directories in the filesystem.  The default correspondence is the most obvious one, i.e. package :mod:`distutils` is found in the directory :file:`distutils` relative to the distribution root. Thus, when you say ``packages = ['foo']`` in your setup script, you are promising that the Distutils will find a file :file:`foo/__init__.py` (which might be spelled differently on your system, but you get the idea) relative to the directory where your setup script lives.  If you break this promise, the Distutils will issue a warning but still process the broken package anyways."
msgstr ""

msgid "If you use a different convention to lay out your source directory, that's no problem: you just have to supply the :option:`package_dir` option to tell the Distutils about your convention.  For example, say you keep all Python source under :file:`lib`, so that modules in the \"root package\" (i.e., not in any package at all) are in :file:`lib`, modules in the :mod:`foo` package are in :file:`lib/foo`, and so forth.  Then you would put ::"
msgstr ""

msgid "package_dir = {'': 'lib'}"
msgstr ""

msgid "in your setup script.  The keys to this dictionary are package names, and an empty package name stands for the root package.  The values are directory names relative to your distribution root.  In this case, when you say ``packages = ['foo']``, you are promising that the file :file:`lib/foo/__init__.py` exists."
msgstr ""

msgid "Another possible convention is to put the :mod:`foo` package right in :file:`lib`, the :mod:`foo.bar` package in :file:`lib/bar`, etc.  This would be written in the setup script as ::"
msgstr ""

msgid "package_dir = {'foo': 'lib'}"
msgstr ""

msgid "A ``package: dir`` entry in the :option:`package_dir` dictionary implicitly applies to all packages below *package*, so the :mod:`foo.bar` case is automatically handled here.  In this example, having ``packages = ['foo', 'foo.bar']`` tells the Distutils to look for :file:`lib/__init__.py` and :file:`lib/bar/__init__.py`.  (Keep in mind that although :option:`package_dir` applies recursively, you must explicitly list all packages in :option:`packages`: the Distutils will *not* recursively scan your source tree looking for any directory with an :file:`__init__.py` file.)"
msgstr ""

msgid "Listing individual modules"
msgstr ""

msgid "For a small module distribution, you might prefer to list all modules rather than listing packages---especially the case of a single module that goes in the \"root package\" (i.e., no package at all).  This simplest case was shown in section :ref:`distutils-simple-example`; here is a slightly more involved example::"
msgstr ""

msgid "py_modules = ['mod1', 'pkg.mod2']"
msgstr ""

msgid "This describes two modules, one of them in the \"root\" package, the other in the :mod:`pkg` package.  Again, the default package/directory layout implies that these two modules can be found in :file:`mod1.py` and :file:`pkg/mod2.py`, and that :file:`pkg/__init__.py` exists as well. And again, you can override the package/directory correspondence using the :option:`package_dir` option."
msgstr ""

msgid "Describing extension modules"
msgstr ""

msgid "Just as writing Python extension modules is a bit more complicated than writing pure Python modules, describing them to the Distutils is a bit more complicated. Unlike pure modules, it's not enough just to list modules or packages and expect the Distutils to go out and find the right files; you have to specify the extension name, source file(s), and any compile/link requirements (include directories, libraries to link with, etc.)."
msgstr ""

msgid "All of this is done through another keyword argument to :func:`setup`, the :option:`ext_modules` option.  :option:`ext_modules` is just a list of :class:`Extension` instances, each of which describes a single extension module. Suppose your distribution includes a single extension, called :mod:`foo` and implemented by :file:`foo.c`.  If no additional instructions to the compiler/linker are needed, describing this extension is quite simple::"
msgstr ""

msgid "Extension('foo', ['foo.c'])"
msgstr ""

msgid "The :class:`Extension` class can be imported from :mod:`distutils.core` along with :func:`setup`.  Thus, the setup script for a module distribution that contains only this one extension and nothing else might be::"
msgstr ""

msgid "from distutils.core import setup, Extension setup(name='foo',       version='1.0',       ext_modules=[Extension('foo', ['foo.c'])],       )"
msgstr ""

msgid "The :class:`Extension` class (actually, the underlying extension-building machinery implemented by the :command:`build_ext` command) supports a great deal of flexibility in describing Python extensions, which is explained in the following sections."
msgstr ""

msgid "Extension names and packages"
msgstr ""

msgid "The first argument to the :class:`Extension` constructor is always the name of the extension, including any package names.  For example, ::"
msgstr ""

msgid "Extension('foo', ['src/foo1.c', 'src/foo2.c'])"
msgstr ""

msgid "describes an extension that lives in the root package, while ::"
msgstr ""

msgid "Extension('pkg.foo', ['src/foo1.c', 'src/foo2.c'])"
msgstr ""

msgid "describes the same extension in the :mod:`pkg` package.  The source files and resulting object code are identical in both cases; the only difference is where in the filesystem (and therefore where in Python's namespace hierarchy) the resulting extension lives."
msgstr ""

msgid "If you have a number of extensions all in the same package (or all under the same base package), use the :option:`ext_package` keyword argument to :func:`setup`.  For example, ::"
msgstr ""

msgid "setup(...,       ext_package='pkg',       ext_modules=[Extension('foo', ['foo.c']),                    Extension('subpkg.bar', ['bar.c'])],      )"
msgstr ""

msgid "will compile :file:`foo.c` to the extension :mod:`pkg.foo`, and :file:`bar.c` to :mod:`pkg.subpkg.bar`."
msgstr ""

msgid "Extension source files"
msgstr ""

msgid "The second argument to the :class:`Extension` constructor is a list of source files.  Since the Distutils currently only support C, C++, and Objective-C extensions, these are normally C/C++/Objective-C source files.  (Be sure to use appropriate extensions to distinguish C++\\ source files: :file:`.cc` and :file:`.cpp` seem to be recognized by both Unix and Windows compilers.)"
msgstr ""

msgid "However, you can also include SWIG interface (:file:`.i`) files in the list; the :command:`build_ext` command knows how to deal with SWIG extensions: it will run SWIG on the interface file and compile the resulting C/C++ file into your extension."
msgstr ""

msgid "**\\*\\*** SWIG support is rough around the edges and largely untested! **\\*\\***"
msgstr ""

msgid "This warning notwithstanding, options to SWIG can be currently passed like this::"
msgstr ""

msgid "setup(...,       ext_modules=[Extension('_foo', ['foo.i'],                              swig_opts=['-modern', '-I../include'])],       py_modules=['foo'],      )"
msgstr ""

msgid "Or on the commandline like this::"
msgstr ""

msgid "> python setup.py build_ext --swig-opts=\"-modern -I../include\""
msgstr ""

msgid "On some platforms, you can include non-source files that are processed by the compiler and included in your extension.  Currently, this just means Windows message text (:file:`.mc`) files and resource definition (:file:`.rc`) files for Visual C++. These will be compiled to binary resource (:file:`.res`) files and linked into the executable."
msgstr ""

msgid "Preprocessor options"
msgstr ""

msgid "Three optional arguments to :class:`Extension` will help if you need to specify include directories to search or preprocessor macros to define/undefine: ``include_dirs``, ``define_macros``, and ``undef_macros``."
msgstr ""

msgid "For example, if your extension requires header files in the :file:`include` directory under your distribution root, use the ``include_dirs`` option::"
msgstr ""

msgid "Extension('foo', ['foo.c'], include_dirs=['include'])"
msgstr ""

msgid "You can specify absolute directories there; if you know that your extension will only be built on Unix systems with X11R6 installed to :file:`/usr`, you can get away with ::"
msgstr ""

msgid "Extension('foo', ['foo.c'], include_dirs=['/usr/include/X11'])"
msgstr ""

msgid "You should avoid this sort of non-portable usage if you plan to distribute your code: it's probably better to write C code like  ::"
msgstr ""

msgid "#include <X11/Xlib.h>"
msgstr ""

msgid "If you need to include header files from some other Python extension, you can take advantage of the fact that header files are installed in a consistent way by the Distutils :command:`install_header` command.  For example, the Numerical Python header files are installed (on a standard Unix installation) to :file:`/usr/local/include/python1.5/Numerical`. (The exact location will differ according to your platform and Python installation.)  Since the Python include directory---\\ :file:`/usr/local/include/python1.5` in this case---is always included in the search path when building Python extensions, the best approach is to write C code like  ::"
msgstr ""

msgid "#include <Numerical/arrayobject.h>"
msgstr ""

msgid "If you must put the :file:`Numerical` include directory right into your header search path, though, you can find that directory using the Distutils :mod:`distutils.sysconfig` module::"
msgstr ""

msgid "from distutils.sysconfig import get_python_inc incdir = os.path.join(get_python_inc(plat_specific=1), 'Numerical') setup(...,       Extension(..., include_dirs=[incdir]),       )"
msgstr ""

msgid "Even though this is quite portable---it will work on any Python installation, regardless of platform---it's probably easier to just write your C code in the sensible way."
msgstr ""

msgid "You can define and undefine pre-processor macros with the ``define_macros`` and ``undef_macros`` options. ``define_macros`` takes a list of ``(name, value)`` tuples, where ``name`` is the name of the macro to define (a string) and ``value`` is its value: either a string or ``None``.  (Defining a macro ``FOO`` to ``None`` is the equivalent of a bare ``#define FOO`` in your C source: with most compilers, this sets ``FOO`` to the string ``1``.)  ``undef_macros`` is just a list of macros to undefine."
msgstr ""

msgid "For example::"
msgstr ""

msgid "Extension(...,           define_macros=[('NDEBUG', '1'),                          ('HAVE_STRFTIME', None)],           undef_macros=['HAVE_FOO', 'HAVE_BAR'])"
msgstr ""

msgid "is the equivalent of having this at the top of every C source file::"
msgstr ""

msgid "#define NDEBUG 1 #define HAVE_STRFTIME #undef HAVE_FOO #undef HAVE_BAR"
msgstr ""

msgid "Library options"
msgstr ""

msgid "You can also specify the libraries to link against when building your extension, and the directories to search for those libraries.  The ``libraries`` option is a list of libraries to link against, ``library_dirs`` is a list of directories to search for libraries at  link-time, and ``runtime_library_dirs`` is a list of directories to  search for shared (dynamically loaded) libraries at run-time."
msgstr ""

msgid "For example, if you need to link against libraries known to be in the standard library search path on target systems ::"
msgstr ""

msgid "Extension(...,           libraries=['gdbm', 'readline'])"
msgstr ""

msgid "If you need to link with libraries in a non-standard location, you'll have to include the location in ``library_dirs``::"
msgstr ""

msgid "Extension(...,           library_dirs=['/usr/X11R6/lib'],           libraries=['X11', 'Xt'])"
msgstr ""

msgid "(Again, this sort of non-portable construct should be avoided if you intend to distribute your code.)"
msgstr ""

msgid "**\\*\\*** Should mention clib libraries here or somewhere else! **\\*\\***"
msgstr ""

msgid "Other options"
msgstr ""

msgid "There are still some other options which can be used to handle special cases."
msgstr ""

msgid "The :option:`optional` option is a boolean; if it is true, a build failure in the extension will not abort the build process, but instead simply not install the failing extension."
msgstr ""

msgid "The :option:`extra_objects` option is a list of object files to be passed to the linker. These files must not have extensions, as the default extension for the compiler is used."
msgstr ""

msgid ":option:`extra_compile_args` and :option:`extra_link_args` can be used to specify additional command line options for the respective compiler and linker command lines."
msgstr ""

msgid ":option:`export_symbols` is only useful on Windows.  It can contain a list of symbols (functions or variables) to be exported. This option is not needed when building compiled extensions: Distutils  will automatically add ``initmodule`` to the list of exported symbols."
msgstr ""

msgid "The :option:`depends` option is a list of files that the extension depends on (for example header files). The build command will call the compiler on the sources to rebuild extension if any on this files has been modified since the previous build."
msgstr ""

msgid "Relationships between Distributions and Packages"
msgstr ""

msgid "A distribution may relate to packages in three specific ways:"
msgstr ""

msgid "It can require packages or modules."
msgstr ""

msgid "It can provide packages or modules."
msgstr ""

msgid "It can obsolete packages or modules."
msgstr ""

msgid "These relationships can be specified using keyword arguments to the :func:`distutils.core.setup` function."
msgstr ""

msgid "Dependencies on other Python modules and packages can be specified by supplying the *requires* keyword argument to :func:`setup`. The value must be a list of strings.  Each string specifies a package that is required, and optionally what versions are sufficient."
msgstr ""

msgid "To specify that any version of a module or package is required, the string should consist entirely of the module or package name. Examples include ``'mymodule'`` and ``'xml.parsers.expat'``."
msgstr ""

msgid "If specific versions are required, a sequence of qualifiers can be supplied in parentheses.  Each qualifier may consist of a comparison operator and a version number.  The accepted comparison operators are::"
msgstr ""

msgid "<    >    == <=   >=   !="
msgstr ""

msgid "These can be combined by using multiple qualifiers separated by commas (and optional whitespace).  In this case, all of the qualifiers must be matched; a logical AND is used to combine the evaluations."
msgstr ""

msgid "Let's look at a bunch of examples:"
msgstr ""

msgid "Requires Expression"
msgstr ""

msgid "Explanation"
msgstr ""

msgid "``==1.0``"
msgstr ""

msgid "Only version ``1.0`` is compatible"
msgstr ""

msgid "``>1.0, !=1.5.1, <2.0``"
msgstr ""

msgid "Any version after ``1.0`` and before ``2.0`` is compatible, except ``1.5.1``"
msgstr ""

msgid "Now that we can specify dependencies, we also need to be able to specify what we provide that other distributions can require.  This is done using the *provides* keyword argument to :func:`setup`. The value for this keyword is a list of strings, each of which names a Python module or package, and optionally identifies the version.  If the version is not specified, it is assumed to match that of the distribution."
msgstr ""

msgid "Some examples:"
msgstr ""

msgid "Provides Expression"
msgstr ""

msgid "``mypkg``"
msgstr ""

msgid "Provide ``mypkg``, using the distribution version"
msgstr ""

msgid "``mypkg (1.1)``"
msgstr ""

msgid "Provide ``mypkg`` version 1.1, regardless of the distribution version"
msgstr ""

msgid "A package can declare that it obsoletes other packages using the *obsoletes* keyword argument.  The value for this is similar to that of the *requires* keyword: a list of strings giving module or package specifiers.  Each specifier consists of a module or package name optionally followed by one or more version qualifiers.  Version qualifiers are given in parentheses after the module or package name."
msgstr ""

msgid "The versions identified by the qualifiers are those that are obsoleted by the distribution being described.  If no qualifiers are given, all versions of the named module or package are understood to be obsoleted."
msgstr ""

msgid "Installing Scripts"
msgstr ""

msgid "So far we have been dealing with pure and non-pure Python modules, which are usually not run by themselves but imported by scripts."
msgstr ""

msgid "Scripts are files containing Python source code, intended to be started from the command line.  Scripts don't require Distutils to do anything very complicated. The only clever feature is that if the first line of the script starts with ``#!`` and contains the word \"python\", the Distutils will adjust the first line to refer to the current interpreter location. By default, it is replaced with the current interpreter location.  The :option:`--executable` (or :option:`-e`) option will allow the interpreter path to be explicitly overridden."
msgstr ""

msgid "The :option:`scripts` option simply is a list of files to be handled in this way.  From the PyXML setup script::"
msgstr ""

msgid "setup(...,       scripts=['scripts/xmlproc_parse', 'scripts/xmlproc_val']       )"
msgstr ""

msgid "Installing Package Data"
msgstr ""

msgid "Often, additional files need to be installed into a package.  These files are often data that's closely related to the package's implementation, or text files containing documentation that might be of interest to programmers using the package.  These files are called :dfn:`package data`."
msgstr ""

msgid "Package data can be added to packages using the ``package_data`` keyword argument to the :func:`setup` function.  The value must be a mapping from package name to a list of relative path names that should be copied into the package.  The paths are interpreted as relative to the directory containing the package (information from the ``package_dir`` mapping is used if appropriate); that is, the files are expected to be part of the package in the source directories. They may contain glob patterns as well."
msgstr ""

msgid "The path names may contain directory portions; any necessary directories will be created in the installation."
msgstr ""

msgid "For example, if a package should contain a subdirectory with several data files, the files can be arranged like this in the source tree::"
msgstr ""

msgid "setup.py src/     mypkg/         __init__.py         module.py         data/             tables.dat             spoons.dat             forks.dat"
msgstr ""

msgid "The corresponding call to :func:`setup` might be::"
msgstr ""

msgid "setup(...,       packages=['mypkg'],       package_dir={'mypkg': 'src/mypkg'},       package_data={'mypkg': ['data/*.dat']},       )"
msgstr ""

msgid "Installing Additional Files"
msgstr ""

msgid "The :option:`data_files` option can be used to specify additional files needed by the module distribution: configuration files, message catalogs, data files, anything which doesn't fit in the previous categories."
msgstr ""

msgid ":option:`data_files` specifies a sequence of (*directory*, *files*) pairs in the following way::"
msgstr ""

msgid "setup(...,       data_files=[('bitmaps', ['bm/b1.gif', 'bm/b2.gif']),                   ('config', ['cfg/data.cfg']),                   ('/etc/init.d', ['init-script'])]      )"
msgstr ""

msgid "Note that you can specify the directory names where the data files will be installed, but you cannot rename the data files themselves."
msgstr ""

msgid "Each (*directory*, *files*) pair in the sequence specifies the installation directory and the files to install there.  If *directory* is a relative path, it is interpreted relative to the installation prefix (Python's ``sys.prefix`` for pure-Python packages, ``sys.exec_prefix`` for packages that contain extension modules).  Each file name in *files* is interpreted relative to the :file:`setup.py` script at the top of the package source distribution.  No directory information from *files* is used to determine the final location of the installed file; only the name of the file is used."
msgstr ""

msgid "You can specify the :option:`data_files` options as a simple sequence of files without specifying a target directory, but this is not recommended, and the :command:`install` command will print a warning in this case. To install data files directly in the target directory, an empty string should be given as the directory."
msgstr ""

msgid "Additional meta-data"
msgstr ""

msgid "The setup script may include additional meta-data beyond the name and version. This information includes:"
msgstr ""

msgid "Meta-Data"
msgstr ""

msgid "Value"
msgstr ""

msgid "``name``"
msgstr ""

msgid "name of the package"
msgstr ""

msgid "short string"
msgstr ""

msgid "\\(1)"
msgstr ""

msgid "``version``"
msgstr ""

msgid "version of this release"
msgstr ""

msgid "(1)(2)"
msgstr ""

msgid "``author``"
msgstr ""

msgid "package author's name"
msgstr ""

msgid "``author_email``"
msgstr ""

msgid "email address of the package author"
msgstr ""

msgid "email address"
msgstr ""

msgid "``maintainer``"
msgstr ""

msgid "package maintainer's name"
msgstr ""

msgid "``maintainer_email``"
msgstr ""

msgid "email address of the package maintainer"
msgstr ""

msgid "``url``"
msgstr ""

msgid "home page for the package"
msgstr ""

msgid "URL"
msgstr ""

msgid "``description``"
msgstr ""

msgid "short, summary description of the package"
msgstr ""

msgid "``long_description``"
msgstr ""

msgid "longer description of the package"
msgstr ""

msgid "long string"
msgstr ""

msgid "``download_url``"
msgstr ""

msgid "location where the package may be downloaded"
msgstr ""

msgid "``classifiers``"
msgstr ""

msgid "a list of classifiers"
msgstr ""

msgid "list of strings"
msgstr ""

msgid "``platforms``"
msgstr ""

msgid "a list of platforms"
msgstr ""

msgid "``license``"
msgstr ""

msgid "license for the package"
msgstr ""

msgid "\\(6)"
msgstr ""

msgid "These fields are required."
msgstr ""

msgid "It is recommended that versions take the form *major.minor[.patch[.sub]]*."
msgstr ""

msgid "Either the author or the maintainer must be identified."
msgstr ""

msgid "These fields should not be used if your package is to be compatible with Python versions prior to 2.2.3 or 2.3.  The list is available from the `PyPI website <http://pypi.python.org/pypi>`_."
msgstr ""

msgid "The ``long_description`` field is used by PyPI when you are registering a package, to build its home page."
msgstr ""

msgid "The ``license`` field is a text indicating the license covering the package where the license is not a selection from the \"License\" Trove classifiers. See the ``Classifier`` field. Notice that there's a ``licence`` distribution option which is deprecated but still acts as an alias for ``license``."
msgstr ""

msgid "A single line of text, not more than 200 characters."
msgstr ""

msgid "Multiple lines of plain text in reStructuredText format (see http://docutils.sf.net/)."
msgstr ""

msgid "See below."
msgstr ""

msgid "Encoding the version information is an art in itself. Python packages generally adhere to the version format *major.minor[.patch][sub]*. The major number is 0 for initial, experimental releases of software. It is incremented for releases that represent major milestones in a package. The minor number is incremented when important new features are added to the package. The patch number increments when bug-fix releases are made. Additional trailing version information is sometimes used to indicate sub-releases.  These are \"a1,a2,...,aN\" (for alpha releases, where functionality and API may change), \"b1,b2,...,bN\" (for beta releases, which only fix bugs) and \"pr1,pr2,...,prN\" (for final pre-release release testing). Some examples:"
msgstr ""

msgid "the first, experimental release of a package"
msgstr ""

msgid "the second alpha release of the first patch version of 1.0"
msgstr ""

msgid ":option:`classifiers` are specified in a Python list::"
msgstr ""

msgid "setup(...,       classifiers=[           'Development Status :: 4 - Beta',           'Environment :: Console',           'Environment :: Web Environment',           'Intended Audience :: End Users/Desktop',           'Intended Audience :: Developers',           'Intended Audience :: System Administrators',           'License :: OSI Approved :: Python Software Foundation License',           'Operating System :: MacOS :: MacOS X',           'Operating System :: Microsoft :: Windows',           'Operating System :: POSIX',           'Programming Language :: Python',           'Topic :: Communications :: Email',           'Topic :: Office/Business',           'Topic :: Software Development :: Bug Tracking',           ],       )"
msgstr ""

msgid "If you wish to include classifiers in your :file:`setup.py` file and also wish to remain backwards-compatible with Python releases prior to 2.2.3, then you can include the following code fragment in your :file:`setup.py` before the :func:`setup` call. ::"
msgstr ""

msgid "# patch distutils if it can't cope with the \"classifiers\" or # \"download_url\" keywords from sys import version if version < '2.2.3':     from distutils.dist import DistributionMetadata     DistributionMetadata.classifiers = None     DistributionMetadata.download_url = None"
msgstr ""

msgid "Debugging the setup script"
msgstr ""

msgid "Sometimes things go wrong, and the setup script doesn't do what the developer wants."
msgstr ""

msgid "Distutils catches any exceptions when running the setup script, and print a simple error message before the script is terminated.  The motivation for this behaviour is to not confuse administrators who don't know much about Python and are trying to install a package.  If they get a big long traceback from deep inside the guts of Distutils, they may think the package or the Python installation is broken because they don't read all the way down to the bottom and see that it's a permission problem."
msgstr ""

msgid "On the other hand, this doesn't help the developer to find the cause of the failure. For this purpose, the DISTUTILS_DEBUG environment variable can be set to anything except an empty string, and distutils will now print detailed information what it is doing, and prints the full traceback in case an exception occurs."
msgstr ""

msgid "Creating a Source Distribution"
msgstr ""

msgid "As shown in section :ref:`distutils-simple-example`, you use the :command:`sdist` command to create a source distribution.  In the simplest case, ::"
msgstr ""

msgid "(assuming you haven't specified any :command:`sdist` options in the setup script or config file), :command:`sdist` creates the archive of the default format for the current platform.  The default format is a gzip'ed tar file (:file:`.tar.gz`) on Unix, and ZIP file on Windows."
msgstr ""

msgid "You can specify as many formats as you like using the :option:`--formats` option, for example::"
msgstr ""

msgid "python setup.py sdist --formats=gztar,zip"
msgstr ""

msgid "to create a gzipped tarball and a zip file.  The available formats are:"
msgstr ""

msgid "gzip'ed tar file (:file:`.tar.gz`)"
msgstr ""

msgid "\\(2)"
msgstr ""

msgid "``bztar``"
msgstr ""

msgid "bzip2'ed tar file (:file:`.tar.bz2`)"
msgstr ""

msgid "requires the :program:`compress` program. Notice that this format is now pending for deprecation and will be removed in the future versions of Python."
msgstr ""

msgid "When using any ``tar`` format (``gztar``, ``bztar``, ``ztar`` or ``tar``) under Unix, you can specify the ``owner`` and ``group`` names that will be set for each member of the archive."
msgstr ""

msgid "For example, if you want all files of the archive to be owned by root::"
msgstr ""

msgid "python setup.py sdist --owner=root --group=root"
msgstr ""

msgid "Specifying the files to distribute"
msgstr ""

msgid "If you don't supply an explicit list of files (or instructions on how to generate one), the :command:`sdist` command puts a minimal default set into the source distribution:"
msgstr ""

msgid "all Python source files implied by the :option:`py_modules` and :option:`packages` options"
msgstr ""

msgid "all C source files mentioned in the :option:`ext_modules` or :option:`libraries` options ("
msgstr ""

msgid "**\\*\\*** getting C library sources currently broken---no :meth:`get_source_files` method in :file:`build_clib.py`! **\\*\\***)"
msgstr ""

msgid "scripts identified by the :option:`scripts` option See :ref:`distutils-installing-scripts`."
msgstr ""

msgid "anything that looks like a test script: :file:`test/test\\*.py` (currently, the Distutils don't do anything with test scripts except include them in source distributions, but in the future there will be a standard for testing Python module distributions)"
msgstr ""

msgid ":file:`README.txt` (or :file:`README`), :file:`setup.py` (or whatever  you called your setup script), and :file:`setup.cfg`"
msgstr ""

msgid "all files that matches the ``package_data`` metadata. See :ref:`distutils-installing-package-data`."
msgstr ""

msgid "all files that matches the ``data_files`` metadata. See :ref:`distutils-additional-files`."
msgstr ""

msgid "Sometimes this is enough, but usually you will want to specify additional files to distribute.  The typical way to do this is to write a *manifest template*, called :file:`MANIFEST.in` by default.  The manifest template is just a list of instructions for how to generate your manifest file, :file:`MANIFEST`, which is the exact list of files to include in your source distribution.  The :command:`sdist` command processes this template and generates a manifest based on its instructions and what it finds in the filesystem."
msgstr ""

msgid "If you prefer to roll your own manifest file, the format is simple: one filename per line, regular files (or symlinks to them) only.  If you do supply your own :file:`MANIFEST`, you must specify everything: the default set of files described above does not apply in this case."
msgstr ""

msgid "See :ref:`manifest_template` section for a syntax reference."
msgstr ""

msgid "Manifest-related options"
msgstr ""

msgid "The normal course of operations for the :command:`sdist` command is as follows:"
msgstr ""

msgid "if the manifest file, :file:`MANIFEST` doesn't exist, read :file:`MANIFEST.in` and create the manifest"
msgstr ""

msgid "if neither :file:`MANIFEST` nor :file:`MANIFEST.in` exist, create a manifest with just the default file set"
msgstr ""

msgid "if either :file:`MANIFEST.in` or the setup script (:file:`setup.py`) are more recent than :file:`MANIFEST`, recreate :file:`MANIFEST` by reading :file:`MANIFEST.in`"
msgstr ""

msgid "use the list of files now in :file:`MANIFEST` (either just generated or read in) to create the source distribution archive(s)"
msgstr ""

msgid "There are a couple of options that modify this behaviour.  First, use the :option:`--no-defaults` and :option:`--no-prune` to disable the standard \"include\" and \"exclude\" sets."
msgstr ""

msgid "Second, you might just want to (re)generate the manifest, but not create a source distribution::"
msgstr ""

msgid "python setup.py sdist --manifest-only"
msgstr ""

msgid ":option:`-o` is a sortcut for :option:`--manifest-only`."
msgstr ""

msgid "The MANIFEST.in template"
msgstr ""

msgid "A :file:`MANIFEST.in` file can be added in a project to define the list of files to include in the distribution built by the :command:`sdist` command."
msgstr ""

msgid "When :command:`sdist` is run, it will look for the :file:`MANIFEST.in` file and interpret it to generate the :file:`MANIFEST` file that contains the list of files that will be included in the package."
msgstr ""

msgid "This mechanism can be used when the default list of files is not enough. (See :ref:`manifest`)."
msgstr ""

msgid "Principle"
msgstr ""

msgid "The manifest template has one command per line, where each command specifies a set of files to include or exclude from the source distribution.  For an example, let's look at the Distutils' own manifest template::"
msgstr ""

msgid "include *.txt recursive-include examples *.txt *.py prune examples/sample?/build"
msgstr ""

msgid "The meanings should be fairly clear: include all files in the distribution root matching :file:`\\*.txt`, all files anywhere under the :file:`examples` directory matching :file:`\\*.txt` or :file:`\\*.py`, and exclude all directories matching :file:`examples/sample?/build`.  All of this is done *after* the standard include set, so you can exclude files from the standard set with explicit instructions in the manifest template.  (Or, you can use the :option:`--no-defaults` option to disable the standard set entirely.)"
msgstr ""

msgid "The order of commands in the manifest template matters: initially, we have the list of default files as described above, and each command in the template adds to or removes from that list of files.  Once we have fully processed the manifest template, we remove files that should not be included in the source distribution:"
msgstr ""

msgid "all files in the Distutils \"build\" tree (default :file:`build/`)"
msgstr ""

msgid "all files in directories named :file:`RCS`, :file:`CVS`, :file:`.svn`, :file:`.hg`, :file:`.git`, :file:`.bzr` or :file:`_darcs`"
msgstr ""

msgid "Now we have our complete list of files, which is written to the manifest for future reference, and then used to build the source distribution archive(s)."
msgstr ""

msgid "You can disable the default set of included files with the :option:`--no-defaults` option, and you can disable the standard exclude set with :option:`--no-prune`."
msgstr ""

msgid "Following the Distutils' own manifest template, let's trace how the :command:`sdist` command builds the list of files to include in the Distutils source distribution:"
msgstr ""

msgid "include all Python source files in the :file:`distutils` and :file:`distutils/command` subdirectories (because packages corresponding to those two directories were mentioned in the :option:`packages` option in the setup script---see section :ref:`setup-script`)"
msgstr ""

msgid "include :file:`README.txt`, :file:`setup.py`, and :file:`setup.cfg` (standard files)"
msgstr ""

msgid "include :file:`test/test\\*.py` (standard files)"
msgstr ""

msgid "include :file:`\\*.txt` in the distribution root (this will find :file:`README.txt` a second time, but such redundancies are weeded out later)"
msgstr ""

msgid "include anything matching :file:`\\*.txt` or :file:`\\*.py` in the sub-tree under :file:`examples`,"
msgstr ""

msgid "exclude all files in the sub-trees starting at directories matching :file:`examples/sample?/build`\\ ---this may exclude files included by the previous two steps, so it's important that the ``prune`` command in the manifest template comes after the ``recursive-include`` command"
msgstr ""

msgid "exclude the entire :file:`build` tree, and any :file:`RCS`, :file:`CVS`, :file:`.svn`, :file:`.hg`, :file:`.git`, :file:`.bzr` and :file:`_darcs` directories"
msgstr ""

msgid "Just like in the setup script, file and directory names in the manifest template should always be slash-separated; the Distutils will take care of converting them to the standard representation on your platform. That way, the manifest template is portable across operating systems."
msgstr ""

msgid "Commands"
msgstr ""

msgid "The manifest template commands are:"
msgstr ""

msgid ":command:`include pat1 pat2 ...`"
msgstr ""

msgid "include all files matching any of the listed patterns"
msgstr ""

msgid ":command:`exclude pat1 pat2 ...`"
msgstr ""

msgid "exclude all files matching any of the listed patterns"
msgstr ""

msgid ":command:`recursive-include dir pat1 pat2 ...`"
msgstr ""

msgid "include all files under *dir* matching any of the listed patterns"
msgstr ""

msgid ":command:`recursive-exclude dir pat1 pat2 ...`"
msgstr ""

msgid "exclude all files under *dir* matching any of the listed patterns"
msgstr ""

msgid ":command:`global-include pat1 pat2 ...`"
msgstr ""

msgid "include all files anywhere in the source tree matching --- & any of the listed patterns"
msgstr ""

msgid ":command:`global-exclude pat1 pat2 ...`"
msgstr ""

msgid "exclude all files anywhere in the source tree matching --- & any of the listed patterns"
msgstr ""

msgid ":command:`prune dir`"
msgstr ""

msgid "exclude all files under *dir*"
msgstr ""

msgid ":command:`graft dir`"
msgstr ""

msgid "include all files under *dir*"
msgstr ""

msgid "The patterns here are Unix-style \"glob\" patterns: ``*`` matches any sequence of regular filename characters, ``?`` matches any single regular filename character, and ``[range]`` matches any of the characters in *range* (e.g., ``a-z``, ``a-zA-Z``, ``a-f0-9_.``).  The definition of \"regular filename character\" is platform-specific: on Unix it is anything except slash; on Windows anything except backslash or colon."
msgstr ""

msgid "Uploading Packages to the Package Index"
msgstr ""

msgid "The Python Package Index (PyPI) not only stores the package info, but also  the package data if the author of the package wishes to. The distutils command :command:`upload` pushes the distribution files to PyPI."
msgstr ""

msgid "The command is invoked immediately after building one or more distribution files.  For example, the command ::"
msgstr ""

msgid "python setup.py sdist bdist_wininst upload"
msgstr ""

msgid "will cause the source distribution and the Windows installer to be uploaded to PyPI.  Note that these will be uploaded even if they are built using an earlier invocation of :file:`setup.py`, but that only distributions named on the command line for the invocation including the :command:`upload` command are uploaded."
msgstr ""

msgid "The :command:`upload` command uses the username, password, and repository URL from the :file:`$HOME/.pypirc` file (see section :ref:`pypirc` for more on this file). If a :command:`register` command was previously called in the same command, and if the password was entered in the prompt, :command:`upload` will reuse the entered password. This is useful if you do not want to store a clear text password in the :file:`$HOME/.pypirc` file."
msgstr ""

msgid "You can specify another PyPI server with the :option:`--repository=*url*` option::"
msgstr ""

msgid "python setup.py sdist bdist_wininst upload -r http://example.com/pypi"
msgstr ""

msgid "See section :ref:`pypirc` for more on defining several servers."
msgstr ""

msgid "You can use the :option:`--sign` option to tell :command:`upload` to sign each uploaded file using GPG (GNU Privacy Guard).  The  :program:`gpg` program must be available for execution on the system :envvar:`PATH`.  You can also specify which key to use for signing using the :option:`--identity=*name*` option."
msgstr ""

msgid "Other :command:`upload` options include :option:`--repository=<url>` or :option:`--repository=<section>` where *url* is the url of the server and *section* the name of the section in :file:`$HOME/.pypirc`, and :option:`--show-response` (which displays the full response text from the PyPI server for help in debugging upload problems)."
msgstr ""

msgid "PyPI package display"
msgstr ""

msgid "The ``long_description`` field plays a special role at PyPI. It is used by the server to display a home page for the registered package."
msgstr ""

msgid "If you use the `reStructuredText <http://docutils.sourceforge.net/rst.html>`_ syntax for this field, PyPI will parse it and display an HTML output for the package home page."
msgstr ""

msgid "The ``long_description`` field can be attached to a text file located in the package::"
msgstr ""

msgid "from distutils.core import setup  setup(name='Distutils',       long_description=open('README.txt'))"
msgstr ""

msgid "In that case, :file:`README.txt` is a regular reStructuredText text file located in the root of the package besides :file:`setup.py`."
msgstr ""

msgid "To prevent registering broken reStructuredText content, you can use the :program:`rst2html` program that is provided by the :mod:`docutils` package and check the ``long_description`` from the command line::"
msgstr ""

msgid "$ python setup.py --long-description | rst2html.py > output.html"
msgstr ""

msgid ":mod:`docutils` will display a warning if there's something wrong with your syntax."
msgstr ""
