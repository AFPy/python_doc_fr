# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2010, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-12-22 00:51+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.7.0\n"

#: reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr ""

#: reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""

#: reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements.  Function and class "
"definitions are also syntactically compound statements."
msgstr ""

#: reference/compound_stmts.rst:23
msgid ""
"Compound statements consist of one or more 'clauses.'  A clause consists of "
"a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong:   ::"
msgstr ""

#: reference/compound_stmts.rst:36
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :keyword:`print` "
"statements are executed::"
msgstr ""

#: reference/compound_stmts.rst:42
msgid "Summarizing:"
msgstr ""

#: reference/compound_stmts.rst:62
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``. Also note that optional continuation clauses always begin with a "
"keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""

#: reference/compound_stmts.rst:68
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""

#: reference/compound_stmts.rst:77
#, fuzzy
msgid "The :keyword:`if` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/compound_stmts.rst:84
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ""

#: reference/compound_stmts.rst:91
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""

#: reference/compound_stmts.rst:101
#, fuzzy
msgid "The :keyword:`while` statement"
msgstr "L'instruction :keyword:`if`"

#: reference/compound_stmts.rst:108
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""

#: reference/compound_stmts.rst:115
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`else` clause, if present, is executed and the "
"loop terminates."
msgstr ""

#: reference/compound_stmts.rst:124
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and goes "
"back to testing the expression."
msgstr ""

#: reference/compound_stmts.rst:133
#, fuzzy
msgid "The :keyword:`for` statement"
msgstr "L'instruction :keyword:`if`"

#: reference/compound_stmts.rst:143
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""

#: reference/compound_stmts.rst:150
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"of ascending indices.  Each item in turn is assigned to the target list "
"using the standard rules for assignments, and then the suite is executed.  "
"When the items are exhausted (which is immediately when the sequence is "
"empty), the suite in the :keyword:`else` clause, if present, is executed, "
"and the loop terminates."
msgstr ""

#: reference/compound_stmts.rst:162
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and "
"continues with the next item, or with the :keyword:`else` clause if there "
"was no next item."
msgstr ""

#: reference/compound_stmts.rst:168
msgid ""
"The suite may assign to the variable(s) in the target list; this does not "
"affect the next item assigned to it."
msgstr ""

#: reference/compound_stmts.rst:175
msgid ""
"The target list is not deleted when the loop is finished, but if the "
"sequence is empty, it will not have been assigned to at all by the loop.  "
"Hint: the built-in function :func:`range` returns a sequence of integers "
"suitable to emulate the effect of Pascal's ``for i := a to b do``; e.g., "
"``range(3)`` returns the list ``[0, 1, 2]``."
msgstr ""

#: reference/compound_stmts.rst:187
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, i.e. lists). An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""

#: reference/compound_stmts.rst:208
#, fuzzy
msgid "The :keyword:`try` statement"
msgstr "L'instruction :keyword:`if`"

#: reference/compound_stmts.rst:215
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""

#: reference/compound_stmts.rst:227
msgid ""
"In previous versions of Python, :keyword:`try`...\\ :keyword:`except`...\\ :"
"keyword:`finally` did not work. :keyword:`try`...\\ :keyword:`except` had to "
"be nested in :keyword:`try`...\\ :keyword:`finally`."
msgstr ""

#: reference/compound_stmts.rst:232
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`try` suite, a search for "
"an exception handler is started.  This search inspects the except clauses in "
"turn until one is found that matches the exception.  An expression-less "
"except clause, if present, must be last; it matches any exception.  For an "
"except clause with an expression, that expression is evaluated, and the "
"clause matches the exception if the resulting object is \"compatible\" with "
"the exception.  An object is compatible with an exception if it is the class "
"or a base class of the exception object, or a tuple containing an item "
"compatible with the exception."
msgstr ""

#: reference/compound_stmts.rst:243
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""

#: reference/compound_stmts.rst:246
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""

#: reference/compound_stmts.rst:251
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified in that except clause, if present, and the except clause's "
"suite is executed.  All except clauses must have an executable block.  When "
"the end of this block is reached, execution continues normally after the "
"entire try statement.  (This means that if two nested handlers exist for the "
"same exception, and the exception occurs in the try clause of the inner "
"handler, the outer handler will not handle the exception.)"
msgstr ""

#: reference/compound_stmts.rst:266
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"assigned to three variables in the :mod:`sys` module: ``sys.exc_type`` "
"receives the object identifying the exception; ``sys.exc_value`` receives "
"the exception's parameter; ``sys.exc_traceback`` receives a traceback object "
"(see section :ref:`types`) identifying the point in the program where the "
"exception occurred. These details are also available through the :func:`sys."
"exc_info` function, which returns a tuple ``(exc_type, exc_value, "
"exc_traceback)``.  Use of the corresponding variables is deprecated in favor "
"of this function, since their use is unsafe in a threaded program.  As of "
"Python 1.5, the variables are restored to their previous values (before the "
"call) when returning from a function that handled an exception."
msgstr ""

#: reference/compound_stmts.rst:284
msgid ""
"The optional :keyword:`else` clause is executed if and when control flows "
"off the end of the :keyword:`try` clause. [#]_ Exceptions in the :keyword:"
"`else` clause are not handled by the preceding :keyword:`except` clauses."
msgstr ""

#: reference/compound_stmts.rst:290
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`finally` "
"clause is executed.  If there is a saved exception, it is re-raised at the "
"end of the :keyword:`finally` clause. If the :keyword:`finally` clause "
"raises another exception or executes a :keyword:`return` or :keyword:`break` "
"statement, the saved exception is discarded::"
msgstr ""

#: reference/compound_stmts.rst:308
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""

#: reference/compound_stmts.rst:316
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`try`...\\ :keyword:"
"`finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.' A :keyword:`continue` statement is illegal in the :keyword:"
"`finally` clause. (The reason is a problem with the current implementation "
"--- this restriction may be lifted in the future)."
msgstr ""

#: reference/compound_stmts.rst:323
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`return` statement executed in the :keyword:`finally` clause will "
"always be the last one executed::"
msgstr ""

#: reference/compound_stmts.rst:337
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""

#: reference/compound_stmts.rst:346
#, fuzzy
msgid "The :keyword:`with` statement"
msgstr "L'instruction :keyword:`if`"

#: reference/compound_stmts.rst:354
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""

#: reference/compound_stmts.rst:363
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""

#: reference/compound_stmts.rst:365
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""

#: reference/compound_stmts.rst:368
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""

#: reference/compound_stmts.rst:370
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr ""

#: reference/compound_stmts.rst:372
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""

#: reference/compound_stmts.rst:377
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""

#: reference/compound_stmts.rst:382
msgid "The suite is executed."
msgstr ""

#: reference/compound_stmts.rst:384
msgid ""
"The context manager's :meth:`__exit__` method is invoked. If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""

#: reference/compound_stmts.rst:389
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised. If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""

#: reference/compound_stmts.rst:394
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""

#: reference/compound_stmts.rst:398
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""

#: reference/compound_stmts.rst:404
msgid "is equivalent to ::"
msgstr ""

#: reference/compound_stmts.rst:412
msgid ""
"In Python 2.5, the :keyword:`with` statement is only allowed when the "
"``with_statement`` feature has been enabled.  It is always enabled in Python "
"2.6."
msgstr ""

#: reference/compound_stmts.rst:416
msgid "Support for multiple context expressions."
msgstr ""

#: reference/compound_stmts.rst:422 reference/datamodel.rst:2401
msgid "PEP 0343 - The \"with\" statement"
msgstr ""

#: reference/compound_stmts.rst:422 reference/datamodel.rst:2401
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""

#: reference/compound_stmts.rst:433
msgid "Function definitions"
msgstr ""

#: reference/compound_stmts.rst:443
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""

#: reference/compound_stmts.rst:461
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""

#: reference/compound_stmts.rst:467
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""

#: reference/compound_stmts.rst:473
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code::"
msgstr ""

#: reference/compound_stmts.rst:484
msgid "is equivalent to::"
msgstr ""

#: reference/compound_stmts.rst:493
msgid ""
"When one or more top-level :term:`parameters <parameter>` have the form "
"*parameter* ``=`` *expression*, the function is said to have \"default "
"parameter values.\"  For a parameter with a default value, the "
"corresponding :term:`argument` may be omitted from a call, in which case the "
"parameter's default value is substituted.  If a parameter has a default "
"value, all following parameters must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""

#: reference/compound_stmts.rst:501
msgid ""
"**Default parameter values are evaluated when the function definition is "
"executed.**  This means that the expression is evaluated once, when the "
"function is defined, and that the same \"pre-computed\" value is used for "
"each call.  This is especially important to understand when a default "
"parameter is a mutable object, such as a list or a dictionary: if the "
"function modifies the object (e.g. by appending an item to a list), the "
"default value is in effect modified. This is generally not what was "
"intended.  A way around this  is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""

#: reference/compound_stmts.rst:520
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from position arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple.  If the form \"``**identifier``\" "
"is present, it is initialized to a new dictionary receiving any excess "
"keyword arguments, defaulting to a new empty dictionary."
msgstr ""

#: reference/compound_stmts.rst:530
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`def`\" form is actually more powerful since it allows the execution "
"of multiple statements."
msgstr ""

#: reference/compound_stmts.rst:538
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"form executed inside a function definition defines a local function that can "
"be returned or passed around.  Free variables used in the nested function "
"can access the local variables of the function containing the def.  See "
"section :ref:`naming` for details."
msgstr ""

#: reference/compound_stmts.rst:548
msgid "Class definitions"
msgstr ""

#: reference/compound_stmts.rst:560
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""

#: reference/compound_stmts.rst:567
msgid ""
"A class definition is an executable statement.  It first evaluates the "
"inheritance list, if present.  Each item in the inheritance list should "
"evaluate to a class object or class type which allows subclassing.  The "
"class's suite is then executed in a new execution frame (see section :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains only function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""

#: reference/compound_stmts.rst:578
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"variables; they are shared by all instances.  To create instance variables, "
"they can be set in a method with ``self.name = value``.  Both class and "
"instance variables are accessible through the notation \"``self.name``\", "
"and an instance variable hides a class variable with the same name when "
"accessed in this way. Class variables can be used as defaults for instance "
"variables, but using mutable values there can lead to unexpected results.  "
"For :term:`new-style class`\\es, descriptors can be used to create instance "
"variables with different implementation details."
msgstr ""

#: reference/compound_stmts.rst:588
msgid ""
"Class definitions, like function definitions, may be wrapped by one or more :"
"term:`decorator` expressions.  The evaluation rules for the decorator "
"expressions are the same as for functions.  The result must be a class "
"object, which is then bound to the class name."
msgstr ""

#: reference/compound_stmts.rst:594 reference/datamodel.rst:2509
#: reference/executionmodel.rst:244 reference/expressions.rst:1402
#: reference/lexical_analysis.rst:760 reference/simple_stmts.rst:1048
msgid "Footnotes"
msgstr "Notes"

#: reference/compound_stmts.rst:595
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""

#: reference/compound_stmts.rst:599
msgid ""
"Currently, control \"flows off the end\" except in the case of an exception "
"or the execution of a :keyword:`return`, :keyword:`continue`, or :keyword:"
"`break` statement."
msgstr ""

#: reference/compound_stmts.rst:603
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""

#: reference/compound_stmts.rst:607
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""

#: reference/datamodel.rst:6
msgid "Data model"
msgstr ""

#: reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr ""

#: reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""

#: reference/datamodel.rst:32
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity (currently implemented as its address). An object's :dfn:`type` is "
"also unchangeable. [#]_ An object's type determines the operations that the "
"object supports (e.g., \"does it have a length?\") and also defines the "
"possible values for objects of that type.  The :func:`type` function returns "
"an object's type (which is an object itself).  The *value* of some objects "
"can change.  Objects whose value can change are said to be *mutable*; "
"objects whose value is unchangeable once they are created are called "
"*immutable*. (The value of an immutable container object that contains a "
"reference to a mutable object can change when the latter's value is changed; "
"however the container is still considered immutable, because the collection "
"of objects it contains cannot be changed.  So, immutability is not strictly "
"the same as having an unchangeable value, it is more subtle.) An object's "
"mutability is determined by its type; for instance, numbers, strings and "
"tuples are immutable, while dictionaries and lists are mutable."
msgstr ""

#: reference/datamodel.rst:55
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""

#: reference/datamodel.rst:63
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (ex: "
"always close files)."
msgstr ""

#: reference/datamodel.rst:72
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""

#: reference/datamodel.rst:77
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement provides a convenient way to do this."
msgstr ""

#: reference/datamodel.rst:87
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""

#: reference/datamodel.rst:96
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""

#: reference/datamodel.rst:110
msgid "The standard type hierarchy"
msgstr ""

#: reference/datamodel.rst:119
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.)."
msgstr ""

#: reference/datamodel.rst:129
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""

#: reference/datamodel.rst:139
msgid "None"
msgstr ""

#: reference/datamodel.rst:136
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""

#: reference/datamodel.rst:149
msgid "NotImplemented"
msgstr ""

#: reference/datamodel.rst:144
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods may return this value if they do "
"not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  Its truth value is true."
msgstr ""

#: reference/datamodel.rst:157
msgid "Ellipsis"
msgstr ""

#: reference/datamodel.rst:154
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``Ellipsis``. It is used "
"to indicate the presence of the ``...`` syntax in a slice.  Its truth value "
"is true."
msgstr ""

#: reference/datamodel.rst:249
msgid "numbers.Number"
msgstr ""

#: reference/datamodel.rst:162
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""

#: reference/datamodel.rst:168
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr ""

#: reference/datamodel.rst:224
msgid "numbers.Integral"
msgstr ""

#: reference/datamodel.rst:174
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""

#: reference/datamodel.rst:177
msgid "There are three types of integers:"
msgstr ""

#: reference/datamodel.rst:192
msgid "Plain integers"
msgstr ""

#: reference/datamodel.rst:184
msgid ""
"These represent numbers in the range -2147483648 through 2147483647. (The "
"range may be larger on machines with a larger natural word size, but not "
"smaller.)  When the result of an operation would fall outside this range, "
"the result is normally returned as a long integer (in some cases, the "
"exception :exc:`OverflowError` is raised instead).  For the purpose of shift "
"and mask operations, integers are assumed to have a binary, 2's complement "
"notation using 32 or more bits, and hiding no bits from the user (i.e., all "
"4294967296 different bit patterns correspond to different values)."
msgstr ""

#: reference/datamodel.rst:201
msgid "Long integers"
msgstr ""

#: reference/datamodel.rst:197
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""

#: reference/datamodel.rst:214
msgid "Booleans"
msgstr ""

#: reference/datamodel.rst:209
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of plain integers, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or ``\"True"
"\"`` are returned, respectively."
msgstr ""

#: reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers and the least surprises when switching between the plain and long "
"integer domains.  Any operation, if it yields a result in the plain integer "
"domain, will yield the same result in the long integer domain or when using "
"mixed operands.  The switch between domains is transparent to the programmer."
msgstr ""

#: reference/datamodel.rst:239
msgid "numbers.Real (float)"
msgstr ""

#: reference/datamodel.rst:233
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""

#: reference/datamodel.rst:249
msgid "numbers.Complex"
msgstr ""

#: reference/datamodel.rst:246
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""

#: reference/datamodel.rst:386
msgid "Sequences"
msgstr ""

#: reference/datamodel.rst:259
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""

#: reference/datamodel.rst:266
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""

#: reference/datamodel.rst:273
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""

#: reference/datamodel.rst:277
msgid "Sequences are distinguished according to their mutability:"
msgstr ""

#: reference/datamodel.rst:352
msgid "Immutable sequences"
msgstr ""

#: reference/datamodel.rst:284
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""

#: reference/datamodel.rst:289
msgid "The following types are immutable sequences:"
msgstr ""

#: reference/datamodel.rst:319
msgid "Strings"
msgstr "Les chaînes de caractères"

#: reference/datamodel.rst:300
msgid ""
"The items of a string are characters.  There is no separate character type; "
"a character is represented by a string of one item. Characters represent (at "
"least) 8-bit bytes.  The built-in functions :func:`chr` and :func:`ord` "
"convert between characters and nonnegative integers representing the byte "
"values.  Bytes with the values 0-127 usually represent the corresponding "
"ASCII values, but the interpretation of values is up to the program.  The "
"string data type is also used to represent arrays of bytes, e.g., to hold "
"data read from a file."
msgstr ""

#: reference/datamodel.rst:316
msgid ""
"(On systems whose native character set is not ASCII, strings may use EBCDIC "
"in their internal representation, provided the functions :func:`chr` and :"
"func:`ord` implement a mapping between ASCII and EBCDIC, and string "
"comparison preserves the ASCII order. Or perhaps someone can propose a "
"better rule?)"
msgstr ""

#: reference/datamodel.rst:340
msgid "Unicode"
msgstr "Unicode"

#: reference/datamodel.rst:331
msgid ""
"The items of a Unicode object are Unicode code units.  A Unicode code unit "
"is represented by a Unicode object of one item and can hold either a 16-bit "
"or 32-bit value representing a Unicode ordinal (the maximum value for the "
"ordinal is given in ``sys.maxunicode``, and depends on how Python is "
"configured at compile time).  Surrogate pairs may be present in the Unicode "
"object, and will be reported as two separate items.  The built-in functions :"
"func:`unichr` and :func:`ord` convert between code units and nonnegative "
"integers representing the Unicode ordinals as defined in the Unicode "
"Standard 3.0. Conversion from and to other encodings are possible through "
"the Unicode method :meth:`encode` and the built-in function :func:`unicode`."
msgstr ""

#: reference/datamodel.rst:352
msgid "Tuples"
msgstr ""

#: reference/datamodel.rst:348
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""

#: reference/datamodel.rst:386
msgid "Mutable sequences"
msgstr ""

#: reference/datamodel.rst:362
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""

#: reference/datamodel.rst:366
msgid "There are currently two intrinsic mutable sequence types:"
msgstr ""

#: reference/datamodel.rst:373
msgid "Lists"
msgstr "Les listes"

#: reference/datamodel.rst:371
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""

#: reference/datamodel.rst:381
msgid "Byte Arrays"
msgstr ""

#: reference/datamodel.rst:378
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable bytes objects."
msgstr ""

#: reference/datamodel.rst:385
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type."
msgstr ""

#: reference/datamodel.rst:420
msgid "Set types"
msgstr ""

#: reference/datamodel.rst:393
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""

#: reference/datamodel.rst:400
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""

#: reference/datamodel.rst:405
msgid "There are currently two intrinsic set types:"
msgstr ""

#: reference/datamodel.rst:412
msgid "Sets"
msgstr "Les ensembles"

#: reference/datamodel.rst:410
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""

#: reference/datamodel.rst:420
msgid "Frozen sets"
msgstr ""

#: reference/datamodel.rst:417
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""

#: reference/datamodel.rst:457
msgid "Mappings"
msgstr ""

#: reference/datamodel.rst:428
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""

#: reference/datamodel.rst:434
msgid "There is currently a single intrinsic mapping type:"
msgstr ""

#: reference/datamodel.rst:457
msgid "Dictionaries"
msgstr "Dictionnaires"

#: reference/datamodel.rst:439
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""

#: reference/datamodel.rst:448
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr ""

#: reference/datamodel.rst:456
msgid ""
"The extension modules :mod:`dbm`, :mod:`gdbm`, and :mod:`bsddb` provide "
"additional examples of mapping types."
msgstr ""

#: reference/datamodel.rst:726
msgid "Callable types"
msgstr ""

#: reference/datamodel.rst:466
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""

#: reference/datamodel.rst:559
msgid "User-defined functions"
msgstr ""

#: reference/datamodel.rst:475
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""

#: reference/datamodel.rst:480
msgid "Special attributes:"
msgstr ""

#: reference/datamodel.rst:485
msgid "Attribute"
msgstr ""

#: reference/datamodel.rst:485 reference/lexical_analysis.rst:481
msgid "Meaning"
msgstr "Signification"

#: reference/datamodel.rst:487
msgid ":attr:`__doc__` :attr:`func_doc`"
msgstr ""

#: reference/datamodel.rst:487
msgid "The function's documentation string, or ``None`` if unavailable."
msgstr ""

#: reference/datamodel.rst:487 reference/datamodel.rst:491
#: reference/datamodel.rst:494 reference/datamodel.rst:498
#: reference/datamodel.rst:504 reference/datamodel.rst:514
msgid "Writable"
msgstr ""

#: reference/datamodel.rst:491
msgid ":attr:`__name__` :attr:`func_name`"
msgstr ""

#: reference/datamodel.rst:491
msgid "The function's name."
msgstr ""

#: reference/datamodel.rst:494
msgid ":attr:`__module__`"
msgstr ""

#: reference/datamodel.rst:494
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""

#: reference/datamodel.rst:498
msgid ":attr:`__defaults__` :attr:`func_defaults`"
msgstr ""

#: reference/datamodel.rst:498
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr ""

#: reference/datamodel.rst:504
msgid ":attr:`__code__` :attr:`func_code`"
msgstr ""

#: reference/datamodel.rst:504
msgid "The code object representing the compiled function body."
msgstr ""

#: reference/datamodel.rst:507
msgid ":attr:`__globals__` :attr:`func_globals`"
msgstr ""

#: reference/datamodel.rst:507
msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr ""

#: reference/datamodel.rst:507 reference/datamodel.rst:518
msgid "Read-only"
msgstr ""

#: reference/datamodel.rst:514
msgid ":attr:`__dict__` :attr:`func_dict`"
msgstr ""

#: reference/datamodel.rst:514
msgid "The namespace supporting arbitrary function attributes."
msgstr ""

#: reference/datamodel.rst:518
msgid ":attr:`__closure__` :attr:`func_closure`"
msgstr ""

#: reference/datamodel.rst:518
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr ""

#: reference/datamodel.rst:523
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr ""

#: reference/datamodel.rst:525
msgid "``func_name`` is now writable."
msgstr ""

#: reference/datamodel.rst:528
msgid ""
"The double-underscore attributes ``__closure__``, ``__code__``, "
"``__defaults__``, and ``__globals__`` were introduced as aliases for the "
"corresponding ``func_*`` attributes for forwards compatibility with Python 3."
msgstr ""

#: reference/datamodel.rst:534
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""

#: reference/datamodel.rst:540
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr ""

#: reference/datamodel.rst:657
msgid "User-defined methods"
msgstr ""

#: reference/datamodel.rst:567
msgid ""
"A user-defined method object combines a class, a class instance (or "
"``None``) and any callable object (normally a user-defined function)."
msgstr ""

#: reference/datamodel.rst:570
msgid ""
"Special read-only attributes: :attr:`im_self` is the class instance object, :"
"attr:`im_func` is the function object; :attr:`im_class` is the class of :"
"attr:`im_self` for bound methods or the class that asked for the method for "
"unbound methods; :attr:`__doc__` is the method's documentation (same as "
"``im_func.__doc__``); :attr:`__name__` is the method name (same as ``im_func."
"__name__``); :attr:`__module__` is the name of the module the method was "
"defined in, or ``None`` if unavailable."
msgstr ""

#: reference/datamodel.rst:578
msgid ":attr:`im_self` used to refer to the class that defined the method."
msgstr ""

#: reference/datamodel.rst:581
msgid ""
"For Python 3 forward-compatibility, :attr:`im_func` is also available as :"
"attr:`__func__`, and :attr:`im_self` as :attr:`__self__`."
msgstr ""

#: reference/datamodel.rst:592
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""

#: reference/datamodel.rst:595
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object, an unbound user-defined method object, or a class "
"method object. When the attribute is a user-defined method object, a new "
"method object is only created if the class from which it is being retrieved "
"is the same as, or a derived class of, the class stored in the original "
"method object; otherwise, the original method object is used as it is."
msgstr ""

#: reference/datamodel.rst:608
msgid ""
"When a user-defined method object is created by retrieving a user-defined "
"function object from a class, its :attr:`im_self` attribute is ``None`` and "
"the method object is said to be unbound. When one is created by retrieving a "
"user-defined function object from a class via one of its instances, its :"
"attr:`im_self` attribute is the instance, and the method object is said to "
"be bound. In either case, the new method's :attr:`im_class` attribute is the "
"class from which the retrieval takes place, and its :attr:`im_func` "
"attribute is the original function object."
msgstr ""

#: reference/datamodel.rst:619
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function "
"object, except that the :attr:`im_func` attribute of the new instance is not "
"the original method object but its :attr:`im_func` attribute."
msgstr ""

#: reference/datamodel.rst:629
msgid ""
"When a user-defined method object is created by retrieving a class method "
"object from a class or instance, its :attr:`im_self` attribute is the class "
"itself, and its :attr:`im_func` attribute is the function object underlying "
"the class method."
msgstr ""

#: reference/datamodel.rst:633
msgid ""
"When an unbound user-defined method object is called, the underlying "
"function (:attr:`im_func`) is called, with the restriction that the first "
"argument must be an instance of the proper class (:attr:`im_class`) or of a "
"derived class thereof."
msgstr ""

#: reference/datamodel.rst:638
msgid ""
"When a bound user-defined method object is called, the underlying function (:"
"attr:`im_func`) is called, inserting the class instance (:attr:`im_self`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""

#: reference/datamodel.rst:644
msgid ""
"When a user-defined method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`im_self` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""

#: reference/datamodel.rst:649
msgid ""
"Note that the transformation from function object to (unbound or bound) "
"method object happens each time the attribute is retrieved from the class or "
"instance. In some cases, a fruitful optimization is to assign the attribute "
"to a local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without "
"transformation.  It is also important to note that user-defined functions "
"which are attributes of a class instance are not converted to bound methods; "
"this *only* happens when the function is an attribute of the class."
msgstr ""

#: reference/datamodel.rst:673
msgid "Generator functions"
msgstr ""

#: reference/datamodel.rst:664
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`~iterator.next` method "
"will cause the function to execute until it provides a value using the :"
"keyword:`yield` statement.  When the function executes a :keyword:`return` "
"statement or falls off the end, a :exc:`StopIteration` exception is raised "
"and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ""

#: reference/datamodel.rst:688
msgid "Built-in functions"
msgstr ""

#: reference/datamodel.rst:681
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`__name__` is the function's name; :attr:`__self__` is set to ``None`` (but "
"see the next item); :attr:`__module__` is the name of the module the "
"function was defined in or ``None`` if unavailable."
msgstr ""

#: reference/datamodel.rst:700
msgid "Built-in methods"
msgstr ""

#: reference/datamodel.rst:696
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""

#: reference/datamodel.rst:707
msgid "Class Types"
msgstr ""

#: reference/datamodel.rst:703
msgid ""
"Class types, or \"new-style classes,\" are callable.  These objects normally "
"act as factories for new instances of themselves, but variations are "
"possible for class types that override :meth:`__new__`.  The arguments of "
"the call are passed to :meth:`__new__` and, in the typical case, to :meth:"
"`__init__` to initialize the new instance."
msgstr ""

#: reference/datamodel.rst:721
msgid "Classic Classes"
msgstr ""

#: reference/datamodel.rst:717
msgid ""
"Class objects are described below.  When a class object is called, a new "
"class instance (also described below) is created and returned.  This implies "
"a call to the class's :meth:`__init__` method if it has one.  Any arguments "
"are passed on to the :meth:`__init__` method.  If there is no :meth:"
"`__init__` method, the class must be called without arguments."
msgstr ""

#: reference/datamodel.rst:726 reference/datamodel.rst:878
msgid "Class instances"
msgstr ""

#: reference/datamodel.rst:724
msgid ""
"Class instances are described below.  Class instances are callable only when "
"the class has a :meth:`__call__` method; ``x(arguments)`` is a shorthand for "
"``x.__call__(arguments)``."
msgstr ""

#: reference/datamodel.rst:769
msgid "Modules"
msgstr "Modules"

#: reference/datamodel.rst:733
msgid ""
"Modules are imported by the :keyword:`import` statement (see section :ref:"
"`import`). A module object has a namespace implemented by a dictionary "
"object (this is the dictionary referenced by the func_globals attribute of "
"functions defined in the module).  Attribute references are translated to "
"lookups in this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x"
"\"]``. A module object does not contain the code object used to initialize "
"the module (since it isn't needed once the initialization is done)."
msgstr ""

#: reference/datamodel.rst:742
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""

#: reference/datamodel.rst:747
msgid ""
"Special read-only attribute: :attr:`__dict__` is the module's namespace as a "
"dictionary object."
msgstr ""

#: reference/datamodel.rst:752
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""

#: reference/datamodel.rst:763
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; :"
"attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute is not present for C modules that are statically linked into the "
"interpreter; for extension modules loaded dynamically from a shared library, "
"it is the pathname of the shared library file."
msgstr ""

#: reference/datamodel.rst:832
msgid "Classes"
msgstr "Classes"

#: reference/datamodel.rst:772
msgid ""
"Both class types (new-style classes) and class objects (old-style/classic "
"classes) are typically created by class definitions (see section :ref:"
"`class`).  A class has a namespace implemented by a dictionary object. Class "
"attribute references are translated to lookups in this dictionary, e.g., ``C."
"x`` is translated to ``C.__dict__[\"x\"]`` (although for new-style classes "
"in particular there are a number of hooks which allow for other means of "
"locating attributes). When the attribute name is not found there, the "
"attribute search continues in the base classes.  For old-style classes, the "
"search is depth-first, left-to-right in the order of occurrence in the base "
"class list. New-style classes use the more complex C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by new-style classes "
"can be found in the documentation accompanying the 2.3 release at https://"
"www.python.org/download/releases/2.3/mro/."
msgstr ""

#: reference/datamodel.rst:799
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"user-defined function object or an unbound user-defined method object whose "
"associated class is either :class:`C` or one of its base classes, it is "
"transformed into an unbound user-defined method object whose :attr:"
"`im_class` attribute is :class:`C`. When it would yield a class method "
"object, it is transformed into a bound user-defined method object whose :"
"attr:`im_self` attribute is :class:`C`.  When it would yield a static method "
"object, it is transformed into the object wrapped by the static method "
"object. See section :ref:`descriptors` for another way in which attributes "
"retrieved from a class may differ from those actually contained in its :attr:"
"`__dict__` (note that only new-style classes support descriptors)."
msgstr ""

#: reference/datamodel.rst:813
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""

#: reference/datamodel.rst:818
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""

#: reference/datamodel.rst:827
msgid ""
"Special attributes: :attr:`__name__` is the class name; :attr:`__module__` "
"is the module name in which the class was defined; :attr:`__dict__` is the "
"dictionary containing the class's namespace; :attr:`~class.__bases__` is a "
"tuple (possibly empty or a singleton) containing the base classes, in the "
"order of their occurrence in the base class list; :attr:`__doc__` is the "
"class's documentation string, or None if undefined."
msgstr ""

#: reference/datamodel.rst:841
msgid ""
"A class instance is created by calling a class object (see above). A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object or an unbound user-defined method "
"object whose associated class is the class (call it :class:`C`) of the "
"instance for which the attribute reference was initiated or one of its "
"bases, it is transformed into a bound user-defined method object whose :attr:"
"`im_class` attribute is :class:`C` and whose :attr:`im_self` attribute is "
"the instance. Static method and class method objects are also transformed, "
"as if they had been retrieved from class :class:`C`; see above under "
"\"Classes\". See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`__dict__`. If no class "
"attribute is found, and the object's class has a :meth:`__getattr__` method, "
"that is called to satisfy the lookup."
msgstr ""

#: reference/datamodel.rst:860
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:"
"`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""

#: reference/datamodel.rst:870
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""

#: reference/datamodel.rst:877
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr ""

#: reference/datamodel.rst:901
msgid "Files"
msgstr ""

#: reference/datamodel.rst:894
msgid ""
"A file object represents an open file.  File objects are created by the :"
"func:`open` built-in function, and also by :func:`os.popen`, :func:`os."
"fdopen`, and the :meth:`makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules).  The objects "
"``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized to file "
"objects corresponding to the interpreter's standard input, output and error "
"streams.  See :ref:`bltin-file-objects` for complete documentation of file "
"objects."
msgstr ""

#: reference/datamodel.rst:1111
msgid "Internal types"
msgstr ""

#: reference/datamodel.rst:908
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""

#: reference/datamodel.rst:978
#, fuzzy
msgid "Code objects"
msgstr "Objets Code"

#: reference/datamodel.rst:917
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""

#: reference/datamodel.rst:942
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_argcount` is the number of positional arguments (including arguments "
"with default values); :attr:`co_nlocals` is the number of local variables "
"used by the function (including arguments); :attr:`co_varnames` is a tuple "
"containing the names of the local variables (starting with the argument "
"names); :attr:`co_cellvars` is a tuple containing the names of local "
"variables that are referenced by nested functions; :attr:`co_freevars` is a "
"tuple containing the names of free variables; :attr:`co_code` is a string "
"representing the sequence of bytecode instructions; :attr:`co_consts` is a "
"tuple containing the literals used by the bytecode; :attr:`co_names` is a "
"tuple containing the names used by the bytecode; :attr:`co_filename` is the "
"filename from which the code was compiled; :attr:`co_firstlineno` is the "
"first line number of the function; :attr:`co_lnotab` is a string encoding "
"the mapping from bytecode offsets to line numbers (for details see the "
"source code of the interpreter); :attr:`co_stacksize` is the required stack "
"size (including local variables); :attr:`co_flags` is an integer encoding a "
"number of flags for the interpreter."
msgstr ""

#: reference/datamodel.rst:961
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""

#: reference/datamodel.rst:967
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""

#: reference/datamodel.rst:973
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ""

#: reference/datamodel.rst:977
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""

#: reference/datamodel.rst:1020
msgid "Frame objects"
msgstr ""

#: reference/datamodel.rst:985
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr ""

#: reference/datamodel.rst:997
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_restricted` is a flag indicating whether the function is "
"executing in restricted execution mode; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code object)."
msgstr ""

#: reference/datamodel.rst:1013
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called at the start of each source code line (this is used by the "
"debugger); :attr:`f_exc_type`, :attr:`f_exc_value`, :attr:`f_exc_traceback` "
"represent the last exception raised in the parent frame provided another "
"exception was ever raised in the current frame (in all other cases they are "
"None); :attr:`f_lineno` is the current line number of the frame --- writing "
"to this from within a trace function jumps to the given line (only for the "
"bottom-most frame).  A debugger can implement a Jump command (aka Set Next "
"Statement) by writing to f_lineno."
msgstr ""

#: reference/datamodel.rst:1062
msgid "Traceback objects"
msgstr ""

#: reference/datamodel.rst:1035
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as ``sys."
"exc_traceback``, and also as the third item of the tuple returned by ``sys."
"exc_info()``.  The latter is the preferred interface, since it works "
"correctly when the program is using multiple threads. When the program "
"contains no suitable handler, the stack trace is written (nicely formatted) "
"to the standard error stream; if the interpreter is interactive, it is also "
"made available to the user as ``sys.last_traceback``."
msgstr ""

#: reference/datamodel.rst:1055
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level; :attr:`tb_frame` points to the execution frame of the "
"current level; :attr:`tb_lineno` gives the line number where the exception "
"occurred; :attr:`tb_lasti` indicates the precise instruction.  The line "
"number and last instruction in the traceback may differ from the line number "
"of its frame object if the exception occurred in a :keyword:`try` statement "
"with no matching except clause or with a finally clause."
msgstr ""

#: reference/datamodel.rst:1093
msgid "Slice objects"
msgstr ""

#: reference/datamodel.rst:1067
msgid ""
"Slice objects are used to represent slices when *extended slice syntax* is "
"used. This is a slice using two colons, or multiple slices or ellipses "
"separated by commas, e.g., ``a[i:j:step]``, ``a[i:j, k:l]``, or ``a[..., i:"
"j]``.  They are also created by the built-in :func:`slice` function."
msgstr ""

#: reference/datamodel.rst:1077
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""

#: reference/datamodel.rst:1081
msgid "Slice objects support one method:"
msgstr ""

#: reference/datamodel.rst:1086
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the extended slice that the slice object would describe if "
"applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices are "
"handled in a manner consistent with regular slices."
msgstr ""

#: reference/datamodel.rst:1103
msgid "Static method objects"
msgstr ""

#: reference/datamodel.rst:1096
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""

#: reference/datamodel.rst:1111
msgid "Class method objects"
msgstr ""

#: reference/datamodel.rst:1106
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""

#: reference/datamodel.rst:1116
msgid "New-style and classic classes"
msgstr ""

#: reference/datamodel.rst:1118
msgid ""
"Classes and instances come in two flavors: old-style (or classic) and new-"
"style."
msgstr ""

#: reference/datamodel.rst:1120
msgid ""
"Up to Python 2.1 the concept of ``class`` was unrelated to the concept of "
"``type``, and old-style classes were the only flavor available.  For an old-"
"style class, the statement ``x.__class__`` provides the class of *x*, but "
"``type(x)`` is always ``<type 'instance'>``.  This reflects the fact that "
"all old-style instances, independent of their class, are implemented with a "
"single built-in type, called ``instance``."
msgstr ""

#: reference/datamodel.rst:1127
msgid ""
"New-style classes were introduced in Python 2.2 to unify the concepts of "
"``class`` and ``type``.  A new-style class is simply a user-defined type, no "
"more, no less.  If *x* is an instance of a new-style class, then ``type(x)`` "
"is typically the same as ``x.__class__`` (although this is not guaranteed -- "
"a new-style class instance is permitted to override the value returned for "
"``x.__class__``)."
msgstr ""

#: reference/datamodel.rst:1134
msgid ""
"The major motivation for introducing new-style classes is to provide a "
"unified object model with a full meta-model.  It also has a number of "
"practical benefits, like the ability to subclass most built-in types, or the "
"introduction of \"descriptors\", which enable computed properties."
msgstr ""

#: reference/datamodel.rst:1139
msgid ""
"For compatibility reasons, classes are still old-style by default.  New-"
"style classes are created by specifying another new-style class (i.e. a "
"type) as a parent class, or the \"top-level type\" :class:`object` if no "
"other parent is needed.  The behaviour of new-style classes differs from "
"that of old-style classes in a number of important details in addition to "
"what :func:`type` returns.  Some of these changes are fundamental to the new "
"object model, like the way special methods are invoked.  Others are \"fixes"
"\" that could not be implemented before for compatibility concerns, like the "
"method resolution order in case of multiple inheritance."
msgstr ""

#: reference/datamodel.rst:1149
msgid ""
"While this manual aims to provide comprehensive coverage of Python's class "
"mechanics, it may still be lacking in some areas when it comes to its "
"coverage of new-style classes. Please see https://www.python.org/doc/"
"newstyle/ for sources of additional information."
msgstr ""

#: reference/datamodel.rst:1159
msgid ""
"Old-style classes are removed in Python 3, leaving only new-style classes."
msgstr ""

#: reference/datamodel.rst:1165
msgid "Special method names"
msgstr ""

#: reference/datamodel.rst:1171
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is "
"roughly equivalent to ``x.__getitem__(i)`` for old-style classes and "
"``type(x).__getitem__(x, i)`` for new-style classes.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""

#: reference/datamodel.rst:1182
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""

#: reference/datamodel.rst:1193
msgid "Basic customization"
msgstr ""

#: reference/datamodel.rst:1199
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""

#: reference/datamodel.rst:1206
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super(currentclass, cls)."
"__new__(cls[, ...])`` with appropriate arguments and then modifying the "
"newly-created instance as necessary before returning it."
msgstr ""

#: reference/datamodel.rst:1211
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's :"
"meth:`__init__` method will be invoked like ``__init__(self[, ...])``, where "
"*self* is the new instance and the remaining arguments are the same as were "
"passed to :meth:`__new__`."
msgstr ""

#: reference/datamodel.rst:1216
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""

#: reference/datamodel.rst:1219
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""

#: reference/datamodel.rst:1228
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``BaseClass.__init__(self, [args...])``."
msgstr ""

#: reference/datamodel.rst:1235
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customise "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""

#: reference/datamodel.rst:1247
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure "
"proper deletion of the base class part of the instance.  Note that it is "
"possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  It "
"may then be called at a later time when this new reference is deleted.  It "
"is not guaranteed that :meth:`__del__` methods are called for objects that "
"still exist when the interpreter exits."
msgstr ""

#: reference/datamodel.rst:1259
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree "
"data structure with parent and child pointers); a reference to the object on "
"the stack frame of a function that caught an exception (the traceback stored "
"in ``sys.exc_traceback`` keeps the stack frame alive); or a reference to the "
"object on the stack frame that raised an unhandled exception in interactive "
"mode (the traceback stored in ``sys.last_traceback`` keeps the stack frame "
"alive).  The first situation can only be remedied by explicitly breaking the "
"cycles; the latter two situations can be resolved by storing ``None`` in "
"``sys.exc_traceback`` or ``sys.last_traceback``.  Circular references which "
"are garbage are detected when the option cycle detector is enabled (it's on "
"by default), but can only be cleaned up if there are no Python-level :meth:"
"`__del__` methods involved. Refer to the documentation for the :mod:`gc` "
"module for more information about how :meth:`__del__` methods are handled by "
"the cycle detector, particularly the description of the ``garbage`` value."
msgstr ""

#: reference/datamodel.rst:1281
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is "
"invoked in response to a module being deleted (e.g., when execution of the "
"program is done), other globals referenced by the :meth:`__del__` method may "
"already have been deleted or in the process of being torn down (e.g. the "
"import machinery shutting down).  For this reason, :meth:`__del__` methods "
"should do the absolute minimum needed to maintain external invariants.  "
"Starting with version 1.5, Python guarantees that globals whose name begins "
"with a single underscore are deleted from their module before other globals "
"are deleted; if no other references to such globals exist, this may help in "
"assuring that imported modules are still available at the time when the :"
"meth:`__del__` method is called."
msgstr ""

#: reference/datamodel.rst:1296
msgid "See also the :option:`-R` command-line option."
msgstr ""

#: reference/datamodel.rst:1303
msgid ""
"Called by the :func:`repr` built-in function and by string conversions "
"(reverse quotes) to compute the \"official\" string representation of an "
"object.  If at all possible, this should look like a valid Python expression "
"that could be used to recreate an object with the same value (given an "
"appropriate environment).  If this is not possible, a string of the form "
"``<...some useful description...>`` should be returned.  The return value "
"must be a string object. If a class defines :meth:`__repr__` but not :meth:"
"`__str__`, then :meth:`__repr__` is also used when an \"informal\" string "
"representation of instances of that class is required."
msgstr ""

#: reference/datamodel.rst:1319
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""

#: reference/datamodel.rst:1329
msgid ""
"Called by the :func:`str` built-in function and by the :keyword:`print` "
"statement to compute the \"informal\" string representation of an object.  "
"This differs from :meth:`__repr__` in that it does not have to be a valid "
"Python expression: a more convenient or concise representation may be used "
"instead. The return value must be a string object."
msgstr ""

#: reference/datamodel.rst:1348
msgid ""
"These are the so-called \"rich comparison\" methods, and are called for "
"comparison operators in preference to :meth:`__cmp__` below. The "
"correspondence between operator symbols and method names is as follows: "
"``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` "
"calls ``x.__eq__(y)``, ``x!=y`` and ``x<>y`` call ``x.__ne__(y)``, ``x>y`` "
"calls ``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""

#: reference/datamodel.rst:1355
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""

#: reference/datamodel.rst:1362
msgid ""
"There are no implied relationships among the comparison operators. The truth "
"of ``x==y`` does not imply that ``x!=y`` is false.  Accordingly, when "
"defining :meth:`__eq__`, one should also define :meth:`__ne__` so that the "
"operators will behave as expected.  See the paragraph on :meth:`__hash__` "
"for some important notes on creating :term:`hashable` objects which support "
"custom comparison operations and are usable as dictionary keys."
msgstr ""

#: reference/datamodel.rst:1369
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection."
msgstr ""

#: reference/datamodel.rst:1375
msgid "Arguments to rich comparison methods are never coerced."
msgstr ""

#: reference/datamodel.rst:1377
msgid ""
"To automatically generate ordering operations from a single root operation, "
"see :func:`functools.total_ordering`."
msgstr ""

#: reference/datamodel.rst:1386
msgid ""
"Called by comparison operations if rich comparison (see above) is not "
"defined.  Should return a negative integer if ``self < other``, zero if "
"``self == other``, a positive integer if ``self > other``.  If no :meth:"
"`__cmp__`, :meth:`__eq__` or :meth:`__ne__` operation is defined, class "
"instances are compared by object identity (\"address\").  See also the "
"description of :meth:`__hash__` for some important notes on creating :term:"
"`hashable` objects which support custom comparison operations and are usable "
"as dictionary keys. (Note: the restriction that exceptions are not "
"propagated by :meth:`__cmp__` has been removed since Python 1.5.)"
msgstr ""

#: reference/datamodel.rst:1399
msgid "No longer supported."
msgstr ""

#: reference/datamodel.rst:1409
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  :meth:`__hash__` should return an integer.  The only required "
"property is that objects which compare equal have the same hash value; it is "
"advised to somehow mix together (e.g. using exclusive or) the hash values "
"for the components of the object that also play a part in comparison of "
"objects."
msgstr ""

#: reference/datamodel.rst:1416
msgid ""
"If a class does not define a :meth:`__cmp__` or :meth:`__eq__` method it "
"should not define a :meth:`__hash__` operation either; if it defines :meth:"
"`__cmp__` or :meth:`__eq__` but not :meth:`__hash__`, its instances will not "
"be usable in hashed collections.  If a class defines mutable objects and "
"implements a :meth:`__cmp__` or :meth:`__eq__` method, it should not "
"implement :meth:`__hash__`, since hashable collection implementations "
"require that a object's hash value is immutable (if the object's hash value "
"changes, it will be in the wrong hash bucket)."
msgstr ""

#: reference/datamodel.rst:1425
msgid ""
"User-defined classes have :meth:`__cmp__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns a result derived from ``id(x)``."
msgstr ""

#: reference/datamodel.rst:1429
msgid ""
"Classes which inherit a :meth:`__hash__` method from a parent class but "
"change the meaning of :meth:`__cmp__` or :meth:`__eq__` such that the hash "
"value returned is no longer appropriate (e.g. by switching to a value-based "
"concept of equality instead of the default identity based equality) can "
"explicitly flag themselves as being unhashable by setting ``__hash__ = "
"None`` in the class definition. Doing so means that not only will instances "
"of the class raise an appropriate :exc:`TypeError` when a program attempts "
"to retrieve their hash value, but they will also be correctly identified as "
"unhashable when checking ``isinstance(obj, collections.Hashable)`` (unlike "
"classes which define their own :meth:`__hash__` to explicitly raise :exc:"
"`TypeError`)."
msgstr ""

#: reference/datamodel.rst:1441
msgid ""
":meth:`__hash__` may now also return a long integer object; the 32-bit "
"integer is then derived from the hash of that object."
msgstr ""

#: reference/datamodel.rst:1445
msgid ""
":attr:`__hash__` may now be set to :const:`None` to explicitly flag "
"instances of a class as unhashable."
msgstr ""

#: reference/datamodel.rst:1454
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``, or their integer "
"equivalents ``0`` or ``1``.  When this method is not defined, :meth:"
"`__len__` is called, if it is defined, and the object is considered true if "
"its result is nonzero. If a class defines neither :meth:`__len__` nor :meth:"
"`__nonzero__`, all its instances are considered true."
msgstr ""

#: reference/datamodel.rst:1466
msgid ""
"Called to implement :func:`unicode` built-in; should return a Unicode "
"object. When this method is not defined, string conversion is attempted, and "
"the result of string conversion is converted to Unicode using the system "
"default encoding."
msgstr ""

#: reference/datamodel.rst:1474
msgid "Customizing attribute access"
msgstr ""

#: reference/datamodel.rst:1476
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""

#: reference/datamodel.rst:1482
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class "
"tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""

#: reference/datamodel.rst:1489
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control in new-style classes."
msgstr ""

#: reference/datamodel.rst:1502
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary).  "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""

#: reference/datamodel.rst:1508
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"not simply execute ``self.name = value`` --- this would cause a recursive "
"call to itself.  Instead, it should insert the value in the dictionary of "
"instance attributes, e.g., ``self.__dict__[name] = value``.  For new-style "
"classes, rather than accessing the instance dictionary, it should call the "
"base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""

#: reference/datamodel.rst:1519
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""

#: reference/datamodel.rst:1526
msgid "More attribute access for new-style classes"
msgstr ""

#: reference/datamodel.rst:1528
msgid "The following methods only apply to new-style classes."
msgstr ""

#: reference/datamodel.rst:1533
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""

#: reference/datamodel.rst:1544
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`new-style-special-lookup`."
msgstr ""

#: reference/datamodel.rst:1552
msgid "Implementing Descriptors"
msgstr ""

#: reference/datamodel.rst:1554
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the attribute"
"\" refers to the attribute whose name is the key of the property in the "
"owner class' :attr:`__dict__`."
msgstr ""

#: reference/datamodel.rst:1564
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr ""

#: reference/datamodel.rst:1574
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""

#: reference/datamodel.rst:1580
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""

#: reference/datamodel.rst:1586
msgid "Invoking Descriptors"
msgstr ""

#: reference/datamodel.rst:1588
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""

#: reference/datamodel.rst:1593
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""

#: reference/datamodel.rst:1598
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called.  "
"Note that descriptors are only invoked for new style objects or classes "
"(ones that subclass :class:`object()` or :class:`type()`)."
msgstr ""

#: reference/datamodel.rst:1605
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""

#: reference/datamodel.rst:1610
msgid "Direct Call"
msgstr ""

#: reference/datamodel.rst:1609
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""

#: reference/datamodel.rst:1614
msgid "Instance Binding"
msgstr ""

#: reference/datamodel.rst:1613
msgid ""
"If binding to a new-style object instance, ``a.x`` is transformed into the "
"call: ``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""

#: reference/datamodel.rst:1618
msgid "Class Binding"
msgstr ""

#: reference/datamodel.rst:1617
msgid ""
"If binding to a new-style class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""

#: reference/datamodel.rst:1624
msgid "Super Binding"
msgstr ""

#: reference/datamodel.rst:1621
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj)."
"m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""

#: reference/datamodel.rst:1626
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return "
"the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or :meth:"
"`__delete__`, it is a data descriptor; if it defines neither, it is a non-"
"data descriptor.  Normally, data descriptors define both :meth:`__get__` "
"and :meth:`__set__`, while non-data descriptors have just the :meth:"
"`__get__` method.  Data descriptors with :meth:`__set__` and :meth:`__get__` "
"defined always override a redefinition in an instance dictionary.  In "
"contrast, non-data descriptors can be overridden by instances."
msgstr ""

#: reference/datamodel.rst:1639
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors "
"that differ from other instances of the same class."
msgstr ""

#: reference/datamodel.rst:1644
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""

#: reference/datamodel.rst:1651
msgid "__slots__"
msgstr "__slots__"

#: reference/datamodel.rst:1653
msgid ""
"By default, instances of both old and new-style classes have a dictionary "
"for attribute storage.  This wastes space for objects having very few "
"instance variables.  The space consumption can become acute when creating "
"large numbers of instances."
msgstr ""

#: reference/datamodel.rst:1658
msgid ""
"The default can be overridden by defining *__slots__* in a new-style class "
"definition.  The *__slots__* declaration takes a sequence of instance "
"variables and reserves just enough space in each instance to hold a value "
"for each variable.  Space is saved because *__dict__* is not created for "
"each instance."
msgstr ""

#: reference/datamodel.rst:1666
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  If defined in a new-style "
"class, *__slots__* reserves space for the declared variables and prevents "
"the automatic creation of *__dict__* and *__weakref__* for each instance."
msgstr ""

#: reference/datamodel.rst:1673
msgid "Notes on using *__slots__*"
msgstr ""

#: reference/datamodel.rst:1675
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* attribute "
"of that class will always be accessible, so a *__slots__* definition in the "
"subclass is meaningless."
msgstr ""

#: reference/datamodel.rst:1679
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted "
"variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""

#: reference/datamodel.rst:1685
msgid ""
"Previously, adding ``'__dict__'`` to the *__slots__* declaration would not "
"enable the assignment of new attributes not specifically listed in the "
"sequence of instance variable names."
msgstr ""

#: reference/datamodel.rst:1690
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""

#: reference/datamodel.rst:1695
msgid ""
"Previously, adding ``'__weakref__'`` to the *__slots__* declaration would "
"not enable support for weak references."
msgstr ""

#: reference/datamodel.rst:1699
msgid ""
"*__slots__* are implemented at the class level by creating descriptors (:ref:"
"`descriptors`) for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""

#: reference/datamodel.rst:1705
msgid ""
"The action of a *__slots__* declaration is limited to the class where it is "
"defined.  As a result, subclasses will have a *__dict__* unless they also "
"define *__slots__* (which must only contain names of any *additional* slots)."
msgstr ""

#: reference/datamodel.rst:1709
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""

#: reference/datamodel.rst:1714
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-length"
"\" built-in types such as :class:`long`, :class:`str` and :class:`tuple`."
msgstr ""

#: reference/datamodel.rst:1717
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be "
"used; however, in the future, special meaning may be assigned to the values "
"corresponding to each key."
msgstr ""

#: reference/datamodel.rst:1721
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr ""

#: reference/datamodel.rst:1723
msgid ""
"Previously, *__class__* assignment raised an error if either new or old "
"class had *__slots__*."
msgstr ""

#: reference/datamodel.rst:1731
msgid "Customizing class creation"
msgstr ""

#: reference/datamodel.rst:1733
msgid ""
"By default, new-style classes are constructed using :func:`type`. A class "
"definition is read into a separate namespace and the value of class name is "
"bound to the result of ``type(name, bases, dict)``."
msgstr ""

#: reference/datamodel.rst:1737
msgid ""
"When the class definition is read, if *__metaclass__* is defined then the "
"callable assigned to it will be called instead of :func:`type`. This allows "
"classes or functions to be written which monitor or alter the class creation "
"process:"
msgstr ""

#: reference/datamodel.rst:1742
msgid "Modifying the class dictionary prior to the class being created."
msgstr ""

#: reference/datamodel.rst:1744
msgid ""
"Returning an instance of another class -- essentially performing the role of "
"a factory function."
msgstr ""

#: reference/datamodel.rst:1747
msgid ""
"These steps will have to be performed in the metaclass's :meth:`__new__` "
"method -- :meth:`type.__new__` can then be called from this method to create "
"a class with different properties.  This example adds a new element to the "
"class dictionary before creating the class::"
msgstr ""

#: reference/datamodel.rst:1757
msgid ""
"You can of course also override other class methods (or add new methods); "
"for example defining a custom :meth:`__call__` method in the metaclass "
"allows custom behavior when the class is called, e.g. not always creating a "
"new instance."
msgstr ""

#: reference/datamodel.rst:1764
msgid ""
"This variable can be any callable accepting arguments for ``name``, "
"``bases``, and ``dict``.  Upon class creation, the callable is used instead "
"of the built-in :func:`type`."
msgstr ""

#: reference/datamodel.rst:1770
msgid ""
"The appropriate metaclass is determined by the following precedence rules:"
msgstr ""

#: reference/datamodel.rst:1772
msgid "If ``dict['__metaclass__']`` exists, it is used."
msgstr ""

#: reference/datamodel.rst:1774
msgid ""
"Otherwise, if there is at least one base class, its metaclass is used (this "
"looks for a *__class__* attribute first and if not found, uses its type)."
msgstr ""

#: reference/datamodel.rst:1777
msgid "Otherwise, if a global variable named __metaclass__ exists, it is used."
msgstr ""

#: reference/datamodel.rst:1779
msgid "Otherwise, the old-style, classic metaclass (types.ClassType) is used."
msgstr ""

#: reference/datamodel.rst:1781
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored including logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""

#: reference/datamodel.rst:1788
msgid "Customizing instance and subclass checks"
msgstr ""

#: reference/datamodel.rst:1792
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""

#: reference/datamodel.rst:1795
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""

#: reference/datamodel.rst:1802
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""

#: reference/datamodel.rst:1809
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""

#: reference/datamodel.rst:1814
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""

#: reference/datamodel.rst:1825
msgid "PEP 3119 - Introducing Abstract Base Classes"
msgstr ""

#: reference/datamodel.rst:1822
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""

#: reference/datamodel.rst:1832
msgid "Emulating callable objects"
msgstr ""

#: reference/datamodel.rst:1839
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, "
"arg2, ...)``."
msgstr ""

#: reference/datamodel.rst:1846
msgid "Emulating container types"
msgstr ""

#: reference/datamodel.rst:1848
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like "
"dictionaries), but can represent other containers as well.  The first set of "
"methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or "
"slice objects, which define a range of items. (For backwards compatibility, "
"the method :meth:`__getslice__` (see below) can also be defined to handle "
"simple, but not extended slices.) It is also recommended that mappings "
"provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :meth:"
"`has_key`, :meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:"
"`iterkeys`, :meth:`itervalues`, :meth:`iteritems`, :meth:`pop`, :meth:"
"`popitem`, :meth:`!copy`, and :meth:`update` behaving similar to those for "
"Python's standard dictionary objects.  The :mod:`UserDict` module provides "
"a :class:`DictMixin` class to help create those methods from a base set of :"
"meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, and :meth:"
"`keys`. Mutable sequences should provide methods :meth:`append`, :meth:"
"`count`, :meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, :meth:"
"`remove`, :meth:`reverse` and :meth:`sort`, like Python standard list "
"objects.  Finally, sequence types should implement addition (meaning "
"concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, :meth:"
"`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; they "
"should not define :meth:`__coerce__` or other numerical operators.  It is "
"recommended that both mappings and sequences implement the :meth:"
"`__contains__` method to allow efficient use of the ``in`` operator; for "
"mappings, ``in`` should be equivalent of :meth:`has_key`; for sequences, it "
"should search through the values.  It is further recommended that both "
"mappings and sequences implement the :meth:`__iter__` method to allow "
"efficient iteration through the container; for mappings, :meth:`__iter__` "
"should be the same as :meth:`iterkeys`; for sequences, it should iterate "
"through the values."
msgstr ""

#: reference/datamodel.rst:1886
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__nonzero__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""

#: reference/datamodel.rst:1896
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""

#: reference/datamodel.rst:1907
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""

#: reference/datamodel.rst:1913
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""

#: reference/datamodel.rst:1919
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""

#: reference/datamodel.rst:1928
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""

#: reference/datamodel.rst:1937
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container, and should also be made available as the method :meth:"
"`iterkeys`."
msgstr ""

#: reference/datamodel.rst:1942
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see :ref:"
"`typeiter`."
msgstr ""

#: reference/datamodel.rst:1948
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""

#: reference/datamodel.rst:1952
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""

#: reference/datamodel.rst:1961
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr ""

#: reference/datamodel.rst:1968
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""

#: reference/datamodel.rst:1972
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""

#: reference/datamodel.rst:1981
msgid "Additional methods for emulation of sequence types"
msgstr ""

#: reference/datamodel.rst:1983
msgid ""
"The following optional methods can be defined to further emulate sequence "
"objects.  Immutable sequences methods should at most only define :meth:"
"`__getslice__`; mutable sequences might define all three methods."
msgstr ""

#: reference/datamodel.rst:1990
msgid ""
"Support slice objects as parameters to the :meth:`__getitem__` method. "
"(However, built-in types in CPython currently still implement :meth:"
"`__getslice__`.  Therefore, you have to override it in derived classes when "
"implementing slicing.)"
msgstr ""

#: reference/datamodel.rst:1996
msgid ""
"Called to implement evaluation of ``self[i:j]``. The returned object should "
"be of the same type as *self*.  Note that missing *i* or *j* in the slice "
"expression are replaced by zero or :attr:`sys.maxsize`, respectively.  If "
"negative indexes are used in the slice, the length of the sequence is added "
"to that index. If the instance does not implement the :meth:`__len__` "
"method, an :exc:`AttributeError` is raised. No guarantee is made that "
"indexes adjusted this way are not still negative.  Indexes which are greater "
"than the length of the sequence are not modified. If no :meth:`__getslice__` "
"is found, a slice object is created instead, and passed to :meth:"
"`__getitem__` instead."
msgstr ""

#: reference/datamodel.rst:2009
msgid ""
"Called to implement assignment to ``self[i:j]``. Same notes for *i* and *j* "
"as for :meth:`__getslice__`."
msgstr ""

#: reference/datamodel.rst:2012
msgid ""
"This method is deprecated. If no :meth:`__setslice__` is found, or for "
"extended slicing of the form ``self[i:j:k]``, a slice object is created, and "
"passed to :meth:`__setitem__`, instead of :meth:`__setslice__` being called."
msgstr ""

#: reference/datamodel.rst:2019
msgid ""
"Called to implement deletion of ``self[i:j]``. Same notes for *i* and *j* as "
"for :meth:`__getslice__`. This method is deprecated. If no :meth:"
"`__delslice__` is found, or for extended slicing of the form ``self[i:j:"
"k]``, a slice object is created, and passed to :meth:`__delitem__`, instead "
"of :meth:`__delslice__` being called."
msgstr ""

#: reference/datamodel.rst:2025
msgid ""
"Notice that these methods are only invoked when a single slice with a single "
"colon is used, and the slice method is available.  For slice operations "
"involving extended slice notation, or in absence of the slice methods, :meth:"
"`__getitem__`, :meth:`__setitem__` or :meth:`__delitem__` is called with a "
"slice object as argument."
msgstr ""

#: reference/datamodel.rst:2031
msgid ""
"The following example demonstrate how to make your program or module "
"compatible with earlier versions of Python (assuming that methods :meth:"
"`__getitem__`, :meth:`__setitem__` and :meth:`__delitem__` support slice "
"objects as arguments)::"
msgstr ""

#: reference/datamodel.rst:2056
msgid ""
"Note the calls to :func:`max`; these are necessary because of the handling "
"of negative indices before the :meth:`__\\*slice__` methods are called.  "
"When negative indexes are used, the :meth:`__\\*item__` methods receive them "
"as provided, but the :meth:`__\\*slice__` methods get a \"cooked\" form of "
"the index values.  For each negative index value, the length of the sequence "
"is added to the index before calling the method (which may still result in a "
"negative index); this is the customary handling of negative indexes by the "
"built-in sequence types, and the :meth:`__\\*item__` methods are expected to "
"do this as well.  However, since they should already be doing that, negative "
"indexes cannot be passed in; they must be constrained to the bounds of the "
"sequence before being passed to the :meth:`__\\*item__` methods. Calling "
"``max(0, i)`` conveniently returns the proper value."
msgstr ""

#: reference/datamodel.rst:2073
msgid "Emulating numeric types"
msgstr ""

#: reference/datamodel.rst:2075
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""

#: reference/datamodel.rst:2099
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an :meth:"
"`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method "
"should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; "
"it should not be related to :meth:`__truediv__` (described below).  Note "
"that :meth:`__pow__` should be defined to accept an optional third argument "
"if the ternary version of the built-in :func:`pow` function is to be "
"supported."
msgstr ""

#: reference/datamodel.rst:2109
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""

#: reference/datamodel.rst:2116
msgid ""
"The division operator (``/``) is implemented by these methods.  The :meth:"
"`__truediv__` method is used when ``__future__.division`` is in effect, "
"otherwise :meth:`__div__` is used.  If only one of these two methods is "
"defined, the object will not support division in the alternate context; :exc:"
"`TypeError` will be raised instead."
msgstr ""

#: reference/datamodel.rst:2142
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``/``, ``%``, :func:`divmod`, :func:`pow`, ``**``, "
"``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) operands.  "
"These functions are only called if the left operand does not support the "
"corresponding operation and the operands are of different types. [#]_ For "
"instance, to evaluate the expression ``x - y``, where *y* is an instance of "
"a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` is called if "
"``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""

#: reference/datamodel.rst:2153
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""

#: reference/datamodel.rst:2158
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr ""

#: reference/datamodel.rst:2178
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, "
"``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation "
"in-place (modifying *self*) and return the result (which could be, but does "
"not have to be, *self*).  If a specific method is not defined, the augmented "
"assignment falls back to the normal methods.  For instance, to execute the "
"statement ``x += y``, where *x* is an instance of a class that has an :meth:"
"`__iadd__` method, ``x.__iadd__(y)`` is called.  If *x* is an instance of a "
"class that does not define a :meth:`__iadd__` method, ``x.__add__(y)`` and "
"``y.__radd__(x)`` are considered, as with the evaluation of ``x + y``."
msgstr ""

#: reference/datamodel.rst:2197
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""

#: reference/datamodel.rst:2212
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, :"
"func:`long`, and :func:`float`.  Should return a value of the appropriate "
"type."
msgstr ""

#: reference/datamodel.rst:2223
msgid ""
"Called to implement the built-in functions :func:`oct` and :func:`hex`.  "
"Should return a string value."
msgstr ""

#: reference/datamodel.rst:2229
msgid ""
"Called to implement :func:`operator.index`.  Also called whenever Python "
"needs an integer object (such as in slicing).  Must return an integer (int "
"or long)."
msgstr ""

#: reference/datamodel.rst:2237
msgid ""
"Called to implement \"mixed-mode\" numeric arithmetic.  Should either return "
"a 2-tuple containing *self* and *other* converted to a common numeric type, "
"or ``None`` if conversion is impossible.  When the common type would be the "
"type of ``other``, it is sufficient to return ``None``, since the "
"interpreter will also ask the other object to attempt a coercion (but "
"sometimes, if the implementation of the other type cannot be changed, it is "
"useful to do the conversion to the other type here).  A return value of "
"``NotImplemented`` is equivalent to returning ``None``."
msgstr ""

#: reference/datamodel.rst:2250
msgid "Coercion rules"
msgstr ""

#: reference/datamodel.rst:2252
msgid ""
"This section used to document the rules for coercion.  As the language has "
"evolved, the coercion rules have become hard to document precisely; "
"documenting what one version of one particular implementation does is "
"undesirable.  Instead, here are some informal guidelines regarding "
"coercion.  In Python 3, coercion will not be supported."
msgstr ""

#: reference/datamodel.rst:2260
msgid ""
"If the left operand of a % operator is a string or Unicode object, no "
"coercion takes place and the string formatting operation is invoked instead."
msgstr ""

#: reference/datamodel.rst:2265
msgid ""
"It is no longer recommended to define a coercion operation. Mixed-mode "
"operations on types that don't define coercion pass the original arguments "
"to the operation."
msgstr ""

#: reference/datamodel.rst:2271
msgid ""
"New-style classes (those derived from :class:`object`) never invoke the :"
"meth:`__coerce__` method in response to a binary operator; the only time :"
"meth:`__coerce__` is invoked is when the built-in function :func:`coerce` is "
"called."
msgstr ""

#: reference/datamodel.rst:2278
msgid ""
"For most intents and purposes, an operator that returns ``NotImplemented`` "
"is treated the same as one that is not implemented at all."
msgstr ""

#: reference/datamodel.rst:2283
msgid ""
"Below, :meth:`__op__` and :meth:`__rop__` are used to signify the generic "
"method names corresponding to an operator; :meth:`__iop__` is used for the "
"corresponding in-place operator.  For example, for the operator '``+``', :"
"meth:`__add__` and :meth:`__radd__` are used for the left and right variant "
"of the binary operator, and :meth:`__iadd__` for the in-place variant."
msgstr ""

#: reference/datamodel.rst:2291
msgid ""
"For objects *x* and *y*, first ``x.__op__(y)`` is tried.  If this is not "
"implemented or returns ``NotImplemented``, ``y.__rop__(x)`` is tried.  If "
"this is also not implemented or returns ``NotImplemented``, a :exc:"
"`TypeError` exception is raised.  But see the following exception:"
msgstr ""

#: reference/datamodel.rst:2298
msgid ""
"Exception to the previous item: if the left operand is an instance of a "
"built-in type or a new-style class, and the right operand is an instance of "
"a proper subclass of that type or class and overrides the base's :meth:"
"`__rop__` method, the right operand's :meth:`__rop__` method is tried "
"*before* the left operand's :meth:`__op__` method."
msgstr ""

#: reference/datamodel.rst:2304
msgid ""
"This is done so that a subclass can completely override binary operators. "
"Otherwise, the left operand's :meth:`__op__` method would always accept the "
"right operand: when an instance of a given class is expected, an instance of "
"a subclass of that class is always acceptable."
msgstr ""

#: reference/datamodel.rst:2311
msgid ""
"When either operand type defines a coercion, this coercion is called before "
"that type's :meth:`__op__` or :meth:`__rop__` method is called, but no "
"sooner.  If the coercion returns an object of a different type for the "
"operand whose coercion is invoked, part of the process is redone using the "
"new object."
msgstr ""

#: reference/datamodel.rst:2318
msgid ""
"When an in-place operator (like '``+=``') is used, if the left operand "
"implements :meth:`__iop__`, it is invoked without any coercion.  When the "
"operation falls back to :meth:`__op__` and/or :meth:`__rop__`, the normal "
"coercion rules apply."
msgstr ""

#: reference/datamodel.rst:2325
msgid ""
"In ``x + y``, if *x* is a sequence that implements sequence concatenation, "
"sequence concatenation is invoked."
msgstr ""

#: reference/datamodel.rst:2330
msgid ""
"In ``x * y``, if one operand is a sequence that implements sequence "
"repetition, and the other is an integer (:class:`int` or :class:`long`), "
"sequence repetition is invoked."
msgstr ""

#: reference/datamodel.rst:2336
msgid ""
"Rich comparisons (implemented by methods :meth:`__eq__` and so on) never use "
"coercion.  Three-way comparison (implemented by :meth:`__cmp__`) does use "
"coercion under the same conditions as other binary operations use it."
msgstr ""

#: reference/datamodel.rst:2342
msgid ""
"In the current implementation, the built-in numeric types :class:`int`, :"
"class:`long`, :class:`float`, and :class:`complex` do not use coercion. All "
"these types implement a :meth:`__coerce__` method, for use by the built-in :"
"func:`coerce` function."
msgstr ""

#: reference/datamodel.rst:2349
msgid ""
"The complex type no longer makes implicit calls to the :meth:`__coerce__` "
"method for mixed-type binary arithmetic operations."
msgstr ""

#: reference/datamodel.rst:2356
msgid "With Statement Context Managers"
msgstr ""

#: reference/datamodel.rst:2360
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""

#: reference/datamodel.rst:2371
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""

#: reference/datamodel.rst:2374
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""

#: reference/datamodel.rst:2379
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`as` clause of the statement, if any."
msgstr ""

#: reference/datamodel.rst:2386
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""

#: reference/datamodel.rst:2390
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""

#: reference/datamodel.rst:2394
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""

#: reference/datamodel.rst:2408
msgid "Special method lookup for old-style classes"
msgstr ""

#: reference/datamodel.rst:2410
msgid ""
"For old-style classes, special methods are always looked up in exactly the "
"same way as any other method or attribute. This is the case regardless of "
"whether the method is being looked up explicitly as in ``x.__getitem__(i)`` "
"or implicitly as in ``x[i]``."
msgstr ""

#: reference/datamodel.rst:2415
msgid ""
"This behaviour means that special methods may exhibit different behaviour "
"for different instances of a single old-style class if the appropriate "
"special attributes are set differently::"
msgstr ""

#: reference/datamodel.rst:2435
msgid "Special method lookup for new-style classes"
msgstr ""

#: reference/datamodel.rst:2437
msgid ""
"For new-style classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception (unlike the equivalent example with old-"
"style classes)::"
msgstr ""

#: reference/datamodel.rst:2452
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""

#: reference/datamodel.rst:2465
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""

#: reference/datamodel.rst:2474
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""

#: reference/datamodel.rst:2501
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""

#: reference/datamodel.rst:2510
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""

#: reference/datamodel.rst:2514
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which "
"is why the reflected method is not called."
msgstr ""

#: reference/executionmodel.rst:6
msgid "Execution model"
msgstr ""

#: reference/executionmodel.rst:14
msgid "Naming and binding"
msgstr ""

#: reference/executionmodel.rst:25
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations. Each occurrence of a name in the program text refers to the :dfn:"
"`binding` of that name established in the innermost function block "
"containing the use."
msgstr ""

#: reference/executionmodel.rst:31
msgid ""
"A :dfn:`block` is a piece of Python program text that is executed as a unit. "
"The following are blocks: a module, a function body, and a class definition. "
"Each command typed interactively is a block.  A script file (a file given as "
"standard input to the interpreter or specified on the interpreter command "
"line the first argument) is a code block.  A script command (a command "
"specified on the interpreter command line with the '**-c**' option) is a "
"code block.  The file read by the built-in function :func:`execfile` is a "
"code block.  The string argument passed to the built-in function :func:"
"`eval` and to the :keyword:`exec` statement is a code block. The expression "
"read and evaluated by the built-in function :func:`input` is a code block."
msgstr ""

#: reference/executionmodel.rst:44
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""

#: reference/executionmodel.rst:50
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name.  The scope of names defined in a class block "
"is limited to the class block; it does not extend to the code blocks of "
"methods -- this includes generator expressions since they are implemented "
"using a function scope.  This means that the following will fail::"
msgstr ""

#: reference/executionmodel.rst:65
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""

#: reference/executionmodel.rst:71
msgid ""
"If a name is bound in a block, it is a local variable of that block. If a "
"name is bound at the module level, it is a global variable.  (The variables "
"of the module code block are local and global.)  If a variable is used in a "
"code block but not defined there, it is a :dfn:`free variable`."
msgstr ""

#: reference/executionmodel.rst:80
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised.  If "
"the name refers to a local variable that has not been bound, a :exc:"
"`UnboundLocalError` exception is raised.  :exc:`UnboundLocalError` is a "
"subclass of :exc:`NameError`."
msgstr ""

#: reference/executionmodel.rst:87
msgid ""
"The following constructs bind names: formal parameters to functions, :"
"keyword:`import` statements, class and function definitions (these bind the "
"class or function name in the defining block), and targets that are "
"identifiers if occurring in an assignment, :keyword:`for` loop header, in "
"the second position of an :keyword:`except` clause header or after :keyword:"
"`as` in a :keyword:`with` statement.  The :keyword:`import` statement of the "
"form ``from ... import *`` binds all names defined in the imported module, "
"except those beginning with an underscore.  This form may only be used at "
"the module level."
msgstr ""

#: reference/executionmodel.rst:97
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name).  It "
"is illegal to unbind a name that is referenced by an enclosing scope; the "
"compiler will report a :exc:`SyntaxError`."
msgstr ""

#: reference/executionmodel.rst:102
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""

#: reference/executionmodel.rst:105
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound. This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations."
msgstr ""

#: reference/executionmodel.rst:112
msgid ""
"If the global statement occurs within a block, all uses of the name "
"specified in the statement refer to the binding of that name in the top-"
"level namespace. Names are resolved in the top-level namespace by searching "
"the global namespace, i.e. the namespace of the module containing the code "
"block, and the builtins namespace, the namespace of the module :mod:"
"`__builtin__`.  The global namespace is searched first.  If the name is not "
"found there, the builtins namespace is searched.  The global statement must "
"precede all uses of the name."
msgstr ""

#: reference/executionmodel.rst:122
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`__builtin__` (note: no "
"'s'); when in any other module, ``__builtins__`` is an alias for the "
"dictionary of the :mod:`__builtin__` module itself.  ``__builtins__`` can be "
"set to a user-created dictionary to create a weak form of restricted "
"execution."
msgstr ""

#: reference/executionmodel.rst:133
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`__builtin__` (no 's') module and modify its "
"attributes appropriately."
msgstr ""

#: reference/executionmodel.rst:140
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""

#: reference/executionmodel.rst:143
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""

#: reference/executionmodel.rst:147
msgid ""
"A class definition is an executable statement that may use and define names. "
"These references follow the normal rules for name resolution. The namespace "
"of the class definition becomes the attribute dictionary of the class.  "
"Names defined at the class scope are not visible in methods."
msgstr ""

#: reference/executionmodel.rst:156
msgid "Interaction with dynamic features"
msgstr ""

#: reference/executionmodel.rst:158
msgid ""
"There are several cases where Python statements are illegal when used in "
"conjunction with nested scopes that contain free variables."
msgstr ""

#: reference/executionmodel.rst:161
msgid ""
"If a variable is referenced in an enclosing scope, it is illegal to delete "
"the name.  An error will be reported at compile time."
msgstr ""

#: reference/executionmodel.rst:164
msgid ""
"If the wild card form of import --- ``import *`` --- is used in a function "
"and the function contains or is a nested block with free variables, the "
"compiler will raise a :exc:`SyntaxError`."
msgstr ""

#: reference/executionmodel.rst:168
msgid ""
"If :keyword:`exec` is used in a function and the function contains or is a "
"nested block with free variables, the compiler will raise a :exc:"
"`SyntaxError` unless the exec explicitly specifies the local namespace for "
"the :keyword:`exec`.  (In other words, ``exec obj`` would be illegal, but "
"``exec obj in ns`` would be legal.)"
msgstr ""

#: reference/executionmodel.rst:174
msgid ""
"The :func:`eval`, :func:`execfile`, and :func:`input` functions and the :"
"keyword:`exec` statement do not have access to the full environment for "
"resolving names.  Names may be resolved in the local and global namespaces "
"of the caller.  Free variables are not resolved in the nearest enclosing "
"namespace, but in the global namespace. [#]_ The :keyword:`exec` statement "
"and the :func:`eval` and :func:`execfile` functions have optional arguments "
"to override the global and local namespace.  If only one namespace is "
"specified, it is used for both."
msgstr ""

#: reference/executionmodel.rst:187
msgid "Exceptions"
msgstr "Exceptions"

#: reference/executionmodel.rst:198
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""

#: reference/executionmodel.rst:204
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""

#: reference/executionmodel.rst:214
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""

#: reference/executionmodel.rst:221
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack backtrace, except when the exception is  :exc:"
"`SystemExit`."
msgstr ""

#: reference/executionmodel.rst:225
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a base class thereof.  The instance can be received "
"by the handler and can carry additional information about the exceptional "
"condition."
msgstr ""

#: reference/executionmodel.rst:230
msgid ""
"Exceptions can also be identified by strings, in which case the :keyword:"
"`except` clause is selected by object identity.  An arbitrary value can be "
"raised along with the identifying string which can be passed to the handler."
msgstr ""

#: reference/executionmodel.rst:236
msgid ""
"Messages to exceptions are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""

#: reference/executionmodel.rst:240
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""

#: reference/executionmodel.rst:245
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""

#: reference/expressions.rst:6
msgid "Expressions"
msgstr ""

#: reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""

#: reference/expressions.rst:14
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""

#: reference/expressions.rst:23
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""

#: reference/expressions.rst:30
msgid "Arithmetic conversions"
msgstr ""

#: reference/expressions.rst:34
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" the arguments are "
"coerced using the coercion rules listed at  :ref:`coercion-rules`.  If both "
"arguments are standard numeric types, the following coercions are applied:"
msgstr ""

#: reference/expressions.rst:39
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""

#: reference/expressions.rst:41
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""

#: reference/expressions.rst:44
msgid ""
"otherwise, if either argument is a long integer, the other is converted to "
"long integer;"
msgstr ""

#: reference/expressions.rst:47
msgid "otherwise, both must be plain integers and no conversion is necessary."
msgstr ""

#: reference/expressions.rst:49
msgid ""
"Some additional rules apply for certain operators (e.g., a string left "
"argument to the '%' operator). Extensions can define their own coercions."
msgstr ""

#: reference/expressions.rst:56
msgid "Atoms"
msgstr ""

#: reference/expressions.rst:60
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in reverse quotes or in "
"parentheses, brackets or braces are also categorized syntactically as "
"atoms.  The syntax for atoms is:"
msgstr ""

#: reference/expressions.rst:75
msgid "Identifiers (Names)"
msgstr ""

#: reference/expressions.rst:81
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""

#: reference/expressions.rst:87
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""

#: reference/expressions.rst:95
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""

#: reference/expressions.rst:112 reference/lexical_analysis.rst:405
msgid "Literals"
msgstr ""

#: reference/expressions.rst:116
msgid "Python supports string literals and various numeric literals:"
msgstr ""

#: reference/expressions.rst:122
msgid ""
"Evaluation of a literal yields an object of the given type (string, integer, "
"long integer, floating point number, complex number) with the given value.  "
"The value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: reference/expressions.rst:131
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""

#: reference/expressions.rst:141
msgid "Parenthesized forms"
msgstr ""

#: reference/expressions.rst:145
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""

#: reference/expressions.rst:150
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""

#: reference/expressions.rst:156
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the rules for literals apply (i.e., two occurrences of the empty "
"tuple may or may not yield the same object)."
msgstr ""

#: reference/expressions.rst:164
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""

#: reference/expressions.rst:173
msgid "List displays"
msgstr ""

#: reference/expressions.rst:179
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""

#: reference/expressions.rst:196
msgid ""
"A list display yields a new list object.  Its contents are specified by "
"providing either a list of expressions or a list comprehension.  When a "
"comma-separated list of expressions is supplied, its elements are evaluated "
"from left to right and placed into the list object in that order.  When a "
"list comprehension is supplied, it consists of a single expression followed "
"by at least one :keyword:`for` clause and zero or more :keyword:`for` or :"
"keyword:`if` clauses.  In this case, the elements of the new list are those "
"that would be produced by considering each of the :keyword:`for` or :keyword:"
"`if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce a list element each time the innermost block is "
"reached [#]_."
msgstr ""

#: reference/expressions.rst:211
msgid "Displays for sets and dictionaries"
msgstr ""

#: reference/expressions.rst:213
msgid ""
"For constructing a set or a dictionary Python provides special syntax called "
"\"displays\", each of them in two flavors:"
msgstr ""

#: reference/expressions.rst:216
msgid "either the container contents are listed explicitly, or"
msgstr ""

#: reference/expressions.rst:218
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""

#: reference/expressions.rst:221
msgid "Common syntax elements for comprehensions are:"
msgstr ""

#: reference/expressions.rst:229
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if` "
"clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr ""

#: reference/expressions.rst:236
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr ""

#: reference/expressions.rst:243
#, fuzzy
msgid "Generator expressions"
msgstr "Expressions et générateurs"

#: reference/expressions.rst:248
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""

#: reference/expressions.rst:253
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""

#: reference/expressions.rst:257
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`__next__` method is called for generator object (in the same fashion "
"as normal generators).  However, the leftmost :keyword:`for` clause is "
"immediately evaluated, so that an error produced by it can be seen before "
"any other possible error in the code that handles the generator expression.  "
"Subsequent :keyword:`for` clauses cannot be evaluated immediately since they "
"may depend on the previous :keyword:`for` loop. For example: ``(x*y for x in "
"range(10) for y in bar(x))``."
msgstr ""

#: reference/expressions.rst:266
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for the detail."
msgstr ""

#: reference/expressions.rst:272
msgid "Dictionary displays"
msgstr ""

#: reference/expressions.rst:278
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""

#: reference/expressions.rst:287
msgid "A dictionary display yields a new dictionary object."
msgstr ""

#: reference/expressions.rst:289
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""

#: reference/expressions.rst:295
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""

#: reference/expressions.rst:303
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""

#: reference/expressions.rst:313
msgid "Set displays"
msgstr ""

#: reference/expressions.rst:318
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""

#: reference/expressions.rst:324
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""

#: reference/expressions.rst:330
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""

#: reference/expressions.rst:337
msgid "String conversions"
msgstr ""

#: reference/expressions.rst:345
msgid ""
"A string conversion is an expression list enclosed in reverse (a.k.a. "
"backward) quotes:"
msgstr ""

#: reference/expressions.rst:351
msgid ""
"A string conversion evaluates the contained expression list and converts the "
"resulting object into a string according to rules specific to its type."
msgstr ""

#: reference/expressions.rst:354
msgid ""
"If the object is a string, a number, ``None``, or a tuple, list or "
"dictionary containing only objects whose type is one of these, the resulting "
"string is a valid Python expression which can be passed to the built-in "
"function :func:`eval` to yield an expression with the same value (or an "
"approximation, if floating point numbers are involved)."
msgstr ""

#: reference/expressions.rst:360
msgid ""
"(In particular, converting a string adds quotes around it and converts "
"\"funny\" characters to escape sequences that are safe to print.)"
msgstr ""

#: reference/expressions.rst:365
msgid ""
"Recursive objects (for example, lists or dictionaries that contain a "
"reference to themselves, directly or indirectly) use ``...`` to indicate a "
"recursive reference, and the result cannot be passed to :func:`eval` to get "
"an equal value (:exc:`SyntaxError` will be raised instead)."
msgstr ""

#: reference/expressions.rst:374
msgid ""
"The built-in function :func:`repr` performs exactly the same conversion in "
"its argument as enclosing it in parentheses and reverse quotes does.  The "
"built-in function :func:`str` performs a similar but more user-friendly "
"conversion."
msgstr ""

#: reference/expressions.rst:382
msgid "Yield expressions"
msgstr ""

#: reference/expressions.rst:395
msgid ""
"The :keyword:`yield` expression is only used when defining a generator "
"function, and can only be used in the body of a function definition. Using "
"a :keyword:`yield` expression in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""

#: reference/expressions.rst:400
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of a generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first :keyword:`yield` "
"expression, where it is suspended again, returning the value of :token:"
"`expression_list` to generator's caller.  By suspended we mean that all "
"local state is retained, including the current bindings of local variables, "
"the instruction pointer, and the internal evaluation stack.  When the "
"execution is resumed by calling one of the generator's methods, the function "
"can proceed exactly as if the :keyword:`yield` expression was just another "
"external call. The value of the :keyword:`yield` expression after resuming "
"depends on the method which resumed the execution."
msgstr ""

#: reference/expressions.rst:415
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where should the execution continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""

#: reference/expressions.rst:425
msgid "Generator-iterator methods"
msgstr ""

#: reference/expressions.rst:427
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""

#: reference/expressions.rst:430
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""

#: reference/expressions.rst:438
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed :keyword:`yield` expression.  When a generator function is resumed "
"with a :meth:`~generator.next` method, the current :keyword:`yield` "
"expression always evaluates to :const:`None`.  The execution then continues "
"to the next :keyword:`yield` expression, where the generator is suspended "
"again, and the value of the :token:`expression_list` is returned to :meth:"
"`~generator.next`'s caller. If the generator exits without yielding another "
"value, a :exc:`StopIteration` exception is raised."
msgstr ""

#: reference/expressions.rst:451
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The ``value`` argument becomes the result of the current :keyword:`yield` "
"expression.  The :meth:`send` method returns the next value yielded by the "
"generator, or raises :exc:`StopIteration` if the generator exits without "
"yielding another value. When :meth:`send` is called to start the generator, "
"it must be called with :const:`None` as the argument, because there is no :"
"keyword:`yield` expression that could receive the value."
msgstr ""

#: reference/expressions.rst:462
msgid ""
"Raises an exception of type ``type`` at the point where generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in "
"exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""

#: reference/expressions.rst:473
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then raises :exc:`StopIteration` (by "
"exiting normally, or due to already being closed) or :exc:`GeneratorExit` "
"(by not catching the exception), close returns to its caller.  If the "
"generator yields a value, a :exc:`RuntimeError` is raised.  If the generator "
"raises any other exception, it is propagated to the caller.  :meth:`close` "
"does nothing if the generator has already exited due to an exception or "
"normal exit."
msgstr ""

#: reference/expressions.rst:481
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""

#: reference/expressions.rst:512 reference/simple_stmts.rst:545
msgid "PEP 0342 - Coroutines via Enhanced Generators"
msgstr ""

#: reference/expressions.rst:512
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""

#: reference/expressions.rst:519
msgid "Primaries"
msgstr ""

#: reference/expressions.rst:523
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""

#: reference/expressions.rst:533
msgid "Attribute references"
msgstr ""

#: reference/expressions.rst:537
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""

#: reference/expressions.rst:547
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, e.g., a module, list, or an instance.  This object is then asked "
"to produce the attribute whose name is the identifier.  If this attribute is "
"not available, the exception :exc:`AttributeError` is raised. Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""

#: reference/expressions.rst:558
msgid "Subscriptions"
msgstr ""

#: reference/expressions.rst:571
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""

#: reference/expressions.rst:577
msgid "The primary must evaluate to an object of a sequence or mapping type."
msgstr ""

#: reference/expressions.rst:579
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list "
"is a tuple except if it has exactly one item.)"
msgstr ""

#: reference/expressions.rst:584
msgid ""
"If the primary is a sequence, the expression (list) must evaluate to a plain "
"integer.  If this value is negative, the length of the sequence is added to "
"it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting "
"value must be a nonnegative integer less than the number of items in the "
"sequence, and the subscription selects the item whose index is that value "
"(counting from zero)."
msgstr ""

#: reference/expressions.rst:595
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr ""

#: reference/expressions.rst:602
msgid "Slicings"
msgstr ""

#: reference/expressions.rst:614
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""

#: reference/expressions.rst:634
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice nor ellipses).  "
"Similarly, when the slice list has exactly one short slice and no trailing "
"comma, the interpretation as a simple slicing takes priority over that as an "
"extended slicing."
msgstr ""

#: reference/expressions.rst:643
msgid ""
"The semantics for a simple slicing are as follows.  The primary must "
"evaluate to a sequence object.  The lower and upper bound expressions, if "
"present, must evaluate to plain integers; defaults are zero and the ``sys."
"maxint``, respectively.  If either bound is negative, the sequence's length "
"is added to it.  The slicing now selects all items with index *k* such that "
"``i <= k < j`` where *i* and *j* are the specified lower and upper bounds.  "
"This may be an empty sequence.  It is not an error if *i* or *j* lie outside "
"the range of valid indexes (such items don't exist so they aren't selected)."
msgstr ""

#: reference/expressions.rst:657
msgid ""
"The semantics for an extended slicing are as follows.  The primary must "
"evaluate to a mapping object, and it is indexed with a key that is "
"constructed from the slice list, as follows.  If the slice list contains at "
"least one comma, the key is a tuple containing the conversion of the slice "
"items; otherwise, the conversion of the lone slice item is the key.  The "
"conversion of a slice item that is an expression is that expression.  The "
"conversion of an ellipsis slice item is the built-in ``Ellipsis`` object.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""

#: reference/expressions.rst:678
msgid "Calls"
msgstr "Appels"

#: reference/expressions.rst:680
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""

#: reference/expressions.rst:697
msgid ""
"A trailing comma may be present after the positional and keyword arguments "
"but does not affect the semantics."
msgstr ""

#: reference/expressions.rst:703
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and certain class instances themselves are callable; "
"extensions may define additional callable object types).  All argument "
"expressions are evaluated before the call is attempted.  Please refer to "
"section :ref:`function` for the syntax of formal :term:`parameter` lists."
msgstr ""

#: reference/expressions.rst:710
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""

#: reference/expressions.rst:730
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""

#: reference/expressions.rst:736
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""

#: reference/expressions.rst:742
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""

#: reference/expressions.rst:752
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an iterable.  Elements from this iterable are treated as if "
"they were additional positional arguments; if there are positional arguments "
"*x1*, ..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, "
"*y1*, ..., *yM*."
msgstr ""

#: reference/expressions.rst:759
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* some keyword arguments, it is processed *before* the keyword "
"arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""

#: reference/expressions.rst:775
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""

#: reference/expressions.rst:781
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a mapping, the contents of which are treated as additional "
"keyword arguments.  In the case of a keyword appearing in both "
"``expression`` and as an explicit keyword argument, a :exc:`TypeError` "
"exception is raised."
msgstr ""

#: reference/expressions.rst:786
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names.  "
"Formal parameters using the syntax ``(sublist)`` cannot be used as keyword "
"argument names; the outermost sublist corresponds to a single unnamed "
"argument slot, and the argument value is assigned to the sublist using the "
"usual tuple assignment rules after all other parameter processing is done."
msgstr ""

#: reference/expressions.rst:793
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""

#: reference/expressions.rst:797
msgid "If it is---"
msgstr ""

#: reference/expressions.rst:810
msgid "a user-defined function:"
msgstr ""

#: reference/expressions.rst:806
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""

#: reference/expressions.rst:824
msgid "a built-in function or method:"
msgstr ""

#: reference/expressions.rst:823
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""

#: reference/expressions.rst:831
msgid "a class object:"
msgstr ""

#: reference/expressions.rst:831
msgid "A new instance of that class is returned."
msgstr ""

#: reference/expressions.rst:841
msgid "a class instance method:"
msgstr ""

#: reference/expressions.rst:839
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""

#: reference/expressions.rst:850
msgid "a class instance:"
msgstr ""

#: reference/expressions.rst:848
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""

#: reference/expressions.rst:855
msgid "The power operator"
msgstr ""

#: reference/expressions.rst:857
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""

#: reference/expressions.rst:863
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""

#: reference/expressions.rst:867
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type.  The result type is that of the arguments after "
"coercion."
msgstr ""

#: reference/expressions.rst:872
msgid ""
"With mixed operand types, the coercion rules for binary arithmetic operators "
"apply. For int and long int operands, the result has the same type as the "
"operands (after coercion) unless the second argument is negative; in that "
"case, all arguments are converted to float and a float result is delivered. "
"For example, ``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``. "
"(This last feature was added in Python 2.2. In Python 2.1 and before, if "
"both arguments were of integer types and the second argument was negative, "
"an exception was raised)."
msgstr ""

#: reference/expressions.rst:881
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :exc:"
"`ValueError`."
msgstr ""

#: reference/expressions.rst:888
msgid "Unary arithmetic and bitwise operations"
msgstr ""

#: reference/expressions.rst:894
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""

#: reference/expressions.rst:903
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""

#: reference/expressions.rst:907
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""

#: reference/expressions.rst:911
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its plain "
"or long integer argument.  The bitwise inversion of ``x`` is defined as ``-(x"
"+1)``.  It only applies to integral numbers."
msgstr ""

#: reference/expressions.rst:917
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""

#: reference/expressions.rst:924
msgid "Binary arithmetic operations"
msgstr ""

#: reference/expressions.rst:928
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""

#: reference/expressions.rst:940
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer (plain or long) and the other must be a sequence. In the former "
"case, the numbers are converted to a common type and then multiplied "
"together.  In the latter case, sequence repetition is performed; a negative "
"repetition factor yields an empty sequence."
msgstr ""

#: reference/expressions.rst:951
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Plain or long integer division yields an integer of the same "
"type; the result is that of mathematical division with the 'floor' function "
"applied to the result. Division by zero raises the :exc:`ZeroDivisionError` "
"exception."
msgstr ""

#: reference/expressions.rst:959
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""

#: reference/expressions.rst:968
msgid ""
"The integer division and modulo operators are connected by the following "
"identity: ``x == (x/y)*y + (x%y)``.  Integer division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x/y, "
"x%y)``.  These identities don't hold for floating point numbers; there "
"similar identities hold approximately where ``x/y`` is replaced by ``floor(x/"
"y)`` or ``floor(x/y) - 1`` [#]_."
msgstr ""

#: reference/expressions.rst:975
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string and unicode objects to perform string "
"formatting (also known as interpolation). The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`string-"
"formatting`."
msgstr ""

#: reference/expressions.rst:980
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are no longer defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: reference/expressions.rst:987
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments. The arguments "
"must either both be numbers or both sequences of the same type.  In the "
"former case, the numbers are converted to a common type and then added "
"together.  In the latter case, the sequences are concatenated."
msgstr ""

#: reference/expressions.rst:994
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""

#: reference/expressions.rst:1001
msgid "Shifting operations"
msgstr ""

#: reference/expressions.rst:1005
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""

#: reference/expressions.rst:1010
msgid ""
"These operators accept plain or long integers as arguments.  The arguments "
"are converted to a common type.  They shift the first argument to the left "
"or right by the number of bits given by the second argument."
msgstr ""

#: reference/expressions.rst:1016
msgid ""
"A right shift by *n* bits is defined as division by ``pow(2, n)``.  A left "
"shift by *n* bits is defined as multiplication with ``pow(2, n)``.  Negative "
"shift counts raise a :exc:`ValueError` exception."
msgstr ""

#: reference/expressions.rst:1022
msgid ""
"In the current implementation, the right-hand operand is required to be at "
"most :attr:`sys.maxsize`.  If the right-hand operand is larger than :attr:"
"`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""

#: reference/expressions.rst:1029
msgid "Binary bitwise operations"
msgstr ""

#: reference/expressions.rst:1033
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""

#: reference/expressions.rst:1042
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"plain or long integers.  The arguments are converted to a common type."
msgstr ""

#: reference/expressions.rst:1049
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be plain or long integers.  The arguments are converted to a "
"common type."
msgstr ""

#: reference/expressions.rst:1056
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be plain or long integers.  The arguments are converted to a common "
"type."
msgstr ""

#: reference/expressions.rst:1067
msgid "Comparisons"
msgstr ""

#: reference/expressions.rst:1073
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""

#: reference/expressions.rst:1083
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""

#: reference/expressions.rst:1087
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""

#: reference/expressions.rst:1091
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""

#: reference/expressions.rst:1096
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""

#: reference/expressions.rst:1100
msgid ""
"The forms ``<>`` and ``!=`` are equivalent; for consistency with C, ``!=`` "
"is preferred; where ``!=`` is mentioned below ``<>`` is also accepted.  The "
"``<>`` spelling is considered obsolescent."
msgstr ""

#: reference/expressions.rst:1104
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects need not have the same type. If both are "
"numbers, they are converted to a common type.  Otherwise, objects of "
"different types *always* compare unequal, and are ordered consistently but "
"arbitrarily. You can control comparison behavior of objects of non-built-in "
"types by defining a ``__cmp__`` method or rich comparison methods like "
"``__gt__``, described in section :ref:`specialnames`."
msgstr ""

#: reference/expressions.rst:1112
msgid ""
"(This unusual definition of comparison was used to simplify the definition "
"of operations like sorting and the :keyword:`in` and :keyword:`not in` "
"operators. In the future, the comparison rules for objects of different "
"types are likely to change.)"
msgstr ""

#: reference/expressions.rst:1117
msgid "Comparison of objects of the same type depends on the type:"
msgstr ""

#: reference/expressions.rst:1119
msgid "Numbers are compared arithmetically."
msgstr ""

#: reference/expressions.rst:1121
msgid ""
"Strings are compared lexicographically using the numeric equivalents (the "
"result of the built-in function :func:`ord`) of their characters.  Unicode "
"and 8-bit strings are fully interoperable in this behavior. [#]_"
msgstr ""

#: reference/expressions.rst:1125
msgid ""
"Tuples and lists are compared lexicographically using comparison of "
"corresponding elements.  This means that to compare equal, each element must "
"compare equal and the two sequences must be of the same type and have the "
"same length."
msgstr ""

#: reference/expressions.rst:1130
msgid ""
"If not equal, the sequences are ordered the same as their first differing "
"elements.  For example, ``cmp([1,2,x], [1,2,y])`` returns the same as "
"``cmp(x,y)``.  If the corresponding element does not exist, the shorter "
"sequence is ordered first (for example, ``[1,2] < [1,2,3]``)."
msgstr ""

#: reference/expressions.rst:1135
msgid ""
"Mappings (dictionaries) compare equal if and only if their sorted (key, "
"value) lists compare equal. [#]_ Outcomes other than equality are resolved "
"consistently, but are not otherwise defined. [#]_"
msgstr ""

#: reference/expressions.rst:1139
msgid ""
"Most other objects of built-in types compare unequal unless they are the "
"same object; the choice whether one object is considered smaller or larger "
"than another one is made arbitrarily but consistently within one execution "
"of a program."
msgstr ""

#: reference/expressions.rst:1146
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for collection "
"membership.  ``x in s`` evaluates to true if *x* is a member of the "
"collection *s*, and false otherwise.  ``x not in s`` returns the negation of "
"``x in s``. The collection membership test has traditionally been bound to "
"sequences; an object is a member of a collection if the collection is a "
"sequence and contains an element equal to that object.  However, it make "
"sense for many other object types to support membership tests without being "
"a sequence.  In particular, dictionaries (for keys) and sets support "
"membership testing."
msgstr ""

#: reference/expressions.rst:1155
msgid ""
"For the list and tuple types, ``x in y`` is true if and only if there exists "
"an index *i* such that ``x == y[i]`` is true."
msgstr ""

#: reference/expressions.rst:1158
msgid ""
"For the Unicode and string types, ``x in y`` is true if and only if *x* is a "
"substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Note, *x* and "
"*y* need not be the same type; consequently, ``u'ab' in 'abc'`` will return "
"``True``. Empty strings are always considered to be a substring of any other "
"string, so ``\"\" in \"abc\"`` will return ``True``."
msgstr ""

#: reference/expressions.rst:1164
msgid "Previously, *x* was required to be a string of length ``1``."
msgstr ""

#: reference/expressions.rst:1167
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` is true if and only if ``y.__contains__(x)`` is true."
msgstr ""

#: reference/expressions.rst:1170
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is true if some value ``z`` with ``x == "
"z`` is produced while iterating over ``y``.  If an exception is raised "
"during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""

#: reference/expressions.rst:1175
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is true if and only if there is a non-negative "
"integer index *i* such that ``x == y[i]``, and all lower integer indices do "
"not raise :exc:`IndexError` exception. (If any other exception is raised, it "
"is as if :keyword:`in` raised that exception)."
msgstr ""

#: reference/expressions.rst:1187
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of :"
"keyword:`in`."
msgstr ""

#: reference/expressions.rst:1195
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr ""

#: reference/expressions.rst:1206
msgid "Boolean operations"
msgstr ""

#: reference/expressions.rst:1217
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  (See the :meth:"
"`~object.__nonzero__` special method for a way to change this.)"
msgstr ""

#: reference/expressions.rst:1226
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""

#: reference/expressions.rst:1231
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: reference/expressions.rst:1236
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: reference/expressions.rst:1239
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument. This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"invent a value anyway, it does not bother to return a value of the same type "
"as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr ""

#: reference/expressions.rst:1249
msgid "Conditional Expressions"
msgstr ""

#: reference/expressions.rst:1261
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""

#: reference/expressions.rst:1264
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* (*not* "
"*x*); if *C* is true, *x* is evaluated and its value is returned; otherwise, "
"*y* is evaluated and its value is returned."
msgstr ""

#: reference/expressions.rst:1268
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""

#: reference/expressions.rst:1275
msgid "Lambdas"
msgstr ""

#: reference/expressions.rst:1285
msgid ""
"Lambda expressions (sometimes called lambda forms) have the same syntactic "
"position as expressions.  They are a shorthand to create anonymous "
"functions; the expression ``lambda arguments: expression`` yields a function "
"object.  The unnamed object behaves like a function object defined with ::"
msgstr ""

#: reference/expressions.rst:1293
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements."
msgstr ""

#: reference/expressions.rst:1300
msgid "Expression lists"
msgstr ""

#: reference/expressions.rst:1309
msgid ""
"An expression list containing at least one comma yields a tuple.  The length "
"of the tuple is the number of expressions in the list.  The expressions are "
"evaluated from left to right."
msgstr ""

#: reference/expressions.rst:1315
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""

#: reference/expressions.rst:1325
msgid "Evaluation order"
msgstr ""

#: reference/expressions.rst:1329
msgid ""
"Python evaluates expressions from left to right. Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""

#: reference/expressions.rst:1332
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""

#: reference/expressions.rst:1346
msgid "Operator precedence"
msgstr ""

#: reference/expressions.rst:1350
msgid ""
"The following table summarizes the operator precedences in Python, from "
"lowest precedence (least binding) to highest precedence (most binding). "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for comparisons, including tests, which all have the "
"same precedence and chain from left to right --- see section :ref:"
"`comparisons` --- and exponentiation, which groups from right to left)."
msgstr ""

#: reference/expressions.rst:1359
msgid "Operator"
msgstr ""

#: reference/expressions.rst:1359
msgid "Description"
msgstr ""

#: reference/expressions.rst:1361
msgid ":keyword:`lambda`"
msgstr ""

#: reference/expressions.rst:1361
#, fuzzy
msgid "Lambda expression"
msgstr "Fonctions anonymes"

#: reference/expressions.rst:1363
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ""

#: reference/expressions.rst:1363
msgid "Conditional expression"
msgstr ""

#: reference/expressions.rst:1365
msgid ":keyword:`or`"
msgstr ""

#: reference/expressions.rst:1365
msgid "Boolean OR"
msgstr ""

#: reference/expressions.rst:1367
msgid ":keyword:`and`"
msgstr ""

#: reference/expressions.rst:1367
msgid "Boolean AND"
msgstr ""

#: reference/expressions.rst:1369
msgid ":keyword:`not` ``x``"
msgstr ""

#: reference/expressions.rst:1369
msgid "Boolean NOT"
msgstr ""

#: reference/expressions.rst:1371
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``<>``, ``!=``, ``==``"
msgstr ""

#: reference/expressions.rst:1371
msgid "Comparisons, including membership tests and identity tests"
msgstr ""

#: reference/expressions.rst:1375
msgid "``|``"
msgstr ""

#: reference/expressions.rst:1375
msgid "Bitwise OR"
msgstr ""

#: reference/expressions.rst:1377
msgid "``^``"
msgstr ""

#: reference/expressions.rst:1377
msgid "Bitwise XOR"
msgstr ""

#: reference/expressions.rst:1379
msgid "``&``"
msgstr ""

#: reference/expressions.rst:1379
msgid "Bitwise AND"
msgstr ""

#: reference/expressions.rst:1381
msgid "``<<``, ``>>``"
msgstr ""

#: reference/expressions.rst:1381
msgid "Shifts"
msgstr ""

#: reference/expressions.rst:1383
msgid "``+``, ``-``"
msgstr ""

#: reference/expressions.rst:1383
msgid "Addition and subtraction"
msgstr ""

#: reference/expressions.rst:1385
msgid "``*``, ``/``, ``//``, ``%``"
msgstr ""

#: reference/expressions.rst:1385
msgid "Multiplication, division, remainder [#]_"
msgstr ""

#: reference/expressions.rst:1388
msgid "``+x``, ``-x``, ``~x``"
msgstr ""

#: reference/expressions.rst:1388
msgid "Positive, negative, bitwise NOT"
msgstr ""

#: reference/expressions.rst:1390
msgid "``**``"
msgstr ""

#: reference/expressions.rst:1390
msgid "Exponentiation [#]_"
msgstr ""

#: reference/expressions.rst:1392
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""

#: reference/expressions.rst:1392
msgid "Subscription, slicing, call, attribute reference"
msgstr ""

#: reference/expressions.rst:1395
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"```expressions...```"
msgstr ""

#: reference/expressions.rst:1395
msgid ""
"Binding or tuple display, list display, dictionary display, string conversion"
msgstr ""

#: reference/expressions.rst:1403
msgid ""
"In Python 2.3 and later releases, a list comprehension \"leaks\" the control "
"variables of each ``for`` it contains into the containing scope.  However, "
"this behavior is deprecated, and relying on it will not work in Python 3."
msgstr ""

#: reference/expressions.rst:1407
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""

#: reference/expressions.rst:1416
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``floor(x/y)`` to be one larger than ``(x-x%y)/y`` due to rounding.  In such "
"cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""

#: reference/expressions.rst:1421
msgid ""
"While comparisons between unicode strings make sense at the byte level, they "
"may be counter-intuitive to users. For example, the strings ``u\"\\u00C7\"`` "
"and ``u\"\\u0043\\u0327\"`` compare differently, even though they both "
"represent the same unicode character (LATIN CAPITAL LETTER C WITH CEDILLA). "
"To compare strings in a human recognizable way, compare using :func:"
"`unicodedata.normalize`."
msgstr ""

#: reference/expressions.rst:1428
msgid ""
"The implementation computes this efficiently, without constructing lists or "
"sorting."
msgstr ""

#: reference/expressions.rst:1431
msgid ""
"Earlier versions of Python used lexicographic comparison of the sorted (key, "
"value) lists, but this was very expensive for the common case of comparing "
"for equality.  An even earlier version of Python compared dictionaries by "
"identity only, but this caused surprises because people expected to be able "
"to test a dictionary for emptiness by comparing it to ``{}``."
msgstr ""

#: reference/expressions.rst:1437
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""

#: reference/expressions.rst:1442
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""

#: reference/expressions.rst:1445
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""

#: reference/grammar.rst:2
msgid "Full Grammar specification"
msgstr ""

#: reference/grammar.rst:4
msgid ""
"This is the full Python grammar, as it is read by the parser generator and "
"used to parse Python source files:"
msgstr ""

#: reference/index.rst:5
msgid "The Python Language Reference"
msgstr ""

#: reference/index.rst:7
msgid ""
"This reference manual describes the syntax and \"core semantics\" of the "
"language. It is terse, but attempts to be exact and complete. The semantics "
"of non-essential built-in object types and of the built-in functions and "
"modules are described in :ref:`library-index`. For an informal introduction "
"to the language, see :ref:`tutorial-index`. For C or C++ programmers, two "
"additional manuals exist: :ref:`extending-index` describes the high-level "
"picture of how to write a Python extension module, and the :ref:`c-api-"
"index` describes the interfaces available to C/C++ programmers in detail."
msgstr ""

#: reference/introduction.rst:6
msgid "Introduction"
msgstr "Introduction"

#: reference/introduction.rst:8
msgid ""
"This reference manual describes the Python programming language. It is not "
"intended as a tutorial."
msgstr ""

#: reference/introduction.rst:11
msgid ""
"While I am trying to be as precise as possible, I chose to use English "
"rather than formal specifications for everything except syntax and lexical "
"analysis. This should make the document more understandable to the average "
"reader, but will leave room for ambiguities. Consequently, if you were "
"coming from Mars and tried to re-implement Python from this document alone, "
"you might have to guess things and in fact you would probably end up "
"implementing quite a different language. On the other hand, if you are using "
"Python and wonder what the precise rules about a particular area of the "
"language are, you should definitely be able to find them here. If you would "
"like to see a more formal definition of the language, maybe you could "
"volunteer your time --- or invent a cloning machine :-)."
msgstr ""

#: reference/introduction.rst:23
msgid ""
"It is dangerous to add too many implementation details to a language "
"reference document --- the implementation may change, and other "
"implementations of the same language may work differently.  On the other "
"hand, there is currently only one Python implementation in widespread use "
"(although alternate implementations exist), and its particular quirks are "
"sometimes worth being mentioned, especially where the implementation imposes "
"additional limitations.  Therefore, you'll find short \"implementation notes"
"\" sprinkled throughout the text."
msgstr ""

#: reference/introduction.rst:31
msgid ""
"Every Python implementation comes with a number of built-in and standard "
"modules.  These are documented in :ref:`library-index`.  A few built-in "
"modules are mentioned when they interact in a significant way with the "
"language definition."
msgstr ""

#: reference/introduction.rst:40
msgid "Alternate Implementations"
msgstr ""

#: reference/introduction.rst:42
msgid ""
"Though there is one Python implementation which is by far the most popular, "
"there are some alternate implementations which are of particular interest to "
"different audiences."
msgstr ""

#: reference/introduction.rst:46
msgid "Known implementations include:"
msgstr ""

#: reference/introduction.rst:50
msgid "CPython"
msgstr "CPython"

#: reference/introduction.rst:49
msgid ""
"This is the original and most-maintained implementation of Python, written "
"in C. New language features generally appear here first."
msgstr ""

#: reference/introduction.rst:56
msgid "Jython"
msgstr ""

#: reference/introduction.rst:53
msgid ""
"Python implemented in Java.  This implementation can be used as a scripting "
"language for Java applications, or can be used to create applications using "
"the Java class libraries.  It is also often used to create tests for Java "
"libraries. More information can be found at `the Jython website <http://www."
"jython.org/>`_."
msgstr ""

#: reference/introduction.rst:62
msgid "Python for .NET"
msgstr ""

#: reference/introduction.rst:59
msgid ""
"This implementation actually uses the CPython implementation, but is a "
"managed .NET application and makes .NET libraries available.  It was created "
"by Brian Lloyd.  For more information, see the `Python for .NET home page "
"<http://pythonnet.sourceforge.net>`_."
msgstr ""

#: reference/introduction.rst:68
msgid "IronPython"
msgstr ""

#: reference/introduction.rst:65
msgid ""
"An alternate Python for .NET.  Unlike Python.NET, this is a complete Python "
"implementation that generates IL, and compiles Python code directly to .NET "
"assemblies.  It was created by Jim Hugunin, the original creator of Jython.  "
"For more information, see `the IronPython website <http://ironpython.net/>`_."
msgstr ""

#: reference/introduction.rst:76
msgid "PyPy"
msgstr ""

#: reference/introduction.rst:71
msgid ""
"An implementation of Python written completely in Python. It supports "
"several advanced features not found in other implementations like stackless "
"support and a Just in Time compiler. One of the goals of the project is to "
"encourage experimentation with the language itself by making it easier to "
"modify the interpreter (since it is written in Python).  Additional "
"information is available on `the PyPy project's home page <http://pypy.org/"
">`_."
msgstr ""

#: reference/introduction.rst:78
msgid ""
"Each of these implementations varies in some way from the language as "
"documented in this manual, or introduces specific information beyond what's "
"covered in the standard Python documentation.  Please refer to the "
"implementation-specific documentation to determine what else you need to "
"know about the specific implementation you're using."
msgstr ""

#: reference/introduction.rst:88
msgid "Notation"
msgstr ""

#: reference/introduction.rst:96
msgid ""
"The descriptions of lexical analysis and syntax use a modified BNF grammar "
"notation.  This uses the following style of definition:"
msgstr ""

#: reference/introduction.rst:103
msgid ""
"The first line says that a ``name`` is an ``lc_letter`` followed by a "
"sequence of zero or more ``lc_letter``\\ s and underscores.  An "
"``lc_letter`` in turn is any of the single characters ``'a'`` through "
"``'z'``.  (This rule is actually adhered to for the names defined in lexical "
"and grammar rules in this document.)"
msgstr ""

#: reference/introduction.rst:108
msgid ""
"Each rule begins with a name (which is the name defined by the rule) and ``::"
"=``.  A vertical bar (``|``) is used to separate alternatives; it is the "
"least binding operator in this notation.  A star (``*``) means zero or more "
"repetitions of the preceding item; likewise, a plus (``+``) means one or "
"more repetitions, and a phrase enclosed in square brackets (``[ ]``) means "
"zero or one occurrences (in other words, the enclosed phrase is optional).  "
"The ``*`` and ``+`` operators bind as tightly as possible; parentheses are "
"used for grouping.  Literal strings are enclosed in quotes.  White space is "
"only meaningful to separate tokens. Rules are normally contained on a single "
"line; rules with many alternatives may be formatted alternatively with each "
"line after the first beginning with a vertical bar."
msgstr ""

#: reference/introduction.rst:124
msgid ""
"In lexical definitions (as the example above), two more conventions are "
"used: Two literal characters separated by three dots mean a choice of any "
"single character in the given (inclusive) range of ASCII characters.  A "
"phrase between angular brackets (``<...>``) gives an informal description of "
"the symbol defined; e.g., this could be used to describe the notion of "
"'control character' if needed."
msgstr ""

#: reference/introduction.rst:131
msgid ""
"Even though the notation used is almost the same, there is a big difference "
"between the meaning of lexical and syntactic definitions: a lexical "
"definition operates on the individual characters of the input source, while "
"a syntax definition operates on the stream of tokens generated by the "
"lexical analysis. All uses of BNF in the next chapter (\"Lexical Analysis\") "
"are lexical definitions; uses in subsequent chapters are syntactic "
"definitions."
msgstr ""

#: reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr ""

#: reference/lexical_analysis.rst:13
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""

#: reference/lexical_analysis.rst:17
msgid "Python uses the 7-bit ASCII character set for program text."
msgstr ""

#: reference/lexical_analysis.rst:19
msgid ""
"An encoding declaration can be used to indicate that  string literals and "
"comments use an encoding different from ASCII."
msgstr ""

#: reference/lexical_analysis.rst:23
msgid ""
"For compatibility with older versions, Python only warns if it finds 8-bit "
"characters; those warnings should be corrected by either declaring an "
"explicit encoding, or using escape sequences if those bytes are binary data, "
"instead of characters."
msgstr ""

#: reference/lexical_analysis.rst:28
msgid ""
"The run-time character set depends on the I/O devices connected to the "
"program but is generally a superset of ASCII."
msgstr ""

#: reference/lexical_analysis.rst:31
msgid ""
"**Future compatibility note:** It may be tempting to assume that the "
"character set for 8-bit characters is ISO Latin-1 (an ASCII superset that "
"covers most western languages that use the Latin alphabet), but it is "
"possible that in the future Unicode text editors will become common.  These "
"generally use the UTF-8 encoding, which is also an ASCII superset, but with "
"very different use for the characters with ordinals 128-255.  While there is "
"no consensus on this subject yet, it is unwise to assume either Latin-1 or "
"UTF-8, even though the current implementation appears to favor Latin-1.  "
"This applies both to the source character set and the run-time character set."
msgstr ""

#: reference/lexical_analysis.rst:45
msgid "Line structure"
msgstr ""

#: reference/lexical_analysis.rst:49
msgid "A Python program is divided into a number of *logical lines*."
msgstr ""

#: reference/lexical_analysis.rst:55
msgid "Logical lines"
msgstr ""

#: reference/lexical_analysis.rst:63
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""

#: reference/lexical_analysis.rst:73
msgid "Physical lines"
msgstr ""

#: reference/lexical_analysis.rst:75
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files, any of the standard platform line termination "
"sequences can be used - the Unix form using ASCII LF (linefeed), the Windows "
"form using the ASCII sequence CR LF (return followed by linefeed), or the "
"old Macintosh form using the ASCII CR (return) character.  All of these "
"forms can be used equally, regardless of platform."
msgstr ""

#: reference/lexical_analysis.rst:82
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""

#: reference/lexical_analysis.rst:90
msgid "Comments"
msgstr ""

#: reference/lexical_analysis.rst:96
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax; they are not tokens."
msgstr ""

#: reference/lexical_analysis.rst:105
msgid "Encoding declarations"
msgstr ""

#: reference/lexical_analysis.rst:109
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""

#: reference/lexical_analysis.rst:118
msgid "which is recognized also by GNU Emacs, and ::"
msgstr ""

#: reference/lexical_analysis.rst:122
msgid ""
"which is recognized by Bram Moolenaar's VIM. In addition, if the first bytes "
"of the file are the UTF-8 byte-order mark (``'\\xef\\xbb\\xbf'``), the "
"declared file encoding is UTF-8 (this is supported, among others, by "
"Microsoft's :program:`notepad`)."
msgstr ""

#: reference/lexical_analysis.rst:127
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, in particular to find the end "
"of a string, and to interpret the contents of Unicode literals. String "
"literals are converted to Unicode for syntactical analysis, then converted "
"back to their original encoding before interpretation starts."
msgstr ""

#: reference/lexical_analysis.rst:139
msgid "Explicit line joining"
msgstr ""

#: reference/lexical_analysis.rst:147
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""

#: reference/lexical_analysis.rst:158
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""

#: reference/lexical_analysis.rst:168
msgid "Implicit line joining"
msgstr ""

#: reference/lexical_analysis.rst:170
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""

#: reference/lexical_analysis.rst:178
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""

#: reference/lexical_analysis.rst:188
msgid "Blank lines"
msgstr ""

#: reference/lexical_analysis.rst:192
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard implementation, an entirely blank logical line (i.e. one containing "
"not even whitespace or a comment) terminates a multi-line statement."
msgstr ""

#: reference/lexical_analysis.rst:203
msgid "Indentation"
msgstr ""

#: reference/lexical_analysis.rst:214
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""

#: reference/lexical_analysis.rst:218
msgid ""
"First, tabs are replaced (from left to right) by one to eight spaces such "
"that the total number of characters up to and including the replacement is a "
"multiple of eight (this is intended to be the same rule as used by Unix).  "
"The total number of spaces preceding the first non-blank character then "
"determines the line's indentation.  Indentation cannot be split over "
"multiple physical lines using backslashes; the whitespace up to the first "
"backslash determines the indentation."
msgstr ""

#: reference/lexical_analysis.rst:226
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""

#: reference/lexical_analysis.rst:231
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""

#: reference/lexical_analysis.rst:240
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""

#: reference/lexical_analysis.rst:243
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""

#: reference/lexical_analysis.rst:254
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""

#: reference/lexical_analysis.rst:269
msgid "The following example shows various indentation errors::"
msgstr ""

#: reference/lexical_analysis.rst:279
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""

#: reference/lexical_analysis.rst:287
msgid "Whitespace between tokens"
msgstr ""

#: reference/lexical_analysis.rst:289
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""

#: reference/lexical_analysis.rst:299
msgid "Other tokens"
msgstr ""

#: reference/lexical_analysis.rst:301
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""

#: reference/lexical_analysis.rst:311
msgid "Identifiers and keywords"
msgstr ""

#: reference/lexical_analysis.rst:317
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:327
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""

#: reference/lexical_analysis.rst:333
msgid "Keywords"
msgstr ""

#: reference/lexical_analysis.rst:339
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""

#: reference/lexical_analysis.rst:353
msgid ""
":const:`None` became a constant and is now recognized by the compiler as a "
"name for the built-in object :const:`None`.  Although it is not a keyword, "
"you cannot assign a different object to it."
msgstr ""

#: reference/lexical_analysis.rst:358
msgid ""
"Using :keyword:`as` and :keyword:`with` as identifiers triggers a warning.  "
"To use them as keywords, enable the ``with_statement`` future feature ."
msgstr ""

#: reference/lexical_analysis.rst:362
msgid ":keyword:`as` and :keyword:`with` are full keywords."
msgstr ""

#: reference/lexical_analysis.rst:369
msgid "Reserved classes of identifiers"
msgstr ""

#: reference/lexical_analysis.rst:371
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""

#: reference/lexical_analysis.rst:385
msgid "_*"
msgstr ""

#: reference/lexical_analysis.rst:376
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`__builtin__` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""

#: reference/lexical_analysis.rst:383
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""

#: reference/lexical_analysis.rst:393
msgid "__*__"
msgstr ""

#: reference/lexical_analysis.rst:388
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr ""

#: reference/lexical_analysis.rst:400
msgid "__*"
msgstr ""

#: reference/lexical_analysis.rst:396
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""

#: reference/lexical_analysis.rst:411
msgid "Literals are notations for constant values of some built-in types."
msgstr ""

#: reference/lexical_analysis.rst:417
msgid "String literals"
msgstr ""

#: reference/lexical_analysis.rst:421
msgid "String literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:438
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` and the rest of "
"the string literal. The source character set is defined by the encoding "
"declaration; it is ASCII if no encoding declaration is given in the source "
"file; see section :ref:`encodings`."
msgstr ""

#: reference/lexical_analysis.rst:450
msgid ""
"In plain English: String literals can be enclosed in matching single quotes "
"(``'``) or double quotes (``\"``).  They can also be enclosed in matching "
"groups of three single or double quotes (these are generally referred to as "
"*triple-quoted strings*).  The backslash (``\\``) character is used to "
"escape characters that otherwise have a special meaning, such as newline, "
"backslash itself, or the quote character.  String literals may optionally be "
"prefixed with a letter ``'r'`` or ``'R'``; such strings are called :dfn:`raw "
"strings` and use different rules for interpreting backslash escape "
"sequences.  A prefix of ``'u'`` or ``'U'`` makes the string a Unicode "
"string.  Unicode strings use the Unicode character set as defined by the "
"Unicode Consortium and ISO 10646.  Some additional escape sequences, "
"described below, are available in Unicode strings. A prefix of ``'b'`` or "
"``'B'`` is ignored in Python 2; it indicates that the literal should become "
"a bytes literal in Python 3 (e.g. when code is automatically converted with "
"2to3).  A ``'u'`` or ``'b'`` prefix may be followed by an ``'r'`` prefix."
msgstr ""

#: reference/lexical_analysis.rst:466
msgid ""
"In triple-quoted strings, unescaped newlines and quotes are allowed (and are "
"retained), except that three unescaped quotes in a row terminate the "
"string.  (A \"quote\" is the character used to open the string, i.e. either "
"``'`` or ``\"``.)"
msgstr ""

#: reference/lexical_analysis.rst:476
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings "
"are interpreted according to rules similar to those used by Standard C.  The "
"recognized escape sequences are:"
msgstr ""

#: reference/lexical_analysis.rst:481
msgid "Escape Sequence"
msgstr ""

#: reference/lexical_analysis.rst:481
msgid "Notes"
msgstr "Notes"

#: reference/lexical_analysis.rst:483
msgid "``\\newline``"
msgstr ""

#: reference/lexical_analysis.rst:483
msgid "Ignored"
msgstr ""

#: reference/lexical_analysis.rst:485
msgid "``\\\\``"
msgstr ""

#: reference/lexical_analysis.rst:485
msgid "Backslash (``\\``)"
msgstr ""

#: reference/lexical_analysis.rst:487
msgid "``\\'``"
msgstr ""

#: reference/lexical_analysis.rst:487
msgid "Single quote (``'``)"
msgstr ""

#: reference/lexical_analysis.rst:489
msgid "``\\\"``"
msgstr ""

#: reference/lexical_analysis.rst:489
msgid "Double quote (``\"``)"
msgstr ""

#: reference/lexical_analysis.rst:491
msgid "``\\a``"
msgstr ""

#: reference/lexical_analysis.rst:491
msgid "ASCII Bell (BEL)"
msgstr ""

#: reference/lexical_analysis.rst:493
msgid "``\\b``"
msgstr "``\\b``"

#: reference/lexical_analysis.rst:493
msgid "ASCII Backspace (BS)"
msgstr ""

#: reference/lexical_analysis.rst:495
msgid "``\\f``"
msgstr ""

#: reference/lexical_analysis.rst:495
msgid "ASCII Formfeed (FF)"
msgstr ""

#: reference/lexical_analysis.rst:497
msgid "``\\n``"
msgstr "``\\n``"

#: reference/lexical_analysis.rst:497
msgid "ASCII Linefeed (LF)"
msgstr ""

#: reference/lexical_analysis.rst:499
msgid "``\\N{name}``"
msgstr ""

#: reference/lexical_analysis.rst:499
msgid "Character named *name* in the Unicode database (Unicode only)"
msgstr ""

#: reference/lexical_analysis.rst:502
msgid "``\\r``"
msgstr "``\\r``"

#: reference/lexical_analysis.rst:502
msgid "ASCII Carriage Return (CR)"
msgstr ""

#: reference/lexical_analysis.rst:504
msgid "``\\t``"
msgstr ""

#: reference/lexical_analysis.rst:504
msgid "ASCII Horizontal Tab (TAB)"
msgstr ""

#: reference/lexical_analysis.rst:506
msgid "``\\uxxxx``"
msgstr ""

#: reference/lexical_analysis.rst:506
msgid "Character with 16-bit hex value *xxxx* (Unicode only)"
msgstr ""

#: reference/lexical_analysis.rst:506
msgid "\\(1)"
msgstr "\\(1)"

#: reference/lexical_analysis.rst:509
msgid "``\\Uxxxxxxxx``"
msgstr ""

#: reference/lexical_analysis.rst:509
msgid "Character with 32-bit hex value *xxxxxxxx* (Unicode only)"
msgstr ""

#: reference/lexical_analysis.rst:509
msgid "\\(2)"
msgstr "\\(2)"

#: reference/lexical_analysis.rst:512
msgid "``\\v``"
msgstr ""

#: reference/lexical_analysis.rst:512
msgid "ASCII Vertical Tab (VT)"
msgstr ""

#: reference/lexical_analysis.rst:514
msgid "``\\ooo``"
msgstr ""

#: reference/lexical_analysis.rst:514
msgid "Character with octal value *ooo*"
msgstr ""

#: reference/lexical_analysis.rst:514
msgid "(3,5)"
msgstr ""

#: reference/lexical_analysis.rst:517
msgid "``\\xhh``"
msgstr ""

#: reference/lexical_analysis.rst:517
msgid "Character with hex value *hh*"
msgstr ""

#: reference/lexical_analysis.rst:517
msgid "(4,5)"
msgstr ""

#: reference/lexical_analysis.rst:522
msgid "Notes:"
msgstr "Notes : "

#: reference/lexical_analysis.rst:525
msgid ""
"Individual code units which form parts of a surrogate pair can be encoded "
"using this escape sequence."
msgstr ""

#: reference/lexical_analysis.rst:529
msgid ""
"Any Unicode character can be encoded this way, but characters outside the "
"Basic Multilingual Plane (BMP) will be encoded using a surrogate pair if "
"Python is compiled to use 16-bit code units (the default)."
msgstr ""

#: reference/lexical_analysis.rst:534
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""

#: reference/lexical_analysis.rst:537
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""

#: reference/lexical_analysis.rst:540
msgid ""
"In a string literal, hexadecimal and octal escapes denote the byte with the "
"given value; it is not necessary that the byte encodes a character in the "
"source character set. In a Unicode literal, these escapes denote a Unicode "
"character with the given value."
msgstr ""

#: reference/lexical_analysis.rst:547
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the string*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences marked as \"(Unicode only)\" in the table above "
"fall into the category of unrecognized escapes for non-Unicode string "
"literals."
msgstr ""

#: reference/lexical_analysis.rst:554
msgid ""
"When an ``'r'`` or ``'R'`` prefix is present, a character following a "
"backslash is included in the string without change, and *all backslashes are "
"left in the string*.  For example, the string literal ``r\"\\n\"`` consists "
"of two characters: a backslash and a lowercase ``'n'``.  String quotes can "
"be escaped with a backslash, but the backslash remains in the string; for "
"example, ``r\"\\\"\"`` is a valid string literal consisting of two "
"characters: a backslash and a double quote; ``r\"\\\"`` is not a valid "
"string literal (even a raw string cannot end in an odd number of "
"backslashes).  Specifically, *a raw string cannot end in a single backslash* "
"(since the backslash would escape the following quote character).  Note also "
"that a single backslash followed by a newline is interpreted as those two "
"characters as part of the string, *not* as a line continuation."
msgstr ""

#: reference/lexical_analysis.rst:567
msgid ""
"When an ``'r'`` or ``'R'`` prefix is used in conjunction with a ``'u'`` or "
"``'U'`` prefix, then the ``\\uXXXX`` and ``\\UXXXXXXXX`` escape sequences "
"are processed while  *all other backslashes are left in the string*. For "
"example, the string literal ``ur\"\\u0062\\n\"`` consists of three Unicode "
"characters: 'LATIN SMALL LETTER B', 'REVERSE SOLIDUS', and 'LATIN SMALL "
"LETTER N'. Backslashes can be escaped with a preceding backslash; however, "
"both remain in the string.  As a result, ``\\uXXXX`` escape sequences are "
"only recognized when there are an odd number of backslashes."
msgstr ""

#: reference/lexical_analysis.rst:580
msgid "String literal concatenation"
msgstr ""

#: reference/lexical_analysis.rst:582
msgid ""
"Multiple adjacent string literals (delimited by whitespace), possibly using "
"different quoting conventions, are allowed, and their meaning is the same as "
"their concatenation.  Thus, ``\"hello\" 'world'`` is equivalent to ``"
"\"helloworld\"``.  This feature can be used to reduce the number of "
"backslashes needed, to split long strings conveniently across long lines, or "
"even to add comments to parts of strings, for example::"
msgstr ""

#: reference/lexical_analysis.rst:593
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings)."
msgstr ""

#: reference/lexical_analysis.rst:602
msgid "Numeric literals"
msgstr ""

#: reference/lexical_analysis.rst:618
msgid ""
"There are four types of numeric literals: plain integers, long integers, "
"floating point numbers, and imaginary numbers.  There are no complex "
"literals (complex numbers can be formed by adding a real number and an "
"imaginary number)."
msgstr ""

#: reference/lexical_analysis.rst:622
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""

#: reference/lexical_analysis.rst:630
msgid "Integer and long integer literals"
msgstr ""

#: reference/lexical_analysis.rst:632
msgid ""
"Integer and long integer literals are described by the following lexical "
"definitions:"
msgstr ""

#: reference/lexical_analysis.rst:647
msgid ""
"Although both lower case ``'l'`` and upper case ``'L'`` are allowed as "
"suffix for long integers, it is strongly recommended to always use ``'L'``, "
"since the letter ``'l'`` looks too much like the digit ``'1'``."
msgstr ""

#: reference/lexical_analysis.rst:651
msgid ""
"Plain integer literals that are above the largest representable plain "
"integer (e.g., 2147483647 when using 32-bit arithmetic) are accepted as if "
"they were long integers instead. [#]_  There is no limit for long integer "
"literals apart from what can be stored in available memory."
msgstr ""

#: reference/lexical_analysis.rst:656
msgid ""
"Some examples of plain integer literals (first row) and long integer "
"literals (second and third rows)::"
msgstr ""

#: reference/lexical_analysis.rst:667
msgid "Floating point literals"
msgstr ""

#: reference/lexical_analysis.rst:669
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:679
msgid ""
"Note that the integer and exponent parts of floating point numbers can look "
"like octal integers, but are interpreted using radix 10.  For example, "
"``077e010`` is legal, and denotes the same number as ``77e10``. The allowed "
"range of floating point literals is implementation-dependent. Some examples "
"of floating point literals::"
msgstr ""

#: reference/lexical_analysis.rst:687
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator ``-`` and the literal "
"``1``."
msgstr ""

#: reference/lexical_analysis.rst:695
msgid "Imaginary literals"
msgstr ""

#: reference/lexical_analysis.rst:697
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:702
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""

#: reference/lexical_analysis.rst:714
msgid "Operators"
msgstr ""

#: reference/lexical_analysis.rst:718
msgid "The following tokens are operators::"
msgstr ""

#: reference/lexical_analysis.rst:724
msgid ""
"The comparison operators ``<>`` and ``!=`` are alternate spellings of the "
"same operator.  ``!=`` is the preferred spelling; ``<>`` is obsolescent."
msgstr ""

#: reference/lexical_analysis.rst:731
msgid "Delimiters"
msgstr ""

#: reference/lexical_analysis.rst:735
msgid "The following tokens serve as delimiters in the grammar::"
msgstr ""

#: reference/lexical_analysis.rst:742
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis in slices. "
"The second half of the list, the augmented assignment operators, serve "
"lexically as delimiters, but also perform an operation."
msgstr ""

#: reference/lexical_analysis.rst:747
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer::"
msgstr ""

#: reference/lexical_analysis.rst:754
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error::"
msgstr ""

#: reference/lexical_analysis.rst:761
msgid ""
"In versions of Python prior to 2.4, octal and hexadecimal literals in the "
"range just above the largest representable plain integer but below the "
"largest unsigned 32-bit number (on a machine using 32-bit arithmetic), "
"4294967296, were taken as the negative plain integer obtained by subtracting "
"4294967296 from their unsigned value."
msgstr ""

#: reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr ""

#: reference/simple_stmts.rst:10
msgid ""
"Simple statements are comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""

#: reference/simple_stmts.rst:35
msgid "Expression statements"
msgstr ""

#: reference/simple_stmts.rst:41
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""

#: reference/simple_stmts.rst:50
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""

#: reference/simple_stmts.rst:62
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output (see section :ref:`print`) on a line by itself.  "
"(Expression statements yielding ``None`` are not written, so that procedure "
"calls do not cause any output.)"
msgstr ""

#: reference/simple_stmts.rst:72
msgid "Assignment statements"
msgstr ""

#: reference/simple_stmts.rst:82
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""

#: reference/simple_stmts.rst:95 reference/simple_stmts.rst:267
msgid ""
"(See section :ref:`primaries` for the syntax definitions for the last three "
"symbols.)"
msgstr ""

#: reference/simple_stmts.rst:100
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""

#: reference/simple_stmts.rst:109
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""

#: reference/simple_stmts.rst:118
msgid ""
"Assignment of an object to a target list is recursively defined as follows."
msgstr ""

#: reference/simple_stmts.rst:120
msgid ""
"If the target list is a single target: The object is assigned to that target."
msgstr ""

#: reference/simple_stmts.rst:122
msgid ""
"If the target list is a comma-separated list of targets: The object must be "
"an iterable with the same number of items as there are targets in the target "
"list, and the items are assigned, from left to right, to the corresponding "
"targets."
msgstr ""

#: reference/simple_stmts.rst:126
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""

#: reference/simple_stmts.rst:128
msgid "If the target is an identifier (name):"
msgstr ""

#: reference/simple_stmts.rst:132
msgid ""
"If the name does not occur in a :keyword:`global` statement in the current "
"code block: the name is bound to the object in the current local namespace."
msgstr ""

#: reference/simple_stmts.rst:135
msgid ""
"Otherwise: the name is bound to the object in the current global namespace."
msgstr ""

#: reference/simple_stmts.rst:139
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""

#: reference/simple_stmts.rst:143
msgid ""
"If the target is a target list enclosed in parentheses or in square "
"brackets: The object must be an iterable with the same number of items as "
"there are targets in the target list, and its items are assigned, from left "
"to right, to the corresponding targets."
msgstr ""

#: reference/simple_stmts.rst:150
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""

#: reference/simple_stmts.rst:159
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the RHS expression, ``a.x`` can "
"access either an instance attribute or (if no instance attribute exists) a "
"class attribute.  The LHS target ``a.x`` is always set as an instance "
"attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` "
"do not necessarily refer to the same attribute: if the RHS expression refers "
"to a class attribute, the LHS creates a new instance attribute as the target "
"of the assignment::"
msgstr ""

#: reference/simple_stmts.rst:173
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""

#: reference/simple_stmts.rst:180
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary). Next, the subscript "
"expression is evaluated."
msgstr ""

#: reference/simple_stmts.rst:189
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield a plain integer.  If it is negative, the sequence's length is "
"added to it. The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""

#: reference/simple_stmts.rst:200
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""

#: reference/simple_stmts.rst:208
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"(small) integers.  If either bound is negative, the sequence's length is "
"added to it. The resulting bounds are clipped to lie between zero and the "
"sequence's length, inclusive.  Finally, the sequence object is asked to "
"replace the slice with the items of the assigned sequence.  The length of "
"the slice may be different from the length of the assigned sequence, thus "
"changing the length of the target sequence, if the object allows it."
msgstr ""

#: reference/simple_stmts.rst:222
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""

#: reference/simple_stmts.rst:226
msgid ""
"WARNING: Although the definition of assignment implies that overlaps between "
"the left-hand side and the right-hand side are 'safe' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables are not safe!  For instance, the following program prints ``[0, "
"2]``::"
msgstr ""

#: reference/simple_stmts.rst:240
msgid "Augmented assignment statements"
msgstr ""

#: reference/simple_stmts.rst:258
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""

#: reference/simple_stmts.rst:270
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""

#: reference/simple_stmts.rst:275
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""

#: reference/simple_stmts.rst:281
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""

#: reference/simple_stmts.rst:287
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""

#: reference/simple_stmts.rst:294
msgid "The :keyword:`assert` statement"
msgstr ""

#: reference/simple_stmts.rst:300
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""

#: reference/simple_stmts.rst:306
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr ""

#: reference/simple_stmts.rst:311
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""

#: reference/simple_stmts.rst:320
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option -O).  The current code generator emits no code for an assert "
"statement when optimization is requested at compile time.  Note that it is "
"unnecessary to include the source code for the expression that failed in the "
"error message; it will be displayed as part of the stack trace."
msgstr ""

#: reference/simple_stmts.rst:329
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""

#: reference/simple_stmts.rst:336
msgid "The :keyword:`pass` statement"
msgstr ""

#: reference/simple_stmts.rst:345
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""

#: reference/simple_stmts.rst:357
msgid "The :keyword:`del` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/simple_stmts.rst:367
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""

#: reference/simple_stmts.rst:370
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""

#: reference/simple_stmts.rst:376
msgid ""
"Deletion of a name removes the binding of that name  from the local or "
"global namespace, depending on whether the name occurs in a :keyword:"
"`global` statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""

#: reference/simple_stmts.rst:383
msgid ""
"It is illegal to delete a name from the local namespace if it occurs as a "
"free variable in a nested block."
msgstr ""

#: reference/simple_stmts.rst:388
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""

#: reference/simple_stmts.rst:397
#, fuzzy
msgid "The :keyword:`print` statement"
msgstr "L'instruction :keyword:`if`"

#: reference/simple_stmts.rst:405
msgid ""
":keyword:`print` evaluates each expression in turn and writes the resulting "
"object to standard output (see below).  If an object is not a string, it is "
"first converted to a string using the rules for string conversions.  The "
"(resulting or original) string is then written.  A space is written before "
"each object is (converted and) written, unless the output system believes it "
"is positioned at the beginning of a line.  This is the case (1) when no "
"characters have yet been written to standard output, (2) when the last "
"character written to standard output is a whitespace character except ``' "
"'``, or (3) when the last write operation on standard output was not a :"
"keyword:`print` statement. (In some cases it may be functional to write an "
"empty string to standard output for this reason.)"
msgstr ""

#: reference/simple_stmts.rst:419
msgid ""
"Objects which act like file objects but which are not the built-in file "
"objects often do not properly emulate this aspect of the file object's "
"behavior, so it is best not to rely on this."
msgstr ""

#: reference/simple_stmts.rst:429
msgid ""
"A ``'\\n'`` character is written at the end, unless the :keyword:`print` "
"statement ends with a comma.  This is the only action if the statement "
"contains just the keyword :keyword:`print`."
msgstr ""

#: reference/simple_stmts.rst:439
msgid ""
"Standard output is defined as the file object named ``stdout`` in the built-"
"in module :mod:`sys`.  If no such object exists, or if it does not have a :"
"meth:`write` method, a :exc:`RuntimeError` exception is raised."
msgstr ""

#: reference/simple_stmts.rst:445
msgid ""
":keyword:`print` also has an extended form, defined by the second portion of "
"the syntax described above. This form is sometimes referred to as \":keyword:"
"`print` chevron.\" In this form, the first expression after the ``>>`` must "
"evaluate to a \"file-like\" object, specifically an object that has a :meth:"
"`write` method as described above.  With this extended form, the subsequent "
"expressions are printed to this file object.  If the first expression "
"evaluates to ``None``, then ``sys.stdout`` is used as the file for output."
msgstr ""

#: reference/simple_stmts.rst:457
msgid "The :keyword:`return` statement"
msgstr ""

#: reference/simple_stmts.rst:467
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""

#: reference/simple_stmts.rst:470
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""

#: reference/simple_stmts.rst:472
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""

#: reference/simple_stmts.rst:477
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the function."
msgstr ""

#: reference/simple_stmts.rst:481
msgid ""
"In a generator function, the :keyword:`return` statement is not allowed to "
"include an :token:`expression_list`.  In that context, a bare :keyword:"
"`return` indicates that the generator is done and will cause :exc:"
"`StopIteration` to be raised."
msgstr ""

#: reference/simple_stmts.rst:490
#, fuzzy
msgid "The :keyword:`yield` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/simple_stmts.rst:502
msgid ""
"The :keyword:`yield` statement is only used when defining a generator "
"function, and is only used in the body of the generator function. Using a :"
"keyword:`yield` statement in a function definition is sufficient to cause "
"that definition to create a generator function instead of a normal function."
msgstr ""

#: reference/simple_stmts.rst:507
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator iterator, or more commonly, a generator.  The body of the "
"generator function is executed by calling the generator's :meth:`~generator."
"next` method repeatedly until it raises an exception."
msgstr ""

#: reference/simple_stmts.rst:512
msgid ""
"When a :keyword:`yield` statement is executed, the state of the generator is "
"frozen and the value of :token:`expression_list` is returned to :meth:"
"`~generator.next`'s caller.  By \"frozen\" we mean that all local state is "
"retained, including the current bindings of local variables, the instruction "
"pointer, and the internal evaluation stack: enough information is saved so "
"that the next time :meth:`~generator.next` is invoked, the function can "
"proceed exactly as if the :keyword:`yield` statement were just another "
"external call."
msgstr ""

#: reference/simple_stmts.rst:520
msgid ""
"As of Python version 2.5, the :keyword:`yield` statement is now allowed in "
"the :keyword:`try` clause of a :keyword:`try` ...  :keyword:`finally` "
"construct.  If the generator is not resumed before it is finalized (by "
"reaching a zero reference count or by being garbage collected), the "
"generator-iterator's :meth:`close` method will be called, allowing any "
"pending :keyword:`finally` clauses to execute."
msgstr ""

#: reference/simple_stmts.rst:527
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""

#: reference/simple_stmts.rst:532
msgid ""
"In Python 2.2, the :keyword:`yield` statement was only allowed when the "
"``generators`` feature has been enabled.  This ``__future__`` import "
"statement was used to enable the feature::"
msgstr ""

#: reference/simple_stmts.rst:542
msgid "PEP 0255 - Simple Generators"
msgstr ""

#: reference/simple_stmts.rst:542
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""

#: reference/simple_stmts.rst:545
msgid ""
"The proposal that, among other generator enhancements, proposed allowing :"
"keyword:`yield` to appear inside a :keyword:`try` ... :keyword:`finally` "
"block."
msgstr ""

#: reference/simple_stmts.rst:552
#, fuzzy
msgid "The :keyword:`raise` statement"
msgstr "L'instruction :keyword:`if`"

#: reference/simple_stmts.rst:562
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception "
"that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`TypeError` exception is raised indicating that this "
"is an error (if running under IDLE, a :exc:`Queue.Empty` exception is raised "
"instead)."
msgstr ""

#: reference/simple_stmts.rst:567
msgid ""
"Otherwise, :keyword:`raise` evaluates the expressions to get three objects, "
"using ``None`` as the value of omitted expressions.  The first two objects "
"are used to determine the *type* and *value* of the exception."
msgstr ""

#: reference/simple_stmts.rst:571
msgid ""
"If the first object is an instance, the type of the exception is the class "
"of the instance, the instance itself is the value, and the second object "
"must be ``None``."
msgstr ""

#: reference/simple_stmts.rst:575
msgid ""
"If the first object is a class, it becomes the type of the exception. The "
"second object is used to determine the exception value: If it is an instance "
"of the class, the instance becomes the exception value. If the second object "
"is a tuple, it is used as the argument list for the class constructor; if it "
"is ``None``, an empty argument list is used, and any other object is treated "
"as a single argument to the constructor.  The instance so created by calling "
"the constructor is used as the exception value."
msgstr ""

#: reference/simple_stmts.rst:585
msgid ""
"If a third object is present and not ``None``, it must be a traceback object "
"(see section :ref:`types`), and it is substituted instead of the current "
"location as the place where the exception occurred.  If the third object is "
"present and not a traceback object or ``None``, a :exc:`TypeError` exception "
"is raised.  The three-expression form of :keyword:`raise` is useful to re-"
"raise an exception transparently in an except clause, but :keyword:`raise` "
"with no expressions should be preferred if the exception to be re-raised was "
"the most recently active exception in the current scope."
msgstr ""

#: reference/simple_stmts.rst:594
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""

#: reference/simple_stmts.rst:601
msgid "The :keyword:`break` statement"
msgstr ""

#: reference/simple_stmts.rst:612
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""

#: reference/simple_stmts.rst:618
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:"
"`else` clause if the loop has one."
msgstr ""

#: reference/simple_stmts.rst:623
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""

#: reference/simple_stmts.rst:628
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the loop."
msgstr ""

#: reference/simple_stmts.rst:636
msgid "The :keyword:`continue` statement"
msgstr ""

#: reference/simple_stmts.rst:648
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"or :keyword:`finally` clause within that loop.  It continues with the next "
"cycle of the nearest enclosing loop."
msgstr ""

#: reference/simple_stmts.rst:653
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really starting the next loop cycle."
msgstr ""

#: reference/simple_stmts.rst:662
msgid "The :keyword:`import` statement"
msgstr ""

#: reference/simple_stmts.rst:682
msgid ""
"Import statements are executed in two steps: (1) find a module, and "
"initialize it if necessary; (2) define a name or names in the local "
"namespace (of the scope where the :keyword:`import` statement occurs). The "
"statement comes in two forms differing on whether it uses the :keyword:"
"`from` keyword. The first form (without :keyword:`from`) repeats these steps "
"for each identifier in the list. The form with :keyword:`from` performs step "
"(1) once, and then performs step (2) repeatedly."
msgstr ""

#: reference/simple_stmts.rst:693
msgid ""
"To understand how step (1) occurs, one must first understand how Python "
"handles hierarchical naming of modules. To help organize modules and provide "
"a hierarchy in naming, Python has a concept of packages. A package can "
"contain other packages and modules while modules cannot contain other "
"modules or packages. From a file system perspective, packages are "
"directories and modules are files."
msgstr ""

#: reference/simple_stmts.rst:703
msgid ""
"Once the name of the module is known (unless otherwise specified, the term "
"\"module\" will refer to both packages and modules), searching for the "
"module or package can begin. The first place checked is :data:`sys.modules`, "
"the cache of all modules that have been imported previously. If the module "
"is found there then it is used in step (2) of import."
msgstr ""

#: reference/simple_stmts.rst:715
msgid ""
"If the module is not found in the cache, then :data:`sys.meta_path` is "
"searched (the specification for :data:`sys.meta_path` can be found in :pep:"
"`302`). The object is a list of :term:`finder` objects which are queried in "
"order as to whether they know how to load the module by calling their :meth:"
"`find_module` method with the name of the module. If the module happens to "
"be contained within a package (as denoted by the existence of a dot in the "
"name), then a second argument to :meth:`find_module` is given as the value "
"of the :attr:`__path__` attribute from the parent package (everything up to "
"the last dot in the name of the module being imported). If a finder can find "
"the module it returns a :term:`loader` (discussed later) or returns ``None``."
msgstr ""

#: reference/simple_stmts.rst:731
msgid ""
"If none of the finders on :data:`sys.meta_path` are able to find the module "
"then some implicitly defined finders are queried. Implementations of Python "
"vary in what implicit meta path finders are defined. The one they all do "
"define, though, is one that handles :data:`sys.path_hooks`, :data:`sys."
"path_importer_cache`, and :data:`sys.path`."
msgstr ""

#: reference/simple_stmts.rst:737
msgid ""
"The implicit finder searches for the requested module in the \"paths\" "
"specified in one of two places (\"paths\" do not have to be file system "
"paths). If the module being imported is supposed to be contained within a "
"package then the second argument passed to :meth:`find_module`, :attr:"
"`__path__` on the parent package, is used as the source of paths. If the "
"module is not contained in a package then :data:`sys.path` is used as the "
"source of paths."
msgstr ""

#: reference/simple_stmts.rst:744
msgid ""
"Once the source of paths is chosen it is iterated over to find a finder that "
"can handle that path. The dict at :data:`sys.path_importer_cache` caches "
"finders for paths and is checked for a finder. If the path does not have a "
"finder cached then :data:`sys.path_hooks` is searched by calling each object "
"in the list with a single argument of the path, returning a finder or "
"raises :exc:`ImportError`. If a finder is returned then it is cached in :"
"data:`sys.path_importer_cache` and then used for that path entry. If no "
"finder can be found but the path exists then a value of ``None`` is stored "
"in :data:`sys.path_importer_cache` to signify that an implicit, file-based "
"finder that handles modules stored as individual files should be used for "
"that path. If the path does not exist then a finder which always returns "
"``None`` is placed in the cache for the path."
msgstr ""

#: reference/simple_stmts.rst:762
msgid ""
"If no finder can find the module then :exc:`ImportError` is raised. "
"Otherwise some finder returned a loader whose :meth:`load_module` method is "
"called with the name of the module to load (see :pep:`302` for the original "
"definition of loaders). A loader has several responsibilities to perform on "
"a module it loads. First, if the module already exists in :data:`sys."
"modules` (a possibility if the loader is called outside of the import "
"machinery) then it is to use that module for initialization and not a new "
"module. But if the module does not exist in :data:`sys.modules` then it is "
"to be added to that dict before initialization begins. If an error occurs "
"during loading of the module and it was added to :data:`sys.modules` it is "
"to be removed from the dict. If an error occurs but the module was already "
"in :data:`sys.modules` it is left in the dict."
msgstr ""

#: reference/simple_stmts.rst:782
msgid ""
"The loader must set several attributes on the module. :data:`__name__` is to "
"be set to the name of the module. :data:`__file__` is to be the \"path\" to "
"the file unless the module is built-in (and thus listed in :data:`sys."
"builtin_module_names`) in which case the attribute is not set. If what is "
"being imported is a package then :data:`__path__` is to be set to a list of "
"paths to be searched when looking for modules and packages contained within "
"the package being imported. :data:`__package__` is optional but should be "
"set to the name of package that contains the module or package (the empty "
"string is used for module not contained in a package). :data:`__loader__` is "
"also optional but should be set to the loader object that is loading the "
"module."
msgstr ""

#: reference/simple_stmts.rst:797
msgid ""
"If an error occurs during loading then the loader raises :exc:`ImportError` "
"if some other exception is not already being propagated. Otherwise the "
"loader returns the module that was loaded and initialized."
msgstr ""

#: reference/simple_stmts.rst:801
msgid ""
"When step (1) finishes without raising an exception, step (2) can begin."
msgstr ""

#: reference/simple_stmts.rst:803
msgid ""
"The first form of :keyword:`import` statement binds the module name in the "
"local namespace to the module object, and then goes on to import the next "
"identifier, if any.  If the module name is followed by :keyword:`as`, the "
"name following :keyword:`as` is used as the local name for the module."
msgstr ""

#: reference/simple_stmts.rst:812
msgid ""
"The :keyword:`from` form does not bind the module name: it goes through the "
"list of identifiers, looks each one of them up in the module found in step "
"(1), and binds the name in the local namespace to the object thus found.  As "
"with the first form of :keyword:`import`, an alternate local name can be "
"supplied by specifying \":keyword:`as` localname\".  If a name is not "
"found, :exc:`ImportError` is raised.  If the list of identifiers is replaced "
"by a star (``'*'``), all public names defined in the module are bound in the "
"local namespace of the :keyword:`import` statement.."
msgstr ""

#: reference/simple_stmts.rst:823
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``). ``__all__`` should contain the entire public API. It is "
"intended to avoid accidentally exporting items that are not part of the API "
"(such as library modules which were imported and used within the module)."
msgstr ""

#: reference/simple_stmts.rst:833
msgid ""
"The :keyword:`from` form with ``*`` may only occur in a module scope.  If "
"the wild card form of import --- ``import *`` --- is used in a function and "
"the function contains or is a nested block with free variables, the compiler "
"will raise a :exc:`SyntaxError`."
msgstr ""

#: reference/simple_stmts.rst:841
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained "
"within :pep:`328`."
msgstr ""

#: reference/simple_stmts.rst:854
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine which modules need to be loaded dynamically."
msgstr ""

#: reference/simple_stmts.rst:861
msgid "Future statements"
msgstr ""

#: reference/simple_stmts.rst:865
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python.  The future statement is intended "
"to ease migration to future versions of Python that introduce incompatible "
"changes to the language.  It allows use of the new features on a per-module "
"basis before the release in which the feature becomes standard."
msgstr ""

#: reference/simple_stmts.rst:880
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""

#: reference/simple_stmts.rst:883
msgid "the module docstring (if any),"
msgstr ""

#: reference/simple_stmts.rst:884
msgid "comments,"
msgstr ""

#: reference/simple_stmts.rst:885
msgid "blank lines, and"
msgstr ""

#: reference/simple_stmts.rst:886
msgid "other future statements."
msgstr ""

#: reference/simple_stmts.rst:888
msgid ""
"The features recognized by Python 2.6 are ``unicode_literals``, "
"``print_function``, ``absolute_import``, ``division``, ``generators``, "
"``nested_scopes`` and ``with_statement``.  ``generators``, "
"``with_statement``, ``nested_scopes`` are redundant in Python version 2.6 "
"and above because they are always enabled."
msgstr ""

#: reference/simple_stmts.rst:894
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""

#: reference/simple_stmts.rst:901
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""

#: reference/simple_stmts.rst:905
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""

#: reference/simple_stmts.rst:909
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""

#: reference/simple_stmts.rst:912
msgid "Note that there is nothing special about the statement::"
msgstr ""

#: reference/simple_stmts.rst:916
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""

#: reference/simple_stmts.rst:919
msgid ""
"Code compiled by an :keyword:`exec` statement or calls to the built-in "
"functions :func:`compile` and :func:`execfile` that occur in a module :mod:"
"`M` containing a future statement will, by default, use the new  syntax or "
"semantics associated with the future statement.  This can, starting with "
"Python 2.2 be controlled by optional arguments to :func:`compile` --- see "
"the documentation of that function for details."
msgstr ""

#: reference/simple_stmts.rst:926
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""

#: reference/simple_stmts.rst:934
msgid "PEP 236 - Back to the __future__"
msgstr "PEP 236 - Retour vers le __future__"

#: reference/simple_stmts.rst:935
msgid "The original proposal for the __future__ mechanism."
msgstr ""

#: reference/simple_stmts.rst:941
msgid "The :keyword:`global` statement"
msgstr ""

#: reference/simple_stmts.rst:950
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`global`, although free variables may refer to "
"globals without being declared global."
msgstr ""

#: reference/simple_stmts.rst:956
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`global` statement."
msgstr ""

#: reference/simple_stmts.rst:959
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, or :keyword:`import` statement."
msgstr ""

#: reference/simple_stmts.rst:965
msgid ""
"The current implementation does not enforce the latter two restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""

#: reference/simple_stmts.rst:975
msgid ""
"**Programmer's note:** the :keyword:`global` is a directive to the parser.  "
"It applies only to code parsed at the same time as the :keyword:`global` "
"statement. In particular, a :keyword:`global` statement contained in an :"
"keyword:`exec` statement does not affect the code block *containing* the :"
"keyword:`exec` statement, and code contained in an :keyword:`exec` statement "
"is unaffected by :keyword:`global` statements in the code containing the :"
"keyword:`exec` statement.  The same applies to the :func:`eval`, :func:"
"`execfile` and :func:`compile` functions."
msgstr ""

#: reference/simple_stmts.rst:988
#, fuzzy
msgid "The :keyword:`exec` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/simple_stmts.rst:995
msgid ""
"This statement supports dynamic execution of Python code.  The first "
"expression should evaluate to either a Unicode string, a *Latin-1* encoded "
"string, an open file object, a code object, or a tuple.  If it is a string, "
"the string is parsed as a suite of Python statements which is then executed "
"(unless a syntax error occurs). [#]_ If it is an open file, the file is "
"parsed until EOF and executed. If it is a code object, it is simply "
"executed.  For the interpretation of a tuple, see below.  In all cases, the "
"code that's executed is expected to be valid as file input (see section :ref:"
"`file-input`).  Be aware that the :keyword:`return` and :keyword:`yield` "
"statements may not be used outside of function definitions even within the "
"context of code passed to the :keyword:`exec` statement."
msgstr ""

#: reference/simple_stmts.rst:1007
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the "
"current scope.  If only the first expression after ``in`` is specified, it "
"should be a dictionary, which will be used for both the global and the local "
"variables.  If two expressions are given, they are used for the global and "
"local variables, respectively. If provided, *locals* can be any mapping "
"object. Remember that at module level, globals and locals are the same "
"dictionary. If two separate objects are given as *globals* and *locals*, the "
"code will be executed as if it were embedded in a class definition."
msgstr ""

#: reference/simple_stmts.rst:1016
msgid ""
"The first expression may also be a tuple of length 2 or 3.  In this case, "
"the optional parts must be omitted.  The form ``exec(expr, globals)`` is "
"equivalent to ``exec expr in globals``, while the form ``exec(expr, globals, "
"locals)`` is equivalent to ``exec expr in globals, locals``.  The tuple form "
"of ``exec`` provides compatibility with Python 3, where ``exec`` is a "
"function rather than a statement."
msgstr ""

#: reference/simple_stmts.rst:1023
msgid "Formerly, *locals* was required to be a dictionary."
msgstr ""

#: reference/simple_stmts.rst:1030
msgid ""
"As a side effect, an implementation may insert additional keys into the "
"dictionaries given besides those corresponding to variable names set by the "
"executed code.  For example, the current implementation may add a reference "
"to the dictionary of the built-in module :mod:`__builtin__` under the key "
"``__builtins__`` (!)."
msgstr ""

#: reference/simple_stmts.rst:1041
msgid ""
"**Programmer's hints:** dynamic evaluation of expressions is supported by "
"the built-in function :func:`eval`.  The built-in functions :func:`globals` "
"and :func:`locals` return the current global and local dictionary, "
"respectively, which may be useful to pass around for use by :keyword:`exec`."
msgstr ""

#: reference/simple_stmts.rst:1049
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use :term:`universal "
"newlines` mode to convert Windows or Mac-style newlines."
msgstr ""

#: reference/toplevel_components.rst:6
msgid "Top-level components"
msgstr ""

#: reference/toplevel_components.rst:10
msgid ""
"The Python interpreter can get its input from a number of sources: from a "
"script passed to it as standard input or as program argument, typed in "
"interactively, from a module source file, etc.  This chapter gives the "
"syntax used in these cases."
msgstr ""

#: reference/toplevel_components.rst:19
msgid "Complete Python programs"
msgstr ""

#: reference/toplevel_components.rst:28
msgid ""
"While a language specification need not prescribe how the language "
"interpreter is invoked, it is useful to have a notion of a complete Python "
"program.  A complete Python program is executed in a minimally initialized "
"environment: all built-in and standard modules are available, but none have "
"been initialized, except for :mod:`sys` (various system services), :mod:"
"`__builtin__` (built-in functions, exceptions and ``None``) and :mod:"
"`__main__`.  The latter is used to provide the local and global namespace "
"for execution of the complete program."
msgstr ""

#: reference/toplevel_components.rst:36
msgid ""
"The syntax for a complete Python program is that for file input, described "
"in the next section."
msgstr ""

#: reference/toplevel_components.rst:43
msgid ""
"The interpreter may also be invoked in interactive mode; in this case, it "
"does not read and execute a complete program but reads and executes one "
"statement (possibly compound) at a time.  The initial environment is "
"identical to that of a complete program; each statement is executed in the "
"namespace of :mod:`__main__`."
msgstr ""

#: reference/toplevel_components.rst:54
msgid ""
"Under Unix, a complete program can be passed to the interpreter in three "
"forms: with the :option:`-c` *string* command line option, as a file passed "
"as the first command line argument, or as standard input. If the file or "
"standard input is a tty device, the interpreter enters interactive mode; "
"otherwise, it executes the file as a complete program."
msgstr ""

#: reference/toplevel_components.rst:64
msgid "File input"
msgstr ""

#: reference/toplevel_components.rst:66
msgid "All input read from non-interactive files has the same form:"
msgstr ""

#: reference/toplevel_components.rst:71
msgid "This syntax is used in the following situations:"
msgstr ""

#: reference/toplevel_components.rst:73
msgid "when parsing a complete Python program (from a file or from a string);"
msgstr ""

#: reference/toplevel_components.rst:75
msgid "when parsing a module;"
msgstr ""

#: reference/toplevel_components.rst:77
msgid "when parsing a string passed to the :keyword:`exec` statement;"
msgstr ""

#: reference/toplevel_components.rst:83
msgid "Interactive input"
msgstr ""

#: reference/toplevel_components.rst:85
msgid "Input in interactive mode is parsed using the following grammar:"
msgstr ""

#: reference/toplevel_components.rst:90
msgid ""
"Note that a (top-level) compound statement must be followed by a blank line "
"in interactive mode; this is needed to help the parser detect the end of the "
"input."
msgstr ""

#: reference/toplevel_components.rst:97
msgid "Expression input"
msgstr ""

#: reference/toplevel_components.rst:103
msgid ""
"There are two forms of expression input.  Both ignore leading whitespace. "
"The string argument to :func:`eval` must have the following form:"
msgstr ""

#: reference/toplevel_components.rst:111
msgid "The input line read by :func:`input` must have the following form:"
msgstr ""

#: reference/toplevel_components.rst:123
msgid ""
"Note: to read 'raw' input line without interpretation, you can use the built-"
"in function :func:`raw_input` or the :meth:`readline` method of file objects."
msgstr ""
