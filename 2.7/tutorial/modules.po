# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: 2017-05-16 22:53+0200\n"
"Last-Translator: Julien Palard <julien@palard.fr>\n"
"Language-Team: \n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.11\n"

#: ../Doc/tutorial/modules.rst:5
msgid "Modules"
msgstr "Modules"

#: ../Doc/tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"Lorsque vous quittez et entrez à nouveau dans l'interpréteur Python, tout ce "
"que vous avez déclaré dans la session précédente est perdu. Afin de rédiger "
"des programmes plus longs, vous devriez utiliser un éditeur de texte, "
"préparer votre code dans un fichier, et exécuter Python avec ce fichier en "
"paramètre. Ça s'appelle créé un *script*. Lorsque votre programme deviendra "
"plus long encore, vous pourrez séparer votre code dans plusieurs fichiers, "
"et vous trouverez aussi pratique de réutiliser des fonctions écrites pour un "
"programme dans un autre sans avoir à les copier."

#: ../Doc/tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"Pour gérer ça, Python à un moyen de rédiger des définitions dans un fichier "
"et les utiliser dans un script ou une session interactive. Un tel fichier "
"est appelé un *module*, et les définitions d'un module peuvent être "
"importées dans un autre module ou dans le module *main* (qui est le module "
"qui contiens vous variables et définitions lors de l'exécution d'un script "
"ou en mode interactif)."

#: ../Doc/tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"Un module est un fichier contenant des définitions et des instructions.  Son "
"nom de fichier est le même que son nom, suffixé de :file:`.py`. À "
"l'intérieur d'un module, son propre nom est accessible dans la variable "
"``__name__``. Par exemple, prenez votre éditeur favori et créez un fichier :"
"file:`fibo.py` contenant : ::"

#: ../Doc/tutorial/modules.rst:44
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr ""
"Maintenant, en étant dans le même dossier, ouvrez un interpréteur et "
"importez le module en tapant : ::"

#: ../Doc/tutorial/modules.rst:49
msgid ""
"This does not enter the names of the functions defined in ``fibo``  directly "
"in the current symbol table; it only enters the module name ``fibo`` there. "
"Using the module name you can access the functions::"
msgstr ""
"Cela n'importe pas les noms des fonctions définies dans ``fibo`` directement "
"dans la table des symboles courante, mais y ajoute simplement ``fibo``. Vous "
"pouvez donc appeler les fonctions via le nom du module : ::"

#: ../Doc/tutorial/modules.rst:60
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"Si vous avez l'intention d'utiliser une fonction souvent, il est possible de "
"lui assigner un nom local : ::"

#: ../Doc/tutorial/modules.rst:70
msgid "More on Modules"
msgstr "Les modules en détails"

#: ../Doc/tutorial/modules.rst:72
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"Un module peut contenir aussi bien des instructions que des déclarations de "
"fonctions. C'est instructions permettent d'initialiser le module, et ne sont "
"donc exécutées que la première fois que le nom d'un module est trouvé dans "
"un ``import``. [#]_ (Elles sont aussi exécutées lorsque le fichier est "
"exécuté en temps que script.)"

#: ../Doc/tutorial/modules.rst:77
msgid ""
"Each module has its own private symbol table, which is used as the global "
"symbol table by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"Chaque module a sa propre table de symboles, utilisée comme table de "
"symboles globaux par toutes les fonctions définies par le module. Ainsi "
"l'auteur d'un module peut utiliser des variables globales dans un module "
"sans se soucier de collisions de noms avec des globales définies par "
"l'utilisateur du module. D'un autre côté, si vous savez ce que vous faites, "
"vous pouvez modifier une variable globale d'un module avec la même notation "
"que pour accéder aux fonctions : ``modname.itemname``."

#: ../Doc/tutorial/modules.rst:84
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names are placed in the importing "
"module's global symbol table."
msgstr ""
"Des modules peuvent importer d'autres modules. Il est habituel mais pas "
"obligatoire de ranger tous les :keyword:`import` au début du module (ou du "
"script). Les noms des module importés sont insérés dans la table des "
"symboles globaux du module qui importe."

#: ../Doc/tutorial/modules.rst:89
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's symbol table.  For "
"example::"
msgstr ""
"Il existe une variation à l'instruction :keyword:`import` qui importe les "
"noms d'un module directement dans la table de symboles du module qui "
"l'importe, par exemple : ::"

#: ../Doc/tutorial/modules.rst:96
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local symbol table (so in the example, ``fibo`` is not defined)."
msgstr ""
"Cela n'insère pas le nom du module depuis lequel les définitions sont "
"récupérées dans la table locale de symboles (dans cet exemple, ``fibo`` "
"n'est pas défini)."

#: ../Doc/tutorial/modules.rst:99
msgid "There is even a variant to import all names that a module defines::"
msgstr ""
"Il existe même une variation permettant d'importer tous les noms qu'un "
"module définit : ::"

#: ../Doc/tutorial/modules.rst:105
msgid ""
"This imports all names except those beginning with an underscore (``_``)."
msgstr "Importe tous les noms sauf ceux commençant par un tiret bas (``_``)."

#: ../Doc/tutorial/modules.rst:107
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"Notez qu'en général, importer ``*`` d'un module ou d'un paquet est "
"déconseillé, en général ça engendre du code difficilement lisible. "
"Cependant, c'est acceptable de l'utiliser pour gagner quelques secondes en "
"mode interactif."

#: ../Doc/tutorial/modules.rst:113
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`reload`, e.g. ``reload(modulename)``."
msgstr ""
"Pour des raisons d'efficience, chaque module n'est importé qu'une fois par "
"session de l'interpète.  Si vous changez vos modules, vous devrez donc "
"redémarrer votre interprète, ou, si vous souhaiter simplement tester un seul "
"module de manière interactive, utiliser la fonction :func:`reload`, tel que: "
"``reload(modulename)``."

#: ../Doc/tutorial/modules.rst:122
msgid "Executing modules as scripts"
msgstr "Exécuter des modules comme des scripts"

#: ../Doc/tutorial/modules.rst:124
msgid "When you run a Python module with ::"
msgstr "Lorsque vous exécutez un module Python avec : ::"

#: ../Doc/tutorial/modules.rst:128
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"le code du module sera exécuté comme si vous l'aviez importé, mais son "
"``__name__`` vaudra ``\"__main__\"``. Donc en ajoutant ces lignes à la fin "
"du module : ::"

#: ../Doc/tutorial/modules.rst:136
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"vous pouvez rendre le fichier utilisable comme script aussi bien que comme "
"un module importable, car le code qui parse la ligne de commande n'est lancé "
"que si le module est exécuté comme fichier « main » :"

#: ../Doc/tutorial/modules.rst:145
msgid "If the module is imported, the code is not run::"
msgstr "Si le fichier est importé, le code n'est pas exécuté : ::"

#: ../Doc/tutorial/modules.rst:150
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"C'est typiquement utilisé soit pour proposer une interface utilisateur pour "
"un module, soit pour lancer les tests sur le module (où exécuter le module "
"en temps que script lance les tests)."

#: ../Doc/tutorial/modules.rst:157
msgid "The Module Search Path"
msgstr "Les dossiers de recherche de modules"

#: ../Doc/tutorial/modules.rst:161
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first searches "
"for a built-in module with that name. If not found, it then searches for a "
"file named :file:`spam.py` in a list of directories given by the variable :"
"data:`sys.path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
"Lorsqu'un module nommé par exemple :mod:`spam` est importé, il est d'abord "
"recherché parmis les modules natifs, puis s'il n'y est pas trouvé, "
"l'interpréteur va chercher un fichier nommé :file:`spam.py` dans une liste "
"de dossiers donnés par la variable :data:`sys.path`, :data:`sys.path` est "
"initialisée par défaut à : ::"

#: ../Doc/tutorial/modules.rst:166
msgid "the directory containing the input script (or the current directory)."
msgstr "le dossier contenant le script d'entrée (ou le dossier courant)."

#: ../Doc/tutorial/modules.rst:167
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (une liste de dossiers, utilisant la même syntaxe que "
"la variable shell :envvar:`PATH`)."

#: ../Doc/tutorial/modules.rst:169
msgid "the installation-dependent default."
msgstr "les valeurs par défaut dépendantes de l'installation."

#: ../Doc/tutorial/modules.rst:171
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"Après leur initialisation, les programmes Python peuvent modifier leur :data:"
"`sys.path`. Le dossier contenant le script courant est placé au début de la "
"liste des dossiers à rechercher, avant les dossiers de bibliothèques, Cela "
"signifie qu'un module dans ce dossier, ayant le même nom qu'un module, sera "
"chargé à sa place. C'est une erreur typique, à moins que ce soit voulu. "
"Voir :ref:`tut-standardmodules` pour plus d'informations."

#: ../Doc/tutorial/modules.rst:180
msgid "\"Compiled\" Python files"
msgstr "Fichiers Python \"compilés\""

#: ../Doc/tutorial/modules.rst:182
msgid ""
"As an important speed-up of the start-up time for short programs that use a "
"lot of standard modules, if a file called :file:`spam.pyc` exists in the "
"directory where :file:`spam.py` is found, this is assumed to contain an "
"already-\"byte-compiled\" version of the module :mod:`spam`. The "
"modification time of the version of :file:`spam.py` used to create :file:"
"`spam.pyc` is recorded in :file:`spam.pyc`, and the :file:`.pyc` file is "
"ignored if these don't match."
msgstr ""
"Un gain de temps important au démarrage pour les courts programmes utilisant "
"beaucoup de modules standards, si un fichier :file:`spam.pyc` existe dans le "
"dossier où :file:`spam.py`est trouvé, il est supposé contenir une version "
"compilée du module :mod:`spam`. La date de modification du fichier :file:"
"`spam.py` est utilisée pour créer le fichier :file:`spam.pyc`, et stockée "
"dans le fichier :file:`spam.pyc`, ainsi le fichier :file:`.pyc` est ignoré "
"si ces deux dates ne coïncident pas."

#: ../Doc/tutorial/modules.rst:189
msgid ""
"Normally, you don't need to do anything to create the :file:`spam.pyc` file. "
"Whenever :file:`spam.py` is successfully compiled, an attempt is made to "
"write the compiled version to :file:`spam.pyc`.  It is not an error if this "
"attempt fails; if for any reason the file is not written completely, the "
"resulting :file:`spam.pyc` file will be recognized as invalid and thus "
"ignored later.  The contents of the :file:`spam.pyc` file are platform "
"independent, so a Python module directory can be shared by machines of "
"different architectures."
msgstr ""
"Normalement, vous n'avez rien à faire pour créer un fichier :file:`spam."
"pyc`. Lorsque le fichier :file:`spam.py` est compilé, Python essaye d'écrire "
"la version compilée dans :file:`spam.pyc`. Ce n'est pas une erreur si cette "
"tentative échoue, et si pour n'importe quelle raison, le fichier :file:`."
"pyc` viendrait à ne pas être écrit entièrement, il serait reconnu comme "
"invalide et ignoré. Le contenu du fichier :file:`spam.pyc` est indépendant "
"de la plateforme, donc un dossier contenant des modules Python peut être "
"partagé entre différentes machines de différentes architectures."

#: ../Doc/tutorial/modules.rst:197
msgid "Some tips for experts:"
msgstr "Astuces pour les experts :"

#: ../Doc/tutorial/modules.rst:199
msgid ""
"When the Python interpreter is invoked with the :option:`-O` flag, optimized "
"code is generated and stored in :file:`.pyo` files.  The optimizer currently "
"doesn't help much; it only removes :keyword:`assert` statements.  When :"
"option:`-O` is used, *all* :term:`bytecode` is optimized; ``.pyc`` files are "
"ignored and ``.py`` files are compiled to optimized bytecode."
msgstr ""
"Lorsque l'interpréteur Python est invoqué avec l'option :option:`-O`, un "
"code optimisé est généré et stocké dans des fichiers en :file:`.pyo`. "
"L'optimiseur, aujourd'hui, n'aide pas beaucoup, il ne fait que supprimer les "
"instructions :keyword:`assert`. Lorsque l'option :option:`-O` est utilisée, "
"*tous* les :term:`bytecodes <bytecode>` sont optimisés, les fichiers ``."
"pyc`` sont ignorés, et les fichier ``.py`` compilés en un bytecode optimisé."

#: ../Doc/tutorial/modules.rst:205
msgid ""
"Passing two :option:`-O` flags to the Python interpreter (:option:`-OO`) "
"will cause the bytecode compiler to perform optimizations that could in some "
"rare cases result in malfunctioning programs.  Currently only ``__doc__`` "
"strings are removed from the bytecode, resulting in more compact :file:`."
"pyo` files.  Since some programs may rely on having these available, you "
"should only use this option if you know what you're doing."
msgstr ""
"Donner deux :option:`-O` à l'interpréteur (:option:`-OO`) engendrera un "
"bytecode qui pourrait dans de rare cas provoquer un dysfonctionnement du "
"programme. Actuellement seulement les chaînes ``__doc__`` sont retirés du "
"bytecode, rendant les :file:`.pyo` plus petits. Puisque certains programmes "
"peuvent en avoir besoin, vous ne devriez utiliser cette option que si vous "
"savez ce que vous faites."

#: ../Doc/tutorial/modules.rst:212
msgid ""
"A program doesn't run any faster when it is read from a :file:`.pyc` or :"
"file:`.pyo` file than when it is read from a :file:`.py` file; the only "
"thing that's faster about :file:`.pyc` or :file:`.pyo` files is the speed "
"with which they are loaded."
msgstr ""
"Un programme ne s'exécute pas plus vite lorsqu'il est lu depuis un :file:`."
"pyc` ou :file:`.pyo`, la seule chose qui est plus rapide est la vitesse à "
"laquelle ils sont chargés."

#: ../Doc/tutorial/modules.rst:217
msgid ""
"When a script is run by giving its name on the command line, the bytecode "
"for the script is never written to a :file:`.pyc` or :file:`.pyo` file.  "
"Thus, the startup time of a script may be reduced by moving most of its code "
"to a module and having a small bootstrap script that imports that module.  "
"It is also possible to name a :file:`.pyc` or :file:`.pyo` file directly on "
"the command line."
msgstr ""
"Lorsqu'un programme est lancé en donnant son nom à une invite de commande, "
"le bytecode du script n'est jamais écrit dans un :file:`.pyc` ni :file:`."
"pyo`. Cependant son temps de chargement peut être réduit en déplaçant la "
"plupart de son code vers un module, et n'utiliser qu'un script léger pour "
"importer ce module. Il est aussi possible d'exécuter un fichier :file:`.pyc` "
"ou :file:`.pyo` directement depuis l'invite de commande."

#: ../Doc/tutorial/modules.rst:224
msgid ""
"It is possible to have a file called :file:`spam.pyc` (or :file:`spam.pyo` "
"when :option:`-O` is used) without a file :file:`spam.py` for the same "
"module. This can be used to distribute a library of Python code in a form "
"that is moderately hard to reverse engineer."
msgstr ""
"Il est possible d'avoir un fichier :file:`spam.pyc` (ou :file:`spam.pyo` "
"lorsque :option:`-O` a été utilisée) sans :file:`spam.py` pour un même "
"module. Cela permet de distribuer une bibliothèque Python dans un format qui "
"est modérément compliqué à rétro-ingénierer."

#: ../Doc/tutorial/modules.rst:231
msgid ""
"The module :mod:`compileall` can create :file:`.pyc` files (or :file:`.pyo` "
"files when :option:`-O` is used) for all modules in a directory."
msgstr ""
"Le module :mod:`compileall` peut créer des fichiers :file:`.pyc` (ou :file:`."
"pyo` si l'option :option:`-O` est fournie) pour chaque module d'un dossier."

#: ../Doc/tutorial/modules.rst:238
msgid "Standard Modules"
msgstr "Modules standards"

#: ../Doc/tutorial/modules.rst:242
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"Python est accompagné d'une bibliothèque de modules standards, décrits dans "
"la documentation de la Bibliothèque Python, plus loin. Certains modules sont "
"intégrés dans l'interpréteur, ils exposent des outils qui ne font pas partie "
"du langage, mais qui font tout de même partie de l'interpréteur, soit pour "
"le côté pratique, soit pour exposer des outils essentiels tels que l'accès "
"aux appels systems. La composition de ces modules est configurable à la "
"compilation, et dépend aussi de la plateforme ciblée. Par exemple, le "
"module :mod:`winreg` n'est proposé que sur les systèmes Windows. Un module "
"mérite une attention particulière, le module :mod:`sys`, qui est présent "
"dans tous les interpréteurs Python. Les variables ``sys.ps1`` et ``sys.ps2`` "
"définissent les chaînes d'invites principales et secondaires : ::"

#: ../Doc/tutorial/modules.rst:265
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr ""
"Ces deux variables ne sont définies que si l'interpréteur est en mode "
"interactif."

#: ../Doc/tutorial/modules.rst:267
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"La variable ``sys.path`` est une liste de chaînes qui détermine les chemins "
"de recherche de modules pour l'interpréteur. Il est initialisé à un chemin "
"par défaut pris de la variable d'environnement :envvar:`PYTHONPATH`, ou "
"d'une valeur par défaut interne si :envvar:`PYTHONPATH` n'est pas définie. "
"``sys.path`` est modifiable en utilisant les opérations habituelles des "
"listes : ::"

#: ../Doc/tutorial/modules.rst:280
msgid "The :func:`dir` Function"
msgstr "La fonction :func:`dir`"

#: ../Doc/tutorial/modules.rst:282
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"La fonction interne :func:`dir` est utilisée pour trouver quels noms sont "
"définies par un module. Elle donne une liste triée de chaînes :;"

#: ../Doc/tutorial/modules.rst:305
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr "Sans paramètres, :func:`dir` listes les noms actuellement définis : ::"

#: ../Doc/tutorial/modules.rst:313
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"Notez qu'elle liste tout types de noms : les variables, fonctions, modules, "
"etc."

#: ../Doc/tutorial/modules.rst:317
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`__builtin__`::"
msgstr ""
"La fonction :func:`dir` ne liste pas les noms des fonctions et variables "
"natives.  Si vous en voulez la liste, ils sont définis dans le module "
"standard :mod:`__builtin__`: ::"

#: ../Doc/tutorial/modules.rst:354
msgid "Packages"
msgstr "Les paquets"

#: ../Doc/tutorial/modules.rst:356
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` designates "
"a submodule named ``B`` in a package named ``A``.  Just like the use of "
"modules saves the authors of different modules from having to worry about "
"each other's global variable names, the use of dotted module names saves the "
"authors of multi-module packages like NumPy or the Python Imaging Library "
"from having to worry about each other's module names."
msgstr ""
"Les paquets sont un moyen de structurer les espaces de noms des modules "
"Python en utilisant une notations \"pointée\". Par exemple, le nom de "
"module :mod:`A.B` désigne le sous-module ``B`` du paquet ``A``. De la même "
"manière que l'utilisation des modules évite aux auteurs de différents "
"modules d'avoir à se soucier des noms de variables globales des autres, "
"l'utilisation des noms de modules avec des points évite aux auteurs de "
"paquets contenant plusieurs modules tel que NumPy ou \"Python Image Library"
"\" d'avoir à se soucier des noms des modules des autres."

#: ../Doc/tutorial/modules.rst:364
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"Imaginez que vous voulez constuire une collections de modules (un \"paquet"
"\") pour gérer uniformément les fichiers contenant du son et des données "
"sonores. Il existe un grand nombre de formats de fichiers pour stocker du "
"son (généralement repérés par leur extension, par exemple :file:`.wav`, :"
"file:`.aiff`, :file:`.au`), vous aurez donc envie de créer et maintenir un "
"nombre croissant de modules pour gérer la conversion entre tous ces formats. "
"Il existe aussi tout une floppée d'opérations que vous voudriez pouvoir "
"faire sur du son (mixer, ajouter de l'écho, égaliser, ajouter un effet "
"stéréo articifiel), donc, en plus des modules de conversion, vous allez "
"écrire un nombre illimité de modules permettant d'effectuer ces opérations. "
"Voici une structure possible pour votre paquet (exprimée comme un système de "
"fichier, hierarchiquement) :"

#: ../Doc/tutorial/modules.rst:401
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"Lorsqu'il importe des paquets, Python cherche dans chaque dossiers de ``sys."
"path``, à la recherche du dossier du paquet."

#: ../Doc/tutorial/modules.rst:404
msgid ""
"The :file:`__init__.py` files are required to make Python treat the "
"directories as containing packages; this is done to prevent directories with "
"a common name, such as ``string``, from unintentionally hiding valid modules "
"that occur later on the module search path. In the simplest case, :file:"
"`__init__.py` can just be an empty file, but it can also execute "
"initialization code for the package or set the ``__all__`` variable, "
"described later."
msgstr ""
"Les fichiers :file:`__init__.py` sont nécessaires pour que Python considère "
"les dossiers comme contenant des paquets, ça évite des dossiers ayant des "
"noms courants comme ``string`` de cacher des modules qui auraient été "
"trouvés plus loin dans les dossiers de recherche. Dans le plus simple des "
"cas, :file:`__init__.py` peut être vide, mais il peut exécuter du code "
"d'initialisation pour son paquet ou configurer la variable ``__all__`` "
"(documentée plus loin)."

#: ../Doc/tutorial/modules.rst:411
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"Les utilisateurs d'un module peuvent importer ses modules individuellement, "
"par exemple : ::"

#: ../Doc/tutorial/modules.rst:416
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"Chargera le sous-module :mod:`sound.effects.echo`. Il dit être référencé par "
"son nom complet. ::"

#: ../Doc/tutorial/modules.rst:421
msgid "An alternative way of importing the submodule is::"
msgstr "Une autre manière d'importer des sous-modules est : ::"

#: ../Doc/tutorial/modules.rst:425
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"Chargera aussi le sous-module :mod:`echo`, et le rendra disponible dans le "
"préfixe du paquet, il peut donc être utilisé comme ça : ::"

#: ../Doc/tutorial/modules.rst:430
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr ""
"Une autre méthode consisterait à importer la fonction ou variable désirée "
"directement : ::"

#: ../Doc/tutorial/modules.rst:434
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function :"
"func:`echofilter` directly available::"
msgstr ""
"Le sous-module :mod:`echo` est toujours chargé, mais ici la fonction :func:"
"`echofilter` est disponible directement : ::"

#: ../Doc/tutorial/modules.rst:439
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"Notez que lorsque vous utilisez ``from package import item``, ``item`` peut "
"aussi bien être un sous-module, un sous-paquet, ou simplement un nom déclaré "
"dans le paquet (une variable, une fonction ou une classe). L'instruction "
"``import`` cherche en premier si ``item`` est définit dans le paquet, s'il "
"ne l'est pas, elle cherche à charger un module, et si elle n'y arrive pas, "
"une exception :exc:`ImportError` est levée."

#: ../Doc/tutorial/modules.rst:446
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"Au contraire, en utilisant la syntaxe ``import item.item.subitement."
"subsubitem``, chaque ``item`` sauf le dernier doivent être des paquets. Le "
"dernier ``item`` peut être un module ou un paquet, mais ne peut être ni une "
"fonction, ni une classe, ni une variable défini dans l'élément précédent."

#: ../Doc/tutorial/modules.rst:455
msgid "Importing \\* From a Package"
msgstr "Importer \\* depuis un paquet"

#: ../Doc/tutorial/modules.rst:459
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"Qu'arrive-il lorsqu'un utilisateur écrit ``from sound.effects import *`` ? "
"Dans l'idéal on pourrait espérer que ça irait chercher tous les sous-modules "
"du paquet sur le système de fichiers, et qu'ils seraient tous importés. Ça "
"pourrait être long, et importer certains sous-modules pourrait avoir des "
"effets secondaires indésirables, du moins, désirés seulement lorsque le sous "
"module est importé explicitement."

#: ../Doc/tutorial/modules.rst:465
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"La seule solution, pour l'auteur du paquet, est de fournir un index "
"explicite du contenu du paquet. L'instruction :keyword:`import` utilise la "
"convention suivante: Si le fichier :file:`__init__.py` du paquet définit une "
"liste nommée ``__all__``, cette liste sera utilisée comme liste des noms de "
"modules devant être importés lorsque ``from package import *`` est utilisé. "
"C'est le rôle de l'auteur du paquet de maintenir cette liste à jour lorsque "
"de nouvelles version du paquet sont publiées. Un auteur de paquet peut aussi "
"décider de ne pas autoriser d'importer ``*`` de leur paquet. Par exemple, le "
"fichier :file:`sound/effects/__init__.py` peut contenir le code suivant : ::"

#: ../Doc/tutorial/modules.rst:477
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`sound` package."
msgstr ""
"Cela signifierai que ``from sound.effects import *`` importait les trois "
"sous-modules du paquet :mod:`sound`."

#: ../Doc/tutorial/modules.rst:480
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`sound.effects` into "
"the current namespace; it only ensures that the package :mod:`sound.effects` "
"has been imported (possibly running any initialization code in :file:"
"`__init__.py`) and then imports whatever names are defined in the package.  "
"This includes any names defined (and submodules explicitly loaded) by :file:"
"`__init__.py`.  It also includes any submodules of the package that were "
"explicitly loaded by previous :keyword:`import` statements.  Consider this "
"code::"
msgstr ""
"Si ``__all__`` n'est pas défini, l'instruction ``from sound.effects import "
"*`` n'importera *pas* tous les sous-modules du paquet :mod:`sound.effects` "
"dans l'espace de nom courant, mais s'assurera seulement que le paquet :mod:"
"`sound.effects` à été importé (que tout le code du fichier :file:`__init__."
"py` à été executé) et importe ensuite n'importe quels noms définis dans le "
"paquet. Cela inclu tous les noms définis (et sous modules chargés "
"explicitement) par :file:`__init__.py`. Elle inclu aussi tous les sous-"
"modules du paquet ayant été chargés explicitement par une instruction :"
"keyword:`import`. Typiquement : ::"

#: ../Doc/tutorial/modules.rst:493
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported in "
"the current namespace because they are defined in the :mod:`sound.effects` "
"package when the ``from...import`` statement is executed.  (This also works "
"when ``__all__`` is defined.)"
msgstr ""
"Dans cet exemple, les modules :mod:`echo` et :mod:`surround` sont importés "
"dans l'espace de noms courant lorsque ``from...import`` est exécuté, parce "
"qu'ils sont définis dans le paquet :mod:`sound.effects`. (Cela fonctionne "
"lorsque ``__all__`` est défini.)"

#: ../Doc/tutorial/modules.rst:498
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practise in production code."
msgstr ""
"Bien que certains modules ont été pensés pour n'exporter que les noms "
"respectant une certaine structure lorsque ``import *`` est utilisé, ``import "
"*`` reste considéré comme une mauvaise pratique."

#: ../Doc/tutorial/modules.rst:502
msgid ""
"Remember, there is nothing wrong with using ``from Package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"Rappelez-vous qu'il n'y a rien de mauvais à utiliser ``from Package import "
"specific_submodule`` ! C'est d'ailleurs la manière recommandée à moins que "
"le module qui fait les imports ai besoin de sous-modules ayant le même nom "
"mais provenant se paquets différents."

#: ../Doc/tutorial/modules.rst:509
msgid "Intra-package References"
msgstr "Références internes dans un paquet"

#: ../Doc/tutorial/modules.rst:511
msgid ""
"The submodules often need to refer to each other.  For example, the :mod:"
"`surround` module might use the :mod:`echo` module.  In fact, such "
"references are so common that the :keyword:`import` statement first looks in "
"the containing package before looking in the standard module search path. "
"Thus, the :mod:`surround` module can simply use ``import echo`` or ``from "
"echo import echofilter``.  If the imported module is not found in the "
"current package (the package of which the current module is a submodule), "
"the :keyword:`import` statement looks for a top-level module with the given "
"name."
msgstr ""
"Les sous modules ont souvent besoin de s'utiliser entre eux. Par exemple le "
"module :mod:`surround` pourrait utiliser le module :mod:`echo`. Dans les "
"faits ces références sont si communes que l'instruction clef :keyword:"
"`import` regarde d'abord dans le paquet avant de chercher dans les modules "
"standard. Donc le module :mod:`surround` peut simplement utiliser ``import "
"echo`` ou ``from echo import echofilter``. Si le module n'est pas trouvé "
"dans le paquet courrant (le paquet pour lequel le module actuel est un sous "
"module), l'instruction :keyword:`import` cherchera le nom donné en dehors du "
"paquet."

#: ../Doc/tutorial/modules.rst:520
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`sound.filters."
"vocoder` needs to use the :mod:`echo` module in the :mod:`sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"Lorsque les paquets sont organisés en sous-paquets (comme le paquet :mod:"
"`sound` par exemple), vous pouvez utiliser des imports absolus pour cibler "
"des paquets voisins. Par exemple, si le module :mod:`sound.filters.vocoder` "
"a besoin du module :mod:`echo` du paquet :mod:`sound.effects`, il peut "
"utiliser ``from sound.effects import echo``."

#: ../Doc/tutorial/modules.rst:526
msgid ""
"Starting with Python 2.5, in addition to the implicit relative imports "
"described above, you can write explicit relative imports with the ``from "
"module import name`` form of import statement. These explicit relative "
"imports use leading dots to indicate the current and parent packages "
"involved in the relative import. From the :mod:`surround` module for "
"example, you might use::"
msgstr ""
"Depuis Python 2.5, en plus des imports relatifs décris plus haut, vous "
"pouvez écrire des imports relatifs explicites via la syntaxe ``form module "
"import name``. Ces imports relatifs explicits utilisent le préfixe point (``."
"``) pour indiquer le paquet courant ou le paquet parent. Pour le module :mod:"
"`surround` par exemple vous pourriez utiliser : ::"

#: ../Doc/tutorial/modules.rst:536
msgid ""
"Note that both explicit and implicit relative imports are based on the name "
"of the current module. Since the name of the main module is always ``"
"\"__main__\"``, modules intended for use as the main module of a Python "
"application should always use absolute imports."
msgstr ""
"Notez que les imports relatifs, implicites et explicites, sont basés sur le "
"nom du module courant. Puisque le nom du module principal est toujours ``"
"\"__main__\"``, les modules conçus comme modules principaux d'une "
"application doivent toujours utiliser des imports absolus."

#: ../Doc/tutorial/modules.rst:543
msgid "Packages in Multiple Directories"
msgstr "Paquets dans plusieurs dossiers"

#: ../Doc/tutorial/modules.rst:545
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""
"Les paquets exposent un attribut supplémentaire, :attr:`__path__`, contenant "
"une liste, initialisée avant l'exécution du fichier :file:`__init__.py`, "
"contenant le nom de son dossier dans le système de fichier. Cette liste peut "
"être modifiée, altérant ainsi les futures recherches de modules et sous-"
"paquets contenus dans le paquet."

#: ../Doc/tutorial/modules.rst:551
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"Bien que cette fonctionnalité ne soit que rarement utile, elle peut servir à "
"élargir la liste des modules trouvés dans un paquet."

#: ../Doc/tutorial/modules.rst:556
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/tutorial/modules.rst:557
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition enters the function name in "
"the module's global symbol table."
msgstr ""
"En réalité, la déclaration d'une fonction est elle même une instruction, "
"sont l'exécution enregistre le nom de la fonction dans la table des symboles "
"globaux du module."
