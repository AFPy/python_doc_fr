# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- Arbre Syntaxique Abstrait"

#: ../Doc/library/ast.rst:10
msgid "The low-level ``_ast`` module containing only the node classes."
msgstr ""

#: ../Doc/library/ast.rst:13
msgid "The high-level ``ast`` module containing all helpers."
msgstr ""

#: ../Doc/library/ast.rst:16
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Code source :** :source:`Lib/ast.py`"

#: ../Doc/library/ast.rst:20
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""

#: ../Doc/library/ast.rst:25
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""

#: ../Doc/library/ast.rst:33
msgid "Node classes"
msgstr ""

#: ../Doc/library/ast.rst:37
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""

#: ../Doc/library/ast.rst:42
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""

#: ../Doc/library/ast.rst:52
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""

#: ../Doc/library/ast.rst:55
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""

#: ../Doc/library/ast.rst:59
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""

#: ../Doc/library/ast.rst:68
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno` and :attr:`col_offset` attributes.  The :attr:`lineno` is the line "
"number of source text (1-indexed so the first line is line 1) and the :attr:"
"`col_offset` is the UTF-8 byte offset of the first token that generated the "
"node.  The UTF-8 offset is recorded because the parser uses UTF-8 internally."
msgstr ""

#: ../Doc/library/ast.rst:75
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""

#: ../Doc/library/ast.rst:77
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""

#: ../Doc/library/ast.rst:79
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""

#: ../Doc/library/ast.rst:82
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""

#: ../Doc/library/ast.rst:94
msgid "or the more compact ::"
msgstr "ou, plus compact : ::"

#: ../Doc/library/ast.rst:99
msgid ""
"The constructor as explained above was added.  In Python 2.5 nodes had to be "
"created by calling the class constructor without arguments and setting the "
"attributes afterwards."
msgstr ""

#: ../Doc/library/ast.rst:108
msgid "Abstract Grammar"
msgstr "Grammaire Abstraite"

#: ../Doc/library/ast.rst:110
msgid ""
"The module defines a string constant ``__version__`` which is the decimal "
"Subversion revision number of the file shown below."
msgstr ""

#: ../Doc/library/ast.rst:113
msgid "The abstract grammar is currently defined as follows:"
msgstr ""

#: ../Doc/library/ast.rst:120
msgid ":mod:`ast` Helpers"
msgstr "Outils du module :mod:`ast`"

#: ../Doc/library/ast.rst:124
msgid ""
"Apart from the node classes, :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""

#: ../Doc/library/ast.rst:129
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""

#: ../Doc/library/ast.rst:135
msgid ""
"Safely evaluate an expression node or a Unicode or *Latin-1* encoded string "
"containing a Python literal or container display.  The string or node "
"provided may only consist of the following Python literal structures: "
"strings, numbers, tuples, lists, dicts, booleans, and ``None``."
msgstr ""

#: ../Doc/library/ast.rst:140
msgid ""
"This can be used for safely evaluating strings containing Python values from "
"untrusted sources without the need to parse the values oneself.  It is not "
"capable of evaluating arbitrarily complex expressions, for example involving "
"operators or indexing."
msgstr ""

#: ../Doc/library/ast.rst:148
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`ClassDef` or :class:`Module` node), or ``None`` if it "
"has no docstring.  If *clean* is true, clean up the docstring's indentation "
"with :func:`inspect.cleandoc`."
msgstr ""

#: ../Doc/library/ast.rst:156
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""

#: ../Doc/library/ast.rst:165
msgid ""
"Increment the line number of each node in the tree starting at *node* by "
"*n*. This is useful to \"move code\" to a different location in a file."
msgstr ""

#: ../Doc/library/ast.rst:171
msgid ""
"Copy source location (:attr:`lineno` and :attr:`col_offset`) from *old_node* "
"to *new_node* if possible, and return *new_node*."
msgstr ""

#: ../Doc/library/ast.rst:177
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""

#: ../Doc/library/ast.rst:183
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""

#: ../Doc/library/ast.rst:189
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""

#: ../Doc/library/ast.rst:196
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""

#: ../Doc/library/ast.rst:200
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""

#: ../Doc/library/ast.rst:205
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""

#: ../Doc/library/ast.rst:211
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr ""

#: ../Doc/library/ast.rst:213
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""

#: ../Doc/library/ast.rst:217
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""

#: ../Doc/library/ast.rst:224
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""

#: ../Doc/library/ast.rst:227
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""

#: ../Doc/library/ast.rst:233
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""

#: ../Doc/library/ast.rst:245
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""

#: ../Doc/library/ast.rst:249
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""

#: ../Doc/library/ast.rst:253
msgid "Usually you use the transformer like this::"
msgstr "Utilisation typique du *transformer* ::"

#: ../Doc/library/ast.rst:260
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  The returned string will show the names and the values "
"for fields.  This makes the code impossible to evaluate, so if evaluation is "
"wanted *annotate_fields* must be set to ``False``.  Attributes such as line "
"numbers and column offsets are not dumped by default.  If this is wanted, "
"*include_attributes* can be set to ``True``."
msgstr ""
