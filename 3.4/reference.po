# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2010, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-12-22 00:54+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 1.7.0\n"

#: reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr ""

#: reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""

#: reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""

#: reference/compound_stmts.rst:25
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""

#: reference/compound_stmts.rst:38
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""

#: reference/compound_stmts.rst:44
msgid "Summarizing:"
msgstr ""

#: reference/compound_stmts.rst:63
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""

#: reference/compound_stmts.rst:69
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""

#: reference/compound_stmts.rst:78
#, fuzzy
msgid "The :keyword:`if` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/compound_stmts.rst:87
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ""

#: reference/compound_stmts.rst:94
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""

#: reference/compound_stmts.rst:104
msgid "The :keyword:`while` statement"
msgstr ""

#: reference/compound_stmts.rst:112
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""

#: reference/compound_stmts.rst:119
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`else` clause, if present, is executed and the "
"loop terminates."
msgstr ""

#: reference/compound_stmts.rst:128
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and goes "
"back to testing the expression."
msgstr ""

#: reference/compound_stmts.rst:137
msgid "The :keyword:`for` statement"
msgstr ""

#: reference/compound_stmts.rst:150
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""

#: reference/compound_stmts.rst:157
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""

#: reference/compound_stmts.rst:170
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`else` clause's suite.  A :keyword:`continue` "
"statement executed in the first suite skips the rest of the suite and "
"continues with the next item, or with the :keyword:`else` clause if there is "
"no next item."
msgstr ""

#: reference/compound_stmts.rst:176
msgid ""
"The for-loop makes assignments to the variables(s) in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""

#: reference/compound_stmts.rst:190
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""

#: reference/compound_stmts.rst:202
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, i.e. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""

#: reference/compound_stmts.rst:223
msgid "The :keyword:`try` statement"
msgstr ""

#: reference/compound_stmts.rst:231
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""

#: reference/compound_stmts.rst:244
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`try` suite, a search for "
"an exception handler is started.  This search inspects the except clauses in "
"turn until one is found that matches the exception.  An expression-less "
"except clause, if present, must be last; it matches any exception.  For an "
"except clause with an expression, that expression is evaluated, and the "
"clause matches the exception if the resulting object is \"compatible\" with "
"the exception.  An object is compatible with an exception if it is the class "
"or a base class of the exception object or a tuple containing an item "
"compatible with the exception."
msgstr ""

#: reference/compound_stmts.rst:255
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""

#: reference/compound_stmts.rst:258
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""

#: reference/compound_stmts.rst:263
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must "
"have an executable block.  When the end of this block is reached, execution "
"continues normally after the entire try statement.  (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""

#: reference/compound_stmts.rst:271
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""

#: reference/compound_stmts.rst:277
msgid "was translated to ::"
msgstr ""

#: reference/compound_stmts.rst:285
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""

#: reference/compound_stmts.rst:294
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"stored in the :mod:`sys` module and can be accessed via :func:`sys."
"exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of the "
"exception class, the exception instance and a traceback object (see section :"
"ref:`types`) identifying the point in the program where the exception "
"occurred.  :func:`sys.exc_info` values are restored to their previous values "
"(before the call) when returning from a function that handled an exception."
msgstr ""

#: reference/compound_stmts.rst:308
msgid ""
"The optional :keyword:`else` clause is executed if and when control flows "
"off the end of the :keyword:`try` clause. [#]_ Exceptions in the :keyword:"
"`else` clause are not handled by the preceding :keyword:`except` clauses."
msgstr ""

#: reference/compound_stmts.rst:314
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`else` clauses.  If an exception occurs in any of the clauses and is "
"not handled, the exception is temporarily saved. The :keyword:`finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`finally` clause.  If the :keyword:`finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`finally` clause executes a :keyword:`return` "
"or :keyword:`break` statement, the saved exception is discarded::"
msgstr ""

#: reference/compound_stmts.rst:333
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""

#: reference/compound_stmts.rst:341
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`try`...\\ :keyword:"
"`finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.' A :keyword:`continue` statement is illegal in the :keyword:"
"`finally` clause. (The reason is a problem with the current implementation "
"--- this restriction may be lifted in the future)."
msgstr ""

#: reference/compound_stmts.rst:348
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`return` statement executed in the :keyword:`finally` clause will "
"always be the last one executed::"
msgstr ""

#: reference/compound_stmts.rst:362
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""

#: reference/compound_stmts.rst:371
msgid "The :keyword:`with` statement"
msgstr ""

#: reference/compound_stmts.rst:377
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""

#: reference/compound_stmts.rst:386
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""

#: reference/compound_stmts.rst:388
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""

#: reference/compound_stmts.rst:391
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""

#: reference/compound_stmts.rst:393
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr ""

#: reference/compound_stmts.rst:395
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""

#: reference/compound_stmts.rst:400
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""

#: reference/compound_stmts.rst:406
msgid "The suite is executed."
msgstr ""

#: reference/compound_stmts.rst:408
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""

#: reference/compound_stmts.rst:413
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""

#: reference/compound_stmts.rst:418
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""

#: reference/compound_stmts.rst:422
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""

#: reference/compound_stmts.rst:428 reference/compound_stmts.rst:503
#: reference/compound_stmts.rst:616 reference/compound_stmts.rst:638
msgid "is equivalent to ::"
msgstr ""

#: reference/compound_stmts.rst:434
msgid "Support for multiple context expressions."
msgstr ""

#: reference/compound_stmts.rst:440 reference/datamodel.rst:2178
msgid "PEP 0343 - The \"with\" statement"
msgstr ""

#: reference/compound_stmts.rst:440 reference/datamodel.rst:2178
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""

#: reference/compound_stmts.rst:451
msgid "Function definitions"
msgstr ""

#: reference/compound_stmts.rst:463
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""

#: reference/compound_stmts.rst:480
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""

#: reference/compound_stmts.rst:486
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""

#: reference/compound_stmts.rst:492
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""

#: reference/compound_stmts.rst:512
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""

#: reference/compound_stmts.rst:520
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list or a "
"dictionary: if the function modifies the object (e.g. by appending an item "
"to a list), the default value is in effect modified.  This is generally not "
"what was intended.  A way around this is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""

#: reference/compound_stmts.rst:540
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from position arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple.  If the form \"``**identifier``\" "
"is present, it is initialized to a new dictionary receiving any excess "
"keyword arguments, defaulting to a new empty dictionary. Parameters after "
"\"``*``\" or \"``*identifier``\" are keyword-only parameters and may only be "
"passed used keyword arguments."
msgstr ""

#: reference/compound_stmts.rst:552
msgid ""
"Parameters may have annotations of the form \"``: expression``\" following "
"the parameter name.  Any parameter may have an annotation even those of the "
"form ``*identifier`` or ``**identifier``.  Functions may have \"return\" "
"annotation of the form \"``-> expression``\" after the parameter list.  "
"These annotations can be any valid Python expression and are evaluated when "
"the function definition is executed.  Annotations may be evaluated in a "
"different order than they appear in the source code.  The presence of "
"annotations does not change the semantics of a function.  The annotation "
"values are available as values of a dictionary keyed by the parameters' "
"names in the :attr:`__annotations__` attribute of the function object."
msgstr ""

#: reference/compound_stmts.rst:565
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`def`\" form is actually more powerful since it allows the execution "
"of multiple statements and annotations."
msgstr ""

#: reference/compound_stmts.rst:573
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""

#: reference/compound_stmts.rst:581
msgid "PEP 3107 - Function Annotations"
msgstr ""

#: reference/compound_stmts.rst:582
msgid "The original specification for function annotations."
msgstr ""

#: reference/compound_stmts.rst:588
msgid "Class definitions"
msgstr ""

#: reference/compound_stmts.rst:600
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr ""

#: reference/compound_stmts.rst:607
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""

#: reference/compound_stmts.rst:621
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""

#: reference/compound_stmts.rst:630
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""

#: reference/compound_stmts.rst:632
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr ""

#: reference/compound_stmts.rst:643
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result must be a class object, which is then bound "
"to the class name."
msgstr ""

#: reference/compound_stmts.rst:647
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""

#: reference/compound_stmts.rst:659
msgid ":pep:`3115` - Metaclasses in Python 3 :pep:`3129` - Class Decorators"
msgstr ""

#: reference/compound_stmts.rst:664 reference/datamodel.rst:2258
#: reference/executionmodel.rst:270 reference/expressions.rst:1487
#: reference/import.rst:965 reference/lexical_analysis.rst:731
msgid "Footnotes"
msgstr "Notes"

#: reference/compound_stmts.rst:665
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""

#: reference/compound_stmts.rst:669
msgid ""
"Currently, control \"flows off the end\" except in the case of an exception "
"or the execution of a :keyword:`return`, :keyword:`continue`, or :keyword:"
"`break` statement."
msgstr ""

#: reference/compound_stmts.rst:673
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""

#: reference/compound_stmts.rst:677
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""

#: reference/datamodel.rst:6
msgid "Data model"
msgstr ""

#: reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr ""

#: reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""

#: reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity* "
"never changes once it has been created; you may think of it as the object's "
"address in memory.  The ':keyword:`is`' operator compares the identity of "
"two objects; the :func:`id` function returns an integer representing its "
"identity."
msgstr ""

#: reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr ""

#: reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports (e.g., "
"\"does it have a length?\") and also defines the possible values for objects "
"of that type.  The :func:`type` function returns an object's type (which is "
"an object itself).  Like its identity, an object's :dfn:`type` is also "
"unchangeable. [#]_"
msgstr ""

#: reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change are "
"said to be *mutable*; objects whose value is unchangeable once they are "
"created are called *immutable*. (The value of an immutable container object "
"that contains a reference to a mutable object can change when the latter's "
"value is changed; however the container is still considered immutable, "
"because the collection of objects it contains cannot be changed.  So, "
"immutability is not strictly the same as having an unchangeable value, it is "
"more subtle.) An object's mutability is determined by its type; for "
"instance, numbers, strings and tuples are immutable, while dictionaries and "
"lists are mutable."
msgstr ""

#: reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed to "
"postpone garbage collection or omit it altogether --- it is a matter of "
"implementation quality how garbage collection is implemented, as long as no "
"objects are collected that are still reachable."
msgstr ""

#: reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) delayed "
"detection of cyclically linked garbage, which collects most objects as soon "
"as they become unreachable, but is not guaranteed to collect garbage "
"containing circular references.  See the documentation of the :mod:`gc` "
"module for information on controlling the collection of cyclic garbage. "
"Other implementations act differently and CPython may change. Do not depend "
"on immediate finalization of objects when they become unreachable (so you "
"should always close files explicitly)."
msgstr ""

#: reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities "
"may keep objects alive that would normally be collectable. Also note that "
"catching an exception with a ':keyword:`try`...\\ :keyword:`except`' "
"statement may keep objects alive."
msgstr ""

#: reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open files "
"or windows.  It is understood that these resources are freed when the object "
"is garbage-collected, but since garbage collection is not guaranteed to "
"happen, such objects also provide an explicit way to release the external "
"resource, usually a :meth:`close` method. Programs are strongly recommended "
"to explicitly close such objects.  The ':keyword:`try`...\\ :keyword:"
"`finally`' statement and the ':keyword:`with`' statement provide convenient "
"ways to do this."
msgstr ""

#: reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries.  "
"The references are part of a container's value.  In most cases, when we talk "
"about the value of a container, we imply the values, not the identities of "
"the contained objects; however, when we talk about the mutability of a "
"container, only the identities of the immediately contained objects are "
"implied.  So, if an immutable container (like a tuple) contains a reference "
"to a mutable object, its value changes if that mutable object is changed."
msgstr ""

#: reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance of "
"object identity is affected in some sense: for immutable types, operations "
"that compute new values may actually return a reference to any existing "
"object with the same type and value, while for mutable objects this is not "
"allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may or may not refer "
"to the same object with the value one, depending on the implementation, but "
"after ``c = []; d = []``, ``c`` and ``d`` are guaranteed to refer to two "
"different, unique, newly created empty lists. (Note that ``c = d = []`` "
"assigns the same object to both ``c`` and ``d``.)"
msgstr ""

#: reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr ""

#: reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension modules "
"(written in C, Java, or other languages, depending on the implementation) "
"can define additional types.  Future versions of Python may add types to the "
"type hierarchy (e.g., rational numbers, efficiently stored arrays of "
"integers, etc.), although such additions will often be provided via the "
"standard library instead."
msgstr ""

#: reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the implementation "
"and are not intended for general use.  Their definition may change in the "
"future."
msgstr ""

#: reference/datamodel.rst:150
msgid "None"
msgstr ""

#: reference/datamodel.rst:147
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to "
"signify the absence of a value in many situations, e.g., it is returned from "
"functions that don't explicitly return anything. Its truth value is false."
msgstr ""

#: reference/datamodel.rst:165
msgid "NotImplemented"
msgstr ""

#: reference/datamodel.rst:155
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if they "
"do not implement the operation for the operands provided.  (The interpreter "
"will then try the reflected operation, or some other fallback, depending on "
"the operator.)  Its truth value is true."
msgstr ""

#: reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr ""

#: reference/datamodel.rst:172
msgid "Ellipsis"
msgstr ""

#: reference/datamodel.rst:170
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""

#: reference/datamodel.rst:242
msgid "numbers.Number"
msgstr ""

#: reference/datamodel.rst:177
msgid ""
"These are created by numeric literals and returned as results by arithmetic "
"operators and arithmetic built-in functions.  Numeric objects are immutable; "
"once created their value never changes.  Python numbers are of course "
"strongly related to mathematical numbers, but subject to the limitations of "
"numerical representation in computers."
msgstr ""

#: reference/datamodel.rst:183
msgid ""
"Python distinguishes between integers, floating point numbers, and complex "
"numbers:"
msgstr ""

#: reference/datamodel.rst:217
msgid "numbers.Integral"
msgstr ""

#: reference/datamodel.rst:189
msgid ""
"These represent elements from the mathematical set of integers (positive and "
"negative)."
msgstr ""

#: reference/datamodel.rst:192
msgid "There are two types of integers:"
msgstr ""

#: reference/datamodel.rst:194
msgid "Integers (:class:`int`)"
msgstr ""

#: reference/datamodel.rst:196
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in a "
"variant of 2's complement which gives the illusion of an infinite string of "
"sign bits extending to the left."
msgstr ""

#: reference/datamodel.rst:212
msgid "Booleans (bool)"
msgstr ""

#: reference/datamodel.rst:208
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean objects. "
"The Boolean type is a subtype of the integer type, and Boolean values behave "
"like the values 0 and 1, respectively, in almost all contexts, the exception "
"being that when converted to a string, the strings ``\"False\"`` or ``\"True"
"\"`` are returned, respectively."
msgstr ""

#: reference/datamodel.rst:216
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative "
"integers."
msgstr ""

#: reference/datamodel.rst:232
msgid "numbers.Real (float)"
msgstr ""

#: reference/datamodel.rst:226
msgid ""
"These represent machine-level double precision floating point numbers. You "
"are at the mercy of the underlying machine architecture (and C or Java "
"implementation) for the accepted range and handling of overflow. Python does "
"not support single-precision floating point numbers; the savings in "
"processor and memory usage that are usually the reason for using these are "
"dwarfed by the overhead of using objects in Python, so there is no reason to "
"complicate the language with two kinds of floating point numbers."
msgstr ""

#: reference/datamodel.rst:242
msgid "numbers.Complex (complex)"
msgstr ""

#: reference/datamodel.rst:239
msgid ""
"These represent complex numbers as a pair of machine-level double precision "
"floating point numbers.  The same caveats apply as for floating point "
"numbers. The real and imaginary parts of a complex number ``z`` can be "
"retrieved through the read-only attributes ``z.real`` and ``z.imag``."
msgstr ""

#: reference/datamodel.rst:359
msgid "Sequences"
msgstr ""

#: reference/datamodel.rst:252
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers 0, "
"1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""

#: reference/datamodel.rst:259
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index *k* "
"such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a slice is "
"a sequence of the same type.  This implies that the index set is renumbered "
"so that it starts at 0."
msgstr ""

#: reference/datamodel.rst:264
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x = "
"i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""

#: reference/datamodel.rst:268
msgid "Sequences are distinguished according to their mutability:"
msgstr ""

#: reference/datamodel.rst:325
msgid "Immutable sequences"
msgstr ""

#: reference/datamodel.rst:275
msgid ""
"An object of an immutable sequence type cannot change once it is created.  "
"(If the object contains references to other objects, these other objects may "
"be mutable and may be changed; however, the collection of objects directly "
"referenced by an immutable object cannot change.)"
msgstr ""

#: reference/datamodel.rst:280
msgid "The following types are immutable sequences:"
msgstr ""

#: reference/datamodel.rst:303
msgid "Strings"
msgstr "Les chaînes de caractères"

#: reference/datamodel.rst:293
msgid ""
"A string is a sequence of values that represent Unicode code points. All the "
"code points in the range ``U+0000 - U+10FFFF`` can be represented in a "
"string.  Python doesn't have a :c:type:`char` type; instead, every code "
"point in the string is represented as a string object with length ``1``.  "
"The built-in function :func:`ord` converts a code point from its string form "
"to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an integer "
"in the range ``0 - 10FFFF`` to the corresponding length ``1`` string "
"object. :meth:`str.encode` can be used to convert a :class:`str` to :class:"
"`bytes` using the given text encoding, and :meth:`bytes.decode` can be used "
"to achieve the opposite."
msgstr ""

#: reference/datamodel.rst:316
msgid "Tuples"
msgstr ""

#: reference/datamodel.rst:311
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one "
"item (a 'singleton') can be formed by affixing a comma to an expression (an "
"expression by itself does not create a tuple, since parentheses must be "
"usable for grouping of expressions).  An empty tuple can be formed by an "
"empty pair of parentheses."
msgstr ""

#: reference/datamodel.rst:325
msgid "Bytes"
msgstr ""

#: reference/datamodel.rst:321
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in function :func:`bytes` can be used to construct "
"bytes objects.  Also, bytes objects can be decoded to strings via the :meth:"
"`~bytes.decode` method."
msgstr ""

#: reference/datamodel.rst:359
msgid "Mutable sequences"
msgstr ""

#: reference/datamodel.rst:335
msgid ""
"Mutable sequences can be changed after they are created.  The subscription "
"and slicing notations can be used as the target of assignment and :keyword:"
"`del` (delete) statements."
msgstr ""

#: reference/datamodel.rst:339
msgid "There are currently two intrinsic mutable sequence types:"
msgstr ""

#: reference/datamodel.rst:346
msgid "Lists"
msgstr "Les listes"

#: reference/datamodel.rst:344
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note that "
"there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""

#: reference/datamodel.rst:354
msgid "Byte Arrays"
msgstr ""

#: reference/datamodel.rst:351
msgid ""
"A bytearray object is a mutable array. They are created by the built-in :"
"func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable bytes objects."
msgstr ""

#: reference/datamodel.rst:358
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""

#: reference/datamodel.rst:393
msgid "Set types"
msgstr ""

#: reference/datamodel.rst:366
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be iterated "
"over, and the built-in function :func:`len` returns the number of items in a "
"set. Common uses for sets are fast membership testing, removing duplicates "
"from a sequence, and computing mathematical operations such as intersection, "
"union, difference, and symmetric difference."
msgstr ""

#: reference/datamodel.rst:373
msgid ""
"For set elements, the same immutability rules apply as for dictionary keys. "
"Note that numeric types obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``), only one of them can be "
"contained in a set."
msgstr ""

#: reference/datamodel.rst:378
msgid "There are currently two intrinsic set types:"
msgstr ""

#: reference/datamodel.rst:385
msgid "Sets"
msgstr "Les ensembles"

#: reference/datamodel.rst:383
msgid ""
"These represent a mutable set. They are created by the built-in :func:`set` "
"constructor and can be modified afterwards by several methods, such as :meth:"
"`~set.add`."
msgstr ""

#: reference/datamodel.rst:393
msgid "Frozen sets"
msgstr ""

#: reference/datamodel.rst:390
msgid ""
"These represent an immutable set.  They are created by the built-in :func:"
"`frozenset` constructor.  As a frozenset is immutable and :term:`hashable`, "
"it can be used again as an element of another set, or as a dictionary key."
msgstr ""

#: reference/datamodel.rst:430
msgid "Mappings"
msgstr ""

#: reference/datamodel.rst:401
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. The "
"subscript notation ``a[k]`` selects the item indexed by ``k`` from the "
"mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function :func:`len` "
"returns the number of items in a mapping."
msgstr ""

#: reference/datamodel.rst:407
msgid "There is currently a single intrinsic mapping type:"
msgstr ""

#: reference/datamodel.rst:430
msgid "Dictionaries"
msgstr "Dictionnaires"

#: reference/datamodel.rst:412
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary values.  "
"The only types of values not acceptable as keys are values containing lists "
"or dictionaries or other mutable types that are compared by value rather "
"than by object identity, the reason being that the efficient implementation "
"of dictionaries requires a key's hash value to remain constant. Numeric "
"types used for keys obey the normal rules for numeric comparison: if two "
"numbers compare equal (e.g., ``1`` and ``1.0``) then they can be used "
"interchangeably to index the same dictionary entry."
msgstr ""

#: reference/datamodel.rst:421
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation (see "
"section :ref:`dict`)."
msgstr ""

#: reference/datamodel.rst:428
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide additional "
"examples of mapping types, as does the :mod:`collections` module."
msgstr ""

#: reference/datamodel.rst:656
msgid "Callable types"
msgstr ""

#: reference/datamodel.rst:439
msgid ""
"These are the types to which the function call operation (see section :ref:"
"`calls`) can be applied:"
msgstr ""

#: reference/datamodel.rst:533
msgid "User-defined functions"
msgstr ""

#: reference/datamodel.rst:448
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter list."
msgstr ""

#: reference/datamodel.rst:453
msgid "Special attributes:"
msgstr ""

#: reference/datamodel.rst:458
msgid "Attribute"
msgstr ""

#: reference/datamodel.rst:458 reference/lexical_analysis.rst:478
#: reference/lexical_analysis.rst:511
msgid "Meaning"
msgstr "Signification"

#: reference/datamodel.rst:460
msgid ":attr:`__doc__`"
msgstr ""

#: reference/datamodel.rst:460
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses"
msgstr ""

#: reference/datamodel.rst:460 reference/datamodel.rst:465
#: reference/datamodel.rst:467 reference/datamodel.rst:472
#: reference/datamodel.rst:476 reference/datamodel.rst:482
#: reference/datamodel.rst:492 reference/datamodel.rst:500
#: reference/datamodel.rst:507
msgid "Writable"
msgstr ""

#: reference/datamodel.rst:465
msgid ":attr:`__name__`"
msgstr ""

#: reference/datamodel.rst:465
msgid "The function's name"
msgstr ""

#: reference/datamodel.rst:467
msgid ":attr:`__qualname__`"
msgstr ""

#: reference/datamodel.rst:467
msgid "The function's :term:`qualified name`"
msgstr ""

#: reference/datamodel.rst:472
msgid ":attr:`__module__`"
msgstr ""

#: reference/datamodel.rst:472
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr ""

#: reference/datamodel.rst:476
msgid ":attr:`__defaults__`"
msgstr ""

#: reference/datamodel.rst:476
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value"
msgstr ""

#: reference/datamodel.rst:482
msgid ":attr:`__code__`"
msgstr ""

#: reference/datamodel.rst:482
msgid "The code object representing the compiled function body."
msgstr ""

#: reference/datamodel.rst:485
msgid ":attr:`__globals__`"
msgstr ""

#: reference/datamodel.rst:485
msgid ""
"A reference to the dictionary that holds the function's global variables --- "
"the global namespace of the module in which the function was defined."
msgstr ""

#: reference/datamodel.rst:485 reference/datamodel.rst:496
msgid "Read-only"
msgstr ""

#: reference/datamodel.rst:492
msgid ":attr:`__dict__`"
msgstr ""

#: reference/datamodel.rst:492
msgid "The namespace supporting arbitrary function attributes."
msgstr ""

#: reference/datamodel.rst:496
msgid ":attr:`__closure__`"
msgstr ""

#: reference/datamodel.rst:496
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's free "
"variables."
msgstr ""

#: reference/datamodel.rst:500
msgid ":attr:`__annotations__`"
msgstr ""

#: reference/datamodel.rst:500
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are the "
"parameter names, and ``'return'`` for the return annotation, if provided."
msgstr ""

#: reference/datamodel.rst:507
msgid ":attr:`__kwdefaults__`"
msgstr ""

#: reference/datamodel.rst:507
msgid "A dict containing defaults for keyword-only parameters."
msgstr ""

#: reference/datamodel.rst:511
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the assigned "
"value."
msgstr ""

#: reference/datamodel.rst:513
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular "
"attribute dot-notation is used to get and set such attributes. *Note that "
"the current implementation only supports function attributes on user-defined "
"functions. Function attributes on built-in functions may be supported in the "
"future.*"
msgstr ""

#: reference/datamodel.rst:519
msgid ""
"Additional information about a function's definition can be retrieved from "
"its code object; see the description of internal types below."
msgstr ""

#: reference/datamodel.rst:602
msgid "Instance methods"
msgstr ""

#: reference/datamodel.rst:541
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr ""

#: reference/datamodel.rst:551
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); :attr:`__name__` is "
"the method name (same as ``__func__.__name__``); :attr:`__module__` is the "
"name of the module the method was defined in, or ``None`` if unavailable."
msgstr ""

#: reference/datamodel.rst:557
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr ""

#: reference/datamodel.rst:560
msgid ""
"User-defined method objects may be created when getting an attribute of a "
"class (perhaps via an instance of that class), if that attribute is a user-"
"defined function object or a class method object."
msgstr ""

#: reference/datamodel.rst:564
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its :attr:`__self__` "
"attribute is the instance, and the method object is said to be bound.  The "
"new method's :attr:`__func__` attribute is the original function object."
msgstr ""

#: reference/datamodel.rst:570
msgid ""
"When a user-defined method object is created by retrieving another method "
"object from a class or instance, the behaviour is the same as for a function "
"object, except that the :attr:`__func__` attribute of the new instance is "
"not the original method object but its :attr:`__func__` attribute."
msgstr ""

#: reference/datamodel.rst:576
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the class "
"itself, and its :attr:`__func__` attribute is the function object underlying "
"the class method."
msgstr ""

#: reference/datamodel.rst:581
msgid ""
"When an instance method object is called, the underlying function (:attr:"
"`__func__`) is called, inserting the class instance (:attr:`__self__`) in "
"front of the argument list.  For instance, when :class:`C` is a class which "
"contains a definition for a function :meth:`f`, and ``x`` is an instance of :"
"class:`C`, calling ``x.f(1)`` is equivalent to calling ``C.f(x, 1)``."
msgstr ""

#: reference/datamodel.rst:588
msgid ""
"When an instance method object is derived from a class method object, the "
"\"class instance\" stored in :attr:`__self__` will actually be the class "
"itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to "
"calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""

#: reference/datamodel.rst:593
msgid ""
"Note that the transformation from function object to instance method object "
"happens each time the attribute is retrieved from the instance.  In some "
"cases, a fruitful optimization is to assign the attribute to a local "
"variable and call that local variable. Also notice that this transformation "
"only happens for user-defined functions; other callable objects (and all non-"
"callable objects) are retrieved without transformation.  It is also "
"important to note that user-defined functions which are attributes of a "
"class instance are not converted to bound methods; this *only* happens when "
"the function is an attribute of the class."
msgstr ""

#: reference/datamodel.rst:617
msgid "Generator functions"
msgstr ""

#: reference/datamodel.rst:609
msgid ""
"A function or method which uses the :keyword:`yield` statement (see section :"
"ref:`yield`) is called a :dfn:`generator function`.  Such a function, when "
"called, always returns an iterator object which can be used to execute the "
"body of the function:  calling the iterator's :meth:`iterator.__next__` "
"method will cause the function to execute until it provides a value using "
"the :keyword:`yield` statement.  When the function executes a :keyword:"
"`return` statement or falls off the end, a :exc:`StopIteration` exception is "
"raised and the iterator will have reached the end of the set of values to be "
"returned."
msgstr ""

#: reference/datamodel.rst:632
msgid "Built-in functions"
msgstr ""

#: reference/datamodel.rst:625
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of "
"built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is a "
"standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: :attr:`__doc__` "
"is the function's documentation string, or ``None`` if unavailable; :attr:"
"`__name__` is the function's name; :attr:`__self__` is set to ``None`` (but "
"see the next item); :attr:`__module__` is the name of the module the "
"function was defined in or ``None`` if unavailable."
msgstr ""

#: reference/datamodel.rst:644
msgid "Built-in methods"
msgstr ""

#: reference/datamodel.rst:640
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, assuming "
"*alist* is a list object. In this case, the special read-only attribute :"
"attr:`__self__` is set to the object denoted by *alist*."
msgstr ""

#: reference/datamodel.rst:651
msgid "Classes"
msgstr "Classes"

#: reference/datamodel.rst:647
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that "
"override :meth:`__new__`.  The arguments of the call are passed to :meth:"
"`__new__` and, in the typical case, to :meth:`__init__` to initialize the "
"new instance."
msgstr ""

#: reference/datamodel.rst:656
msgid "Class Instances"
msgstr ""

#: reference/datamodel.rst:654
msgid ""
"Instances of arbitrary classes can be made callable by defining a :meth:"
"`__call__` method in their class."
msgstr ""

#: reference/datamodel.rst:703
msgid "Modules"
msgstr "Modules"

#: reference/datamodel.rst:663
msgid ""
"Modules are a basic organizational unit of Python code, and are created by "
"the :ref:`import system <importsystem>` as invoked either by the :keyword:"
"`import` statement (see :keyword:`import`), or by calling functions such as :"
"func:`importlib.import_module` and built-in :func:`__import__`.  A module "
"object has a namespace implemented by a dictionary object (this is the "
"dictionary referenced by the ``__globals__`` attribute of functions defined "
"in the module).  Attribute references are translated to lookups in this "
"dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``. A module "
"object does not contain the code object used to initialize the module (since "
"it isn't needed once the initialization is done)."
msgstr ""

#: reference/datamodel.rst:675
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., ``m.x "
"= 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""

#: reference/datamodel.rst:680
msgid ""
"Special read-only attribute: :attr:`__dict__` is the module's namespace as a "
"dictionary object."
msgstr ""

#: reference/datamodel.rst:685
msgid ""
"Because of the way CPython clears module dictionaries, the module dictionary "
"will be cleared when the module falls out of scope even if the dictionary "
"still has live references.  To avoid this, copy the dictionary or keep the "
"module around while using its dictionary directly."
msgstr ""

#: reference/datamodel.rst:696
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; :"
"attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__file__` is the pathname of the file from which the "
"module was loaded, if it was loaded from a file. The :attr:`__file__` "
"attribute may be missing for certain types of modules, such as C modules "
"that are statically linked into the interpreter; for extension modules "
"loaded dynamically from a shared library, it is the pathname of the shared "
"library file."
msgstr ""

#: reference/datamodel.rst:759
msgid "Custom classes"
msgstr ""

#: reference/datamodel.rst:706
msgid ""
"Custom class types are typically created by class definitions (see section :"
"ref:`class`).  A class has a namespace implemented by a dictionary object. "
"Class attribute references are translated to lookups in this dictionary, e."
"g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` (although there are a "
"number of hooks which allow for other means of locating attributes). When "
"the attribute name is not found there, the attribute search continues in the "
"base classes. This search of the base classes uses the C3 method resolution "
"order which behaves correctly even in the presence of 'diamond' inheritance "
"structures where there are multiple inheritance paths leading back to a "
"common ancestor. Additional details on the C3 MRO used by Python can be "
"found in the documentation accompanying the 2.3 release at https://www."
"python.org/download/releases/2.3/mro/."
msgstr ""

#: reference/datamodel.rst:730
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield a "
"class method object, it is transformed into an instance method object whose :"
"attr:`__self__` attributes is :class:`C`.  When it would yield a static "
"method object, it is transformed into the object wrapped by the static "
"method object. See section :ref:`descriptors` for another way in which "
"attributes retrieved from a class may differ from those actually contained "
"in its :attr:`__dict__`."
msgstr ""

#: reference/datamodel.rst:740
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr ""

#: reference/datamodel.rst:745
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr ""

#: reference/datamodel.rst:754
msgid ""
"Special attributes: :attr:`__name__` is the class name; :attr:`__module__` "
"is the module name in which the class was defined; :attr:`__dict__` is the "
"dictionary containing the class's namespace; :attr:`~class.__bases__` is a "
"tuple (possibly empty or a singleton) containing the base classes, in the "
"order of their occurrence in the base class list; :attr:`__doc__` is the "
"class's documentation string, or None if undefined."
msgstr ""

#: reference/datamodel.rst:802
msgid "Class instances"
msgstr ""

#: reference/datamodel.rst:768
msgid ""
"A class instance is created by calling a class object (see above).  A class "
"instance has a namespace implemented as a dictionary which is the first "
"place in which attribute references are searched.  When an attribute is not "
"found there, and the instance's class has an attribute by that name, the "
"search continues with the class attributes.  If a class attribute is found "
"that is a user-defined function object, it is transformed into an instance "
"method object whose :attr:`__self__` attribute is the instance.  Static "
"method and class method objects are also transformed; see above under "
"\"Classes\".  See section :ref:`descriptors` for another way in which "
"attributes of a class retrieved via its instances may differ from the "
"objects actually stored in the class's :attr:`__dict__`.  If no class "
"attribute is found, and the object's class has a :meth:`__getattr__` method, "
"that is called to satisfy the lookup."
msgstr ""

#: reference/datamodel.rst:784
msgid ""
"Attribute assignments and deletions update the instance's dictionary, never "
"a class's dictionary.  If the class has a :meth:`__setattr__` or :meth:"
"`__delattr__` method, this is called instead of updating the instance "
"dictionary directly."
msgstr ""

#: reference/datamodel.rst:794
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they "
"have methods with certain special names.  See section :ref:`specialnames`."
msgstr ""

#: reference/datamodel.rst:801
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary; :"
"attr:`~instance.__class__` is the instance's class."
msgstr ""

#: reference/datamodel.rst:828
msgid "I/O objects (also known as file objects)"
msgstr ""

#: reference/datamodel.rst:818
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and "
"also :func:`os.popen`, :func:`os.fdopen`, and the :meth:`~socket.socket."
"makefile` method of socket objects (and perhaps by other functions or "
"methods provided by extension modules)."
msgstr ""

#: reference/datamodel.rst:824
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are initialized "
"to file objects corresponding to the interpreter's standard input, output "
"and error streams; they are all open in text mode and therefore follow the "
"interface defined by the :class:`io.TextIOBase` abstract class."
msgstr ""

#: reference/datamodel.rst:1036
msgid "Internal types"
msgstr ""

#: reference/datamodel.rst:835
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but "
"they are mentioned here for completeness."
msgstr ""

#: reference/datamodel.rst:905
#, fuzzy
msgid "Code objects"
msgstr "Objets Code"

#: reference/datamodel.rst:844
msgid ""
"Code objects represent *byte-compiled* executable Python code, or :term:"
"`bytecode`. The difference between a code object and a function object is "
"that the function object contains an explicit reference to the function's "
"globals (the module in which it was defined), while a code object contains "
"no context; also the default argument values are stored in the function "
"object, not in the code object (because they represent values calculated at "
"run-time).  Unlike function objects, code objects are immutable and contain "
"no references (directly or indirectly) to mutable objects."
msgstr ""

#: reference/datamodel.rst:869
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; :attr:"
"`co_argcount` is the number of positional arguments (including arguments "
"with default values); :attr:`co_nlocals` is the number of local variables "
"used by the function (including arguments); :attr:`co_varnames` is a tuple "
"containing the names of the local variables (starting with the argument "
"names); :attr:`co_cellvars` is a tuple containing the names of local "
"variables that are referenced by nested functions; :attr:`co_freevars` is a "
"tuple containing the names of free variables; :attr:`co_code` is a string "
"representing the sequence of bytecode instructions; :attr:`co_consts` is a "
"tuple containing the literals used by the bytecode; :attr:`co_names` is a "
"tuple containing the names used by the bytecode; :attr:`co_filename` is the "
"filename from which the code was compiled; :attr:`co_firstlineno` is the "
"first line number of the function; :attr:`co_lnotab` is a string encoding "
"the mapping from bytecode offsets to line numbers (for details see the "
"source code of the interpreter); :attr:`co_stacksize` is the required stack "
"size (including local variables); :attr:`co_flags` is an integer encoding a "
"number of flags for the interpreter."
msgstr ""

#: reference/datamodel.rst:888
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is "
"set if the function uses the ``*arguments`` syntax to accept an arbitrary "
"number of positional arguments; bit ``0x08`` is set if the function uses the "
"``**keywords`` syntax to accept arbitrary keyword arguments; bit ``0x20`` is "
"set if the function is a generator."
msgstr ""

#: reference/datamodel.rst:894
msgid ""
"Future feature declarations (``from __future__ import division``) also use "
"bits in :attr:`co_flags` to indicate whether a code object was compiled with "
"a particular feature enabled: bit ``0x2000`` is set if the function was "
"compiled with future division enabled; bits ``0x10`` and ``0x1000`` were "
"used in earlier versions of Python."
msgstr ""

#: reference/datamodel.rst:900
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ""

#: reference/datamodel.rst:904
msgid ""
"If a code object represents a function, the first item in :attr:`co_consts` "
"is the documentation string of the function, or ``None`` if undefined."
msgstr ""

#: reference/datamodel.rst:954
msgid "Frame objects"
msgstr ""

#: reference/datamodel.rst:912
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below)."
msgstr ""

#: reference/datamodel.rst:923
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack frame "
"(towards the caller), or ``None`` if this is the bottom stack frame; :attr:"
"`f_code` is the code object being executed in this frame; :attr:`f_locals` "
"is the dictionary used to look up local variables; :attr:`f_globals` is used "
"for global variables; :attr:`f_builtins` is used for built-in (intrinsic) "
"names; :attr:`f_lasti` gives the precise instruction (this is an index into "
"the bytecode string of the code object)."
msgstr ""

#: reference/datamodel.rst:935
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a function "
"called at the start of each source code line (this is used by the "
"debugger); :attr:`f_lineno` is the current line number of the frame --- "
"writing to this from within a trace function jumps to the given line (only "
"for the bottom-most frame).  A debugger can implement a Jump command (aka "
"Set Next Statement) by writing to f_lineno."
msgstr ""

#: reference/datamodel.rst:942
msgid "Frame objects support one method:"
msgstr ""

#: reference/datamodel.rst:946
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example when "
"catching an exception and storing its traceback for later use)."
msgstr ""

#: reference/datamodel.rst:952
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr ""

#: reference/datamodel.rst:992
msgid "Traceback objects"
msgstr ""

#: reference/datamodel.rst:967
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is created when an exception occurs.  When the search for an "
"exception handler unwinds the execution stack, at each unwound level a "
"traceback object is inserted in front of the current traceback.  When an "
"exception handler is entered, the stack trace is made available to the "
"program. (See section :ref:`try`.) It is accessible as the third item of the "
"tuple returned by ``sys.exc_info()``. When the program contains no suitable "
"handler, the stack trace is written (nicely formatted) to the standard error "
"stream; if the interpreter is interactive, it is also made available to the "
"user as ``sys.last_traceback``."
msgstr ""

#: reference/datamodel.rst:985
msgid ""
"Special read-only attributes: :attr:`tb_next` is the next level in the stack "
"trace (towards the frame where the exception occurred), or ``None`` if there "
"is no next level; :attr:`tb_frame` points to the execution frame of the "
"current level; :attr:`tb_lineno` gives the line number where the exception "
"occurred; :attr:`tb_lasti` indicates the precise instruction.  The line "
"number and last instruction in the traceback may differ from the line number "
"of its frame object if the exception occurred in a :keyword:`try` statement "
"with no matching except clause or with a finally clause."
msgstr ""

#: reference/datamodel.rst:1018
msgid "Slice objects"
msgstr ""

#: reference/datamodel.rst:997
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` methods.  "
"They are also created by the built-in :func:`slice` function."
msgstr ""

#: reference/datamodel.rst:1005
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; :attr:"
"`~slice.stop` is the upper bound; :attr:`~slice.step` is the step value; "
"each is ``None`` if omitted.  These attributes can have any type."
msgstr ""

#: reference/datamodel.rst:1009
msgid "Slice objects support one method:"
msgstr ""

#: reference/datamodel.rst:1013
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if applied "
"to a sequence of *length* items.  It returns a tuple of three integers; "
"respectively these are the *start* and *stop* indices and the *step* or "
"stride length of the slice. Missing or out-of-bounds indices are handled in "
"a manner consistent with regular slices."
msgstr ""

#: reference/datamodel.rst:1028
msgid "Static method objects"
msgstr ""

#: reference/datamodel.rst:1021
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method object "
"is a wrapper around any other object, usually a user-defined method object. "
"When a static method object is retrieved from a class or a class instance, "
"the object actually returned is the wrapped object, which is not subject to "
"any further transformation. Static method objects are not themselves "
"callable, although the objects they wrap usually are. Static method objects "
"are created by the built-in :func:`staticmethod` constructor."
msgstr ""

#: reference/datamodel.rst:1036
msgid "Class method objects"
msgstr ""

#: reference/datamodel.rst:1031
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from "
"classes and class instances. The behaviour of class method objects upon such "
"retrieval is described above, under \"User-defined methods\". Class method "
"objects are created by the built-in :func:`classmethod` constructor."
msgstr ""

#: reference/datamodel.rst:1041
msgid "Special method names"
msgstr ""

#: reference/datamodel.rst:1047
msgid ""
"A class can implement certain operations that are invoked by special syntax "
"(such as arithmetic operations or subscripting and slicing) by defining "
"methods with special names. This is Python's approach to :dfn:`operator "
"overloading`, allowing classes to define their own behavior with respect to "
"language operators.  For instance, if a class defines a method named :meth:"
"`__getitem__`, and ``x`` is an instance of this class, then ``x[i]`` is "
"roughly equivalent to ``type(x).__getitem__(x, i)``.  Except where "
"mentioned, attempts to execute an operation raise an exception when no "
"appropriate method is defined (typically :exc:`AttributeError` or :exc:"
"`TypeError`)."
msgstr ""

#: reference/datamodel.rst:1057
msgid ""
"When implementing a class that emulates any built-in type, it is important "
"that the emulation only be implemented to the degree that it makes sense for "
"the object being modelled.  For example, some sequences may work well with "
"retrieval of individual elements, but extracting a slice may not make "
"sense.  (One example of this is the :class:`~xml.dom.NodeList` interface in "
"the W3C's Document Object Model.)"
msgstr ""

#: reference/datamodel.rst:1068
msgid "Basic customization"
msgstr ""

#: reference/datamodel.rst:1074
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a static "
"method (special-cased so you need not declare it as such) that takes the "
"class of which an instance was requested as its first argument.  The "
"remaining arguments are those passed to the object constructor expression "
"(the call to the class).  The return value of :meth:`__new__` should be the "
"new object instance (usually an instance of *cls*)."
msgstr ""

#: reference/datamodel.rst:1081
msgid ""
"Typical implementations create a new instance of the class by invoking the "
"superclass's :meth:`__new__` method using ``super(currentclass, cls)."
"__new__(cls[, ...])`` with appropriate arguments and then modifying the "
"newly-created instance as necessary before returning it."
msgstr ""

#: reference/datamodel.rst:1086
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's :"
"meth:`__init__` method will be invoked like ``__init__(self[, ...])``, where "
"*self* is the new instance and the remaining arguments are the same as were "
"passed to :meth:`__new__`."
msgstr ""

#: reference/datamodel.rst:1091
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""

#: reference/datamodel.rst:1094
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types "
"(like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""

#: reference/datamodel.rst:1103
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but before "
"it is returned to the caller.  The arguments are those passed to the class "
"constructor expression.  If a base class has an :meth:`__init__` method, the "
"derived class's :meth:`__init__` method, if any, must explicitly call it to "
"ensure proper initialization of the base class part of the instance; for "
"example: ``BaseClass.__init__(self, [args...])``."
msgstr ""

#: reference/datamodel.rst:1110
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in constructing "
"objects (:meth:`__new__` to create it, and :meth:`__init__` to customise "
"it), no non-``None`` value may be returned by :meth:`__init__`; doing so "
"will cause a :exc:`TypeError` to be raised at runtime."
msgstr ""

#: reference/datamodel.rst:1122
msgid ""
"Called when the instance is about to be destroyed.  This is also called a "
"destructor.  If a base class has a :meth:`__del__` method, the derived "
"class's :meth:`__del__` method, if any, must explicitly call it to ensure "
"proper deletion of the base class part of the instance.  Note that it is "
"possible (though not recommended!) for the :meth:`__del__` method to "
"postpone destruction of the instance by creating a new reference to it.  It "
"may then be called at a later time when this new reference is deleted.  It "
"is not guaranteed that :meth:`__del__` methods are called for objects that "
"still exist when the interpreter exits."
msgstr ""

#: reference/datamodel.rst:1134
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements "
"the reference count for ``x`` by one, and the latter is only called when "
"``x``'s reference count reaches zero.  Some common situations that may "
"prevent the reference count of an object from going to zero include: "
"circular references between objects (e.g., a doubly-linked list or a tree "
"data structure with parent and child pointers); a reference to the object on "
"the stack frame of a function that caught an exception (the traceback stored "
"in ``sys.exc_info()[2]`` keeps the stack frame alive); or a reference to the "
"object on the stack frame that raised an unhandled exception in interactive "
"mode (the traceback stored in ``sys.last_traceback`` keeps the stack frame "
"alive).  The first situation can only be remedied by explicitly breaking the "
"cycles; the second can be resolved by freeing the reference to the traceback "
"object when it is no longer useful, and the third can be resolved by storing "
"``None`` in ``sys.last_traceback``. Circular references which are garbage "
"are detected and cleaned up when the cyclic garbage collector is enabled "
"(it's on by default). Refer to the documentation for the :mod:`gc` module "
"for more information about this topic."
msgstr ""

#: reference/datamodel.rst:1156
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods are "
"invoked, exceptions that occur during their execution are ignored, and a "
"warning is printed to ``sys.stderr`` instead.  Also, when :meth:`__del__` is "
"invoked in response to a module being deleted (e.g., when execution of the "
"program is done), other globals referenced by the :meth:`__del__` method may "
"already have been deleted or in the process of being torn down (e.g. the "
"import machinery shutting down).  For this reason, :meth:`__del__` methods "
"should do the absolute minimum needed to maintain external invariants.  "
"Starting with version 1.5, Python guarantees that globals whose name begins "
"with a single underscore are deleted from their module before other globals "
"are deleted; if no other references to such globals exist, this may help in "
"assuring that imported modules are still available at the time when the :"
"meth:`__del__` method is called."
msgstr ""

#: reference/datamodel.rst:1177
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look "
"like a valid Python expression that could be used to recreate an object with "
"the same value (given an appropriate environment).  If this is not possible, "
"a string of the form ``<...some useful description...>`` should be returned. "
"The return value must be a string object. If a class defines :meth:"
"`__repr__` but not :meth:`__str__`, then :meth:`__repr__` is also used when "
"an \"informal\" string representation of instances of that class is required."
msgstr ""

#: reference/datamodel.rst:1186
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr ""

#: reference/datamodel.rst:1197
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions :func:"
"`format` and :func:`print` to compute the \"informal\" or nicely printable "
"string representation of an object.  The return value must be a :ref:`string "
"<textseq>` object."
msgstr ""

#: reference/datamodel.rst:1202
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more "
"convenient or concise representation can be used."
msgstr ""

#: reference/datamodel.rst:1206
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr ""

#: reference/datamodel.rst:1216
msgid ""
"Called by :func:`bytes` to compute a byte-string representation of an "
"object. This should return a ``bytes`` object."
msgstr ""

#: reference/datamodel.rst:1227
msgid ""
"Called by the :func:`format` built-in function (and by extension, the :meth:"
"`str.format` method of class :class:`str`) to produce a \"formatted\" string "
"representation of an object. The ``format_spec`` argument is a string that "
"contains a description of the formatting options desired. The interpretation "
"of the ``format_spec`` argument is up to the type implementing :meth:"
"`__format__`, however most classes will either delegate formatting to one of "
"the built-in types, or use a similar formatting option syntax."
msgstr ""

#: reference/datamodel.rst:1236
msgid ""
"See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr ""

#: reference/datamodel.rst:1238
msgid "The return value must be a string object."
msgstr ""

#: reference/datamodel.rst:1240
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""

#: reference/datamodel.rst:1256
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls ``x."
"__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, "
"``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` "
"calls ``x.__ge__(y)``."
msgstr ""

#: reference/datamodel.rst:1262
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if it "
"does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful comparison. "
"However, these methods can return any value, so if the comparison operator "
"is used in a Boolean context (e.g., in the condition of an ``if`` "
"statement), Python will call :func:`bool` on the value to determine if the "
"result is true or false."
msgstr ""

#: reference/datamodel.rst:1269
msgid ""
"By default, :meth:`__ne__` delegates to :meth:`__eq__` and inverts the "
"result unless it is ``NotImplemented``.  There are no other implied "
"relationships among the comparison operators, for example, the truth of "
"``(x<y or x==y)`` does not imply ``x<=y``. To automatically generate "
"ordering operations from a single root operation, see :func:`functools."
"total_ordering`."
msgstr ""

#: reference/datamodel.rst:1276
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on creating :"
"term:`hashable` objects which support custom comparison operations and are "
"usable as dictionary keys."
msgstr ""

#: reference/datamodel.rst:1280
msgid ""
"There are no swapped-argument versions of these methods (to be used when the "
"left argument does not support the operation but the right argument does); "
"rather, :meth:`__lt__` and :meth:`__gt__` are each other's reflection, :meth:"
"`__le__` and :meth:`__ge__` are each other's reflection, and :meth:`__eq__` "
"and :meth:`__ne__` are their own reflection. If the operands are of "
"different types, and right operand's type is a direct or indirect subclass "
"of the left operand's type, the reflected method of the right operand has "
"priority, otherwise the left operand's method has priority.  Virtual "
"subclassing is not considered."
msgstr ""

#: reference/datamodel.rst:1297
msgid ""
"Called by built-in function :func:`hash` and for operations on members of "
"hashed collections including :class:`set`, :class:`frozenset`, and :class:"
"`dict`.  :meth:`__hash__` should return an integer.  The only required "
"property is that objects which compare equal have the same hash value; it is "
"advised to somehow mix together (e.g. using exclusive or) the hash values "
"for the components of the object that also play a part in comparison of "
"objects."
msgstr ""

#: reference/datamodel.rst:1307
msgid ""
":func:`hash` truncates the value returned from an object's custom :meth:"
"`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is typically "
"8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an object's   :"
"meth:`__hash__` must interoperate on builds of different bit sizes, be sure "
"to check the width on all supported builds.  An easy way to do this is with "
"``python -c \"import sys; print(sys.hash_info.width)\"``."
msgstr ""

#: reference/datamodel.rst:1315
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define a :"
"meth:`__hash__` operation either; if it defines :meth:`__eq__` but not :meth:"
"`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an :meth:"
"`__eq__` method, it should not implement :meth:`__hash__`, since the "
"implementation of hashable collections requires that a key's hash value is "
"immutable (if the object's hash value changes, it will be in the wrong hash "
"bucket)."
msgstr ""

#: reference/datamodel.rst:1324
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) and "
"``x.__hash__()`` returns an appropriate value such that ``x == y`` implies "
"both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""

#: reference/datamodel.rst:1329
msgid ""
"A class that overrides :meth:`__eq__` and does not define :meth:`__hash__` "
"will have its :meth:`__hash__` implicitly set to ``None``.  When the :meth:"
"`__hash__` method of a class is ``None``, instances of the class will raise "
"an appropriate :exc:`TypeError` when a program attempts to retrieve their "
"hash value, and will also be correctly identified as unhashable when "
"checking ``isinstance(obj, collections.Hashable)``."
msgstr ""

#: reference/datamodel.rst:1336
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the implementation "
"of :meth:`__hash__` from a parent class, the interpreter must be told this "
"explicitly by setting ``__hash__ = <ParentClass>.__hash__``."
msgstr ""

#: reference/datamodel.rst:1340
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A "
"class which defines its own :meth:`__hash__` that explicitly raises a :exc:"
"`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.Hashable)`` call."
msgstr ""

#: reference/datamodel.rst:1349
msgid ""
"By default, the :meth:`__hash__` values of str, bytes and datetime objects "
"are \"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""

#: reference/datamodel.rst:1354
msgid ""
"This is intended to provide protection against a denial-of-service caused by "
"carefully-chosen inputs that exploit the worst case performance of a dict "
"insertion, O(n^2) complexity.  See http://www.ocert.org/advisories/"
"ocert-2011-003.html for details."
msgstr ""

#: reference/datamodel.rst:1359
msgid ""
"Changing hash values affects the iteration order of dicts, sets and other "
"mappings.  Python has never made guarantees about this ordering (and it "
"typically varies between 32-bit and 64-bit builds)."
msgstr ""

#: reference/datamodel.rst:1363
#, fuzzy
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr "Voir aussi :envvar:`PYTHONUNBUFFERED`."

#: reference/datamodel.rst:1365
msgid "Hash randomization is enabled by default."
msgstr ""

#: reference/datamodel.rst:1373
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not "
"defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither :meth:"
"`__len__` nor :meth:`__bool__`, all its instances are considered true."
msgstr ""

#: reference/datamodel.rst:1384
msgid "Customizing attribute access"
msgstr ""

#: reference/datamodel.rst:1386
msgid ""
"The following methods can be defined to customize the meaning of attribute "
"access (use of, assignment to, or deletion of ``x.name``) for class "
"instances."
msgstr ""

#: reference/datamodel.rst:1394
msgid ""
"Called when an attribute lookup has not found the attribute in the usual "
"places (i.e. it is not an instance attribute nor is it found in the class "
"tree for ``self``).  ``name`` is the attribute name. This method should "
"return the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""

#: reference/datamodel.rst:1399
msgid ""
"Note that if the attribute is found through the normal mechanism, :meth:"
"`__getattr__` is not called.  (This is an intentional asymmetry between :"
"meth:`__getattr__` and :meth:`__setattr__`.) This is done both for "
"efficiency reasons and because otherwise :meth:`__getattr__` would have no "
"way to access other attributes of the instance.  Note that at least for "
"instance variables, you can fake total control by not inserting any values "
"in the instance attribute dictionary (but instead inserting them in another "
"object).  See the :meth:`__getattribute__` method below for a way to "
"actually get total control over attribute access."
msgstr ""

#: reference/datamodel.rst:1412
msgid ""
"Called unconditionally to implement attribute accesses for instances of the "
"class. If the class also defines :meth:`__getattr__`, the latter will not be "
"called unless :meth:`__getattribute__` either calls it explicitly or raises "
"an :exc:`AttributeError`. This method should return the (computed) attribute "
"value or raise an :exc:`AttributeError` exception. In order to avoid "
"infinite recursion in this method, its implementation should always call the "
"base class method with the same name to access any attributes it needs, for "
"example, ``object.__getattribute__(self, name)``."
msgstr ""

#: reference/datamodel.rst:1423
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr ""

#: reference/datamodel.rst:1430
msgid ""
"Called when an attribute assignment is attempted.  This is called instead of "
"the normal mechanism (i.e. store the value in the instance dictionary). "
"*name* is the attribute name, *value* is the value to be assigned to it."
msgstr ""

#: reference/datamodel.rst:1434
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it should "
"call the base class method with the same name, for example, ``object."
"__setattr__(self, name, value)``."
msgstr ""

#: reference/datamodel.rst:1441
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of assignment.  "
"This should only be implemented if ``del obj.name`` is meaningful for the "
"object."
msgstr ""

#: reference/datamodel.rst:1447
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts it."
msgstr ""

#: reference/datamodel.rst:1454
msgid "Implementing Descriptors"
msgstr ""

#: reference/datamodel.rst:1456
msgid ""
"The following methods only apply when an instance of the class containing "
"the method (a so-called *descriptor* class) appears in an *owner* class (the "
"descriptor must be in either the owner's class dictionary or in the class "
"dictionary for one of its parents).  In the examples below, \"the attribute"
"\" refers to the attribute whose name is the key of the property in the "
"owner class' :attr:`__dict__`."
msgstr ""

#: reference/datamodel.rst:1466
msgid ""
"Called to get the attribute of the owner class (class attribute access) or "
"of an instance of that class (instance attribute access). *owner* is always "
"the owner class, while *instance* is the instance that the attribute was "
"accessed through, or ``None`` when the attribute is accessed through the "
"*owner*.  This method should return the (computed) attribute value or raise "
"an :exc:`AttributeError` exception."
msgstr ""

#: reference/datamodel.rst:1476
msgid ""
"Called to set the attribute on an instance *instance* of the owner class to "
"a new value, *value*."
msgstr ""

#: reference/datamodel.rst:1482
msgid ""
"Called to delete the attribute on an instance *instance* of the owner class."
msgstr ""

#: reference/datamodel.rst:1485
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting this "
"appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given "
"type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods that "
"are implemented in C)."
msgstr ""

#: reference/datamodel.rst:1496
msgid "Invoking Descriptors"
msgstr ""

#: reference/datamodel.rst:1498
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol:  :meth:`__get__`, :meth:`__set__`, and :meth:`__delete__`. If any "
"of those methods are defined for an object, it is said to be a descriptor."
msgstr ""

#: reference/datamodel.rst:1503
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses."
msgstr ""

#: reference/datamodel.rst:1508
msgid ""
"However, if the looked-up value is an object defining one of the descriptor "
"methods, then Python may override the default behavior and invoke the "
"descriptor method instead.  Where this occurs in the precedence chain "
"depends on which descriptor methods were defined and how they were called."
msgstr ""

#: reference/datamodel.rst:1513
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How the "
"arguments are assembled depends on ``a``:"
msgstr ""

#: reference/datamodel.rst:1518
msgid "Direct Call"
msgstr ""

#: reference/datamodel.rst:1517
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr ""

#: reference/datamodel.rst:1522
msgid "Instance Binding"
msgstr ""

#: reference/datamodel.rst:1521
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""

#: reference/datamodel.rst:1526
msgid "Class Binding"
msgstr ""

#: reference/datamodel.rst:1525
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: ``A."
"__dict__['x'].__get__(None, A)``."
msgstr ""

#: reference/datamodel.rst:1532
msgid "Super Binding"
msgstr ""

#: reference/datamodel.rst:1529
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, obj)."
"m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the call: "
"``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""

#: reference/datamodel.rst:1534
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on "
"the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  If "
"it does not define :meth:`__get__`, then accessing the attribute will return "
"the descriptor object itself unless there is a value in the object's "
"instance dictionary.  If the descriptor defines :meth:`__set__` and/or :meth:"
"`__delete__`, it is a data descriptor; if it defines neither, it is a non-"
"data descriptor.  Normally, data descriptors define both :meth:`__get__` "
"and :meth:`__set__`, while non-data descriptors have just the :meth:"
"`__get__` method.  Data descriptors with :meth:`__set__` and :meth:`__get__` "
"defined always override a redefinition in an instance dictionary.  In "
"contrast, non-data descriptors can be overridden by instances."
msgstr ""

#: reference/datamodel.rst:1547
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) are "
"implemented as non-data descriptors.  Accordingly, instances can redefine "
"and override methods.  This allows individual instances to acquire behaviors "
"that differ from other instances of the same class."
msgstr ""

#: reference/datamodel.rst:1552
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""

#: reference/datamodel.rst:1559
msgid "__slots__"
msgstr "__slots__"

#: reference/datamodel.rst:1561
msgid ""
"By default, instances of classes have a dictionary for attribute storage.  "
"This wastes space for objects having very few instance variables.  The space "
"consumption can become acute when creating large numbers of instances."
msgstr ""

#: reference/datamodel.rst:1565
msgid ""
"The default can be overridden by defining *__slots__* in a class definition. "
"The *__slots__* declaration takes a sequence of instance variables and "
"reserves just enough space in each instance to hold a value for each "
"variable.  Space is saved because *__dict__* is not created for each "
"instance."
msgstr ""

#: reference/datamodel.rst:1573
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves space "
"for the declared variables and prevents the automatic creation of *__dict__* "
"and *__weakref__* for each instance."
msgstr ""

#: reference/datamodel.rst:1580
msgid "Notes on using *__slots__*"
msgstr ""

#: reference/datamodel.rst:1582
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* attribute "
"of that class will always be accessible, so a *__slots__* definition in the "
"subclass is meaningless."
msgstr ""

#: reference/datamodel.rst:1586
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables "
"not listed in the *__slots__* definition.  Attempts to assign to an unlisted "
"variable name raises :exc:`AttributeError`. If dynamic assignment of new "
"variables is desired, then add ``'__dict__'`` to the sequence of strings in "
"the *__slots__* declaration."
msgstr ""

#: reference/datamodel.rst:1592
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence of "
"strings in the *__slots__* declaration."
msgstr ""

#: reference/datamodel.rst:1597
msgid ""
"*__slots__* are implemented at the class level by creating descriptors (:ref:"
"`descriptors`) for each variable name.  As a result, class attributes cannot "
"be used to set default values for instance variables defined by *__slots__*; "
"otherwise, the class attribute would overwrite the descriptor assignment."
msgstr ""

#: reference/datamodel.rst:1603
msgid ""
"The action of a *__slots__* declaration is limited to the class where it is "
"defined.  As a result, subclasses will have a *__dict__* unless they also "
"define *__slots__* (which must only contain names of any *additional* slots)."
msgstr ""

#: reference/datamodel.rst:1607
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the "
"meaning of the program undefined.  In the future, a check may be added to "
"prevent this."
msgstr ""

#: reference/datamodel.rst:1612
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-length"
"\" built-in types such as :class:`int`, :class:`bytes` and :class:`tuple`."
msgstr ""

#: reference/datamodel.rst:1615
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also be "
"used; however, in the future, special meaning may be assigned to the values "
"corresponding to each key."
msgstr ""

#: reference/datamodel.rst:1619
msgid ""
"*__class__* assignment works only if both classes have the same *__slots__*."
msgstr ""

#: reference/datamodel.rst:1625
msgid "Customizing class creation"
msgstr ""

#: reference/datamodel.rst:1627
msgid ""
"By default, classes are constructed using :func:`type`. The class body is "
"executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""

#: reference/datamodel.rst:1631
msgid ""
"The class creation process can be customised by passing the ``metaclass`` "
"keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""

#: reference/datamodel.rst:1645
msgid ""
"Any other keyword arguments that are specified in the class definition are "
"passed through to all metaclass operations described below."
msgstr ""

#: reference/datamodel.rst:1648
msgid "When a class definition is executed, the following steps occur:"
msgstr ""

#: reference/datamodel.rst:1650
msgid "the appropriate metaclass is determined"
msgstr ""

#: reference/datamodel.rst:1651
msgid "the class namespace is prepared"
msgstr ""

#: reference/datamodel.rst:1652
msgid "the class body is executed"
msgstr ""

#: reference/datamodel.rst:1653
msgid "the class object is created"
msgstr ""

#: reference/datamodel.rst:1656
msgid "Determining the appropriate metaclass"
msgstr ""

#: reference/datamodel.rst:1658
msgid ""
"The appropriate metaclass for a class definition is determined as follows:"
msgstr ""

#: reference/datamodel.rst:1660
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is used"
msgstr ""

#: reference/datamodel.rst:1661
msgid ""
"if an explicit metaclass is given and it is *not* an instance of :func:"
"`type`, then it is used directly as the metaclass"
msgstr ""

#: reference/datamodel.rst:1663
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or bases "
"are defined, then the most derived metaclass is used"
msgstr ""

#: reference/datamodel.rst:1666
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all specified "
"base classes. The most derived metaclass is one which is a subtype of *all* "
"of these candidate metaclasses. If none of the candidate metaclasses meets "
"that criterion, then the class definition will fail with ``TypeError``."
msgstr ""

#: reference/datamodel.rst:1676
msgid "Preparing the class namespace"
msgstr ""

#: reference/datamodel.rst:1678
msgid ""
"Once the appropriate metaclass has been identified, then the class namespace "
"is prepared. If the metaclass has a ``__prepare__`` attribute, it is called "
"as ``namespace = metaclass.__prepare__(name, bases, **kwds)`` (where the "
"additional keyword arguments, if any, come from the class definition)."
msgstr ""

#: reference/datamodel.rst:1683
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class namespace "
"is initialised as an empty :func:`dict` instance."
msgstr ""

#: reference/datamodel.rst:1688
msgid "PEP 3115 - Metaclasses in Python 3000"
msgstr ""

#: reference/datamodel.rst:1689
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr ""

#: reference/datamodel.rst:1693
msgid "Executing the class body"
msgstr ""

#: reference/datamodel.rst:1695
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is that "
"lexical scoping allows the class body (including any methods) to reference "
"names from the current and outer scopes when the class definition occurs "
"inside a function."
msgstr ""

#: reference/datamodel.rst:1701
msgid ""
"However, even when the class definition occurs inside the function, methods "
"defined inside the class still cannot see names defined at the class scope. "
"Class variables must be accessed through the first parameter of instance or "
"class methods, and cannot be accessed at all from static methods."
msgstr ""

#: reference/datamodel.rst:1708
msgid "Creating the class object"
msgstr ""

#: reference/datamodel.rst:1710
msgid ""
"Once the class namespace has been populated by executing the class body, the "
"class object is created by calling ``metaclass(name, bases, namespace, "
"**kwds)`` (the additional keywords passed here are the same as those passed "
"to ``__prepare__``)."
msgstr ""

#: reference/datamodel.rst:1715
msgid ""
"This class object is the one that will be referenced by the zero-argument "
"form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of :func:"
"`super` to correctly identify the class being defined based on lexical "
"scoping, while the class or instance that was used to make the current call "
"is identified based on the first argument passed to the method."
msgstr ""

#: reference/datamodel.rst:1723
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is bound "
"in the local namespace as the defined class."
msgstr ""

#: reference/datamodel.rst:1729
msgid "PEP 3135 - New super"
msgstr ""

#: reference/datamodel.rst:1730
msgid "Describes the implicit ``__class__`` closure reference"
msgstr ""

#: reference/datamodel.rst:1734
msgid "Metaclass example"
msgstr ""

#: reference/datamodel.rst:1736
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have been "
"explored include logging, interface checking, automatic delegation, "
"automatic property creation, proxies, frameworks, and automatic resource "
"locking/synchronization."
msgstr ""

#: reference/datamodel.rst:1741
msgid ""
"Here is an example of a metaclass that uses an :class:`collections."
"OrderedDict` to remember the order that class variables are defined::"
msgstr ""

#: reference/datamodel.rst:1764
msgid ""
"When the class definition for *A* gets executed, the process begins with "
"calling the metaclass's :meth:`__prepare__` method which returns an empty :"
"class:`collections.OrderedDict`.  That mapping records the methods and "
"attributes of *A* as they are defined within the body of the class "
"statement. Once those definitions are executed, the ordered dictionary is "
"fully populated and the metaclass's :meth:`__new__` method gets invoked.  "
"That method builds the new type and it saves the ordered dictionary keys in "
"an attribute called ``members``."
msgstr ""

#: reference/datamodel.rst:1775
msgid "Customizing instance and subclass checks"
msgstr ""

#: reference/datamodel.rst:1777
msgid ""
"The following methods are used to override the default behavior of the :func:"
"`isinstance` and :func:`issubclass` built-in functions."
msgstr ""

#: reference/datamodel.rst:1780
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these methods "
"in order to allow the addition of Abstract Base Classes (ABCs) as \"virtual "
"base classes\" to any class or type (including built-in types), including "
"other ABCs."
msgstr ""

#: reference/datamodel.rst:1787
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement ``isinstance(instance, "
"class)``."
msgstr ""

#: reference/datamodel.rst:1794
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement ``issubclass(subclass, "
"class)``."
msgstr ""

#: reference/datamodel.rst:1799
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class.  "
"They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on instances, "
"only in this case the instance is itself a class."
msgstr ""

#: reference/datamodel.rst:1810
msgid "PEP 3119 - Introducing Abstract Base Classes"
msgstr ""

#: reference/datamodel.rst:1807
msgid ""
"Includes the specification for customizing :func:`isinstance` and :func:"
"`issubclass` behavior through :meth:`~class.__instancecheck__` and :meth:"
"`~class.__subclasscheck__`, with motivation for this functionality in the "
"context of adding Abstract Base Classes (see the :mod:`abc` module) to the "
"language."
msgstr ""

#: reference/datamodel.rst:1817
msgid "Emulating callable objects"
msgstr ""

#: reference/datamodel.rst:1824
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, "
"arg2, ...)``."
msgstr ""

#: reference/datamodel.rst:1831
msgid "Emulating container types"
msgstr ""

#: reference/datamodel.rst:1833
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings (like "
"dictionaries), but can represent other containers as well.  The first set of "
"methods is used either to emulate a sequence or to emulate a mapping; the "
"difference is that for a sequence, the allowable keys should be the integers "
"*k* for which ``0 <= k < N`` where *N* is the length of the sequence, or "
"slice objects, which define a range of items.  It is also recommended that "
"mappings provide the methods :meth:`keys`, :meth:`values`, :meth:`items`, :"
"meth:`get`, :meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:"
"`popitem`, :meth:`!copy`, and :meth:`update` behaving similar to those for "
"Python's standard dictionary objects.  The :mod:`collections` module "
"provides a :class:`~collections.abc.MutableMapping` abstract base class to "
"help create those methods from a base set of :meth:`__getitem__`, :meth:"
"`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable sequences "
"should provide methods :meth:`append`, :meth:`count`, :meth:`index`, :meth:"
"`extend`, :meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse` and :"
"meth:`sort`, like Python standard list objects.  Finally, sequence types "
"should implement addition (meaning concatenation) and multiplication "
"(meaning repetition) by defining the methods :meth:`__add__`, :meth:"
"`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__` and :meth:"
"`__imul__` described below; they should not define other numerical "
"operators.  It is recommended that both mappings and sequences implement "
"the :meth:`__contains__` method to allow efficient use of the ``in`` "
"operator; for mappings, ``in`` should search the mapping's keys; for "
"sequences, it should search through the values.  It is further recommended "
"that both mappings and sequences implement the :meth:`__iter__` method to "
"allow efficient iteration through the container; for mappings, :meth:"
"`__iter__` should be the same as :meth:`keys`; for sequences, it should "
"iterate through the values."
msgstr ""

#: reference/datamodel.rst:1868
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the "
"length of the object, an integer ``>=`` 0.  Also, an object that doesn't "
"define a :meth:`__bool__` method and whose :meth:`__len__` method returns "
"zero is considered to be false in a Boolean context."
msgstr ""

#: reference/datamodel.rst:1876
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an estimated "
"length for the object (which may be greater or less than the actual length). "
"The length must be an integer ``>=`` 0. This method is purely an "
"optimization and is never required for correctness."
msgstr ""

#: reference/datamodel.rst:1885
msgid ""
"Slicing is done exclusively with the following three methods.  A call like ::"
msgstr ""

#: reference/datamodel.rst:1889
msgid "is translated to ::"
msgstr ""

#: reference/datamodel.rst:1893
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr ""

#: reference/datamodel.rst:1900
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the special "
"interpretation of negative indexes (if the class wishes to emulate a "
"sequence type) is up to the :meth:`__getitem__` method. If *key* is of an "
"inappropriate type, :exc:`TypeError` may be raised; if of a value outside "
"the set of indexes for the sequence (after any special interpretation of "
"negative values), :exc:`IndexError` should be raised. For mapping types, if "
"*key* is missing (not in the container), :exc:`KeyError` should be raised."
msgstr ""

#: reference/datamodel.rst:1911
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""

#: reference/datamodel.rst:1917
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement ``self[key]`` "
"for dict subclasses when key is not in the dictionary."
msgstr ""

#: reference/datamodel.rst:1923
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support changes to the values for keys, or if new keys can be added, or for "
"sequences if elements can be replaced.  The same exceptions should be raised "
"for improper *key* values as for the :meth:`__getitem__` method."
msgstr ""

#: reference/datamodel.rst:1932
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for :meth:"
"`__getitem__`.  This should only be implemented for mappings if the objects "
"support removal of keys, or for sequences if elements can be removed from "
"the sequence.  The same exceptions should be raised for improper *key* "
"values as for the :meth:`__getitem__` method."
msgstr ""

#: reference/datamodel.rst:1941
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys of "
"the container."
msgstr ""

#: reference/datamodel.rst:1945
msgid ""
"Iterator objects also need to implement this method; they are required to "
"return themselves.  For more information on iterator objects, see :ref:"
"`typeiter`."
msgstr ""

#: reference/datamodel.rst:1951
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse "
"iteration.  It should return a new iterator object that iterates over all "
"the objects in the container in reverse order."
msgstr ""

#: reference/datamodel.rst:1955
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` and :"
"meth:`__getitem__`).  Objects that support the sequence protocol should only "
"provide :meth:`__reversed__` if they can provide an implementation that is "
"more efficient than the one provided by :func:`reversed`."
msgstr ""

#: reference/datamodel.rst:1962
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, container "
"objects can supply the following special method with a more efficient "
"implementation, which also does not require the object be a sequence."
msgstr ""

#: reference/datamodel.rst:1969
msgid ""
"Called to implement membership test operators.  Should return true if *item* "
"is in *self*, false otherwise.  For mapping objects, this should consider "
"the keys of the mapping rather than the values or the key-item pairs."
msgstr ""

#: reference/datamodel.rst:1973
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence iteration "
"protocol via :meth:`__getitem__`, see :ref:`this section in the language "
"reference <membership-test-details>`."
msgstr ""

#: reference/datamodel.rst:1982
msgid "Emulating numeric types"
msgstr ""

#: reference/datamodel.rst:1984
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind of "
"number implemented (e.g., bitwise operations for non-integral numbers) "
"should be left undefined."
msgstr ""

#: reference/datamodel.rst:2009
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, "
"``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance, to evaluate the "
"expression ``x + y``, where *x* is an instance of a class that has an :meth:"
"`__add__` method, ``x.__add__(y)`` is called.  The :meth:`__divmod__` method "
"should be the equivalent to using :meth:`__floordiv__` and :meth:`__mod__`; "
"it should not be related to :meth:`__truediv__`.  Note that :meth:`__pow__` "
"should be defined to accept an optional third argument if the ternary "
"version of the built-in :func:`pow` function is to be supported."
msgstr ""

#: reference/datamodel.rst:2019
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr ""

#: reference/datamodel.rst:2041
msgid ""
"These methods are called to implement the binary arithmetic operations (``"
"+``, ``-``, ``*``, ``/``, ``//``, ``%``, :func:`divmod`, :func:`pow`, "
"``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected (swapped) "
"operands. These functions are only called if the left operand does not "
"support the corresponding operation and the operands are of different types. "
"[#]_  For instance, to evaluate the expression ``x - y``, where *y* is an "
"instance of a class that has an :meth:`__rsub__` method, ``y.__rsub__(x)`` "
"is called if ``x.__sub__(y)`` returns *NotImplemented*."
msgstr ""

#: reference/datamodel.rst:2052
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""

#: reference/datamodel.rst:2057
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this method "
"will be called before the left operand's non-reflected method.  This "
"behavior allows subclasses to override their ancestors' operations."
msgstr ""

#: reference/datamodel.rst:2076
msgid ""
"These methods are called to implement the augmented arithmetic assignments "
"(``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``, ``**=``, ``<<=``, ``>>=``, "
"``&=``, ``^=``, ``|=``).  These methods should attempt to do the operation "
"in-place (modifying *self*) and return the result (which could be, but does "
"not have to be, *self*).  If a specific method is not defined, the augmented "
"assignment falls back to the normal methods.  For instance, if *x* is an "
"instance of a class with an :meth:`__iadd__` method, ``x += y`` is "
"equivalent to ``x = x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and ``y."
"__radd__(x)`` are considered, as with the evaluation of ``x + y``. In "
"certain situations, augmented assignment can result in unexpected errors "
"(see :ref:`faq-augmented-assignment-tuple-error`), but this behavior is in "
"fact part of the data model."
msgstr ""

#: reference/datamodel.rst:2097
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, :func:"
"`abs` and ``~``)."
msgstr ""

#: reference/datamodel.rst:2112
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int`, :"
"func:`float` and :func:`round`.  Should return a value of the appropriate "
"type."
msgstr ""

#: reference/datamodel.rst:2119
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is an "
"integer type.  Must return an integer."
msgstr ""

#: reference/datamodel.rst:2127
msgid ""
"In order to have a coherent integer type class, when :meth:`__index__` is "
"defined :meth:`__int__` should also be defined, and both should return the "
"same value."
msgstr ""

#: reference/datamodel.rst:2135
msgid "With Statement Context Managers"
msgstr ""

#: reference/datamodel.rst:2137
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to be "
"established when executing a :keyword:`with` statement. The context manager "
"handles the entry into, and the exit from, the desired runtime context for "
"the execution of the block of code.  Context managers are normally invoked "
"using the :keyword:`with` statement (described in section :ref:`with`), but "
"can also be used by directly invoking their methods."
msgstr ""

#: reference/datamodel.rst:2148
msgid ""
"Typical uses of context managers include saving and restoring various kinds "
"of global state, locking and unlocking resources, closing opened files, etc."
msgstr ""

#: reference/datamodel.rst:2151
msgid ""
"For more information on context managers, see :ref:`typecontextmanager`."
msgstr ""

#: reference/datamodel.rst:2156
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified in "
"the :keyword:`as` clause of the statement, if any."
msgstr ""

#: reference/datamodel.rst:2163
msgid ""
"Exit the runtime context related to this object. The parameters describe the "
"exception that caused the context to be exited. If the context was exited "
"without an exception, all three arguments will be :const:`None`."
msgstr ""

#: reference/datamodel.rst:2167
msgid ""
"If an exception is supplied, and the method wishes to suppress the exception "
"(i.e., prevent it from being propagated), it should return a true value. "
"Otherwise, the exception will be processed normally upon exit from this "
"method."
msgstr ""

#: reference/datamodel.rst:2171
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""

#: reference/datamodel.rst:2185
msgid "Special method lookup"
msgstr ""

#: reference/datamodel.rst:2187
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""

#: reference/datamodel.rst:2202
msgid ""
"The rationale behind this behaviour lies with a number of special methods "
"such as :meth:`__hash__` and :meth:`__repr__` that are implemented by all "
"objects, including type objects. If the implicit lookup of these methods "
"used the conventional lookup process, they would fail when invoked on the "
"type object itself::"
msgstr ""

#: reference/datamodel.rst:2215
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way is "
"sometimes referred to as 'metaclass confusion', and is avoided by bypassing "
"the instance when looking up special methods::"
msgstr ""

#: reference/datamodel.rst:2224
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the :"
"meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""

#: reference/datamodel.rst:2250
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides "
"significant scope for speed optimisations within the interpreter, at the "
"cost of some flexibility in the handling of special methods (the special "
"method *must* be set on the class object itself in order to be consistently "
"invoked by the interpreter)."
msgstr ""

#: reference/datamodel.rst:2259
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it can "
"lead to some very strange behaviour if it is handled incorrectly."
msgstr ""

#: reference/datamodel.rst:2263
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, which "
"is why the reflected method is not called."
msgstr ""

#: reference/executionmodel.rst:6
msgid "Execution model"
msgstr ""

#: reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr ""

#: reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the '**-c**' option) is a code block.  The string argument "
"passed to the built-in functions :func:`eval` and :func:`exec` is a code "
"block."
msgstr ""

#: reference/executionmodel.rst:31
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""

#: reference/executionmodel.rst:38
msgid "Naming and binding"
msgstr ""

#: reference/executionmodel.rst:47
msgid "Binding of names"
msgstr ""

#: reference/executionmodel.rst:53
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""

#: reference/executionmodel.rst:57
msgid ""
"The following constructs bind names: formal parameters to functions, :"
"keyword:`import` statements, class and function definitions (these bind the "
"class or function name in the defining block), and targets that are "
"identifiers if occurring in an assignment, :keyword:`for` loop header, or "
"after :keyword:`as` in a :keyword:`with` statement or :keyword:`except` "
"clause. The :keyword:`import` statement of the form ``from ... import *`` "
"binds all names defined in the imported module, except those beginning with "
"an underscore.  This form may only be used at the module level."
msgstr ""

#: reference/executionmodel.rst:67
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""

#: reference/executionmodel.rst:70
msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""

#: reference/executionmodel.rst:75
msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :dfn:`free variable`."
msgstr ""

#: reference/executionmodel.rst:81
msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""

#: reference/executionmodel.rst:87
msgid "Resolution of names"
msgstr ""

#: reference/executionmodel.rst:91
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""

#: reference/executionmodel.rst:99
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""

#: reference/executionmodel.rst:107
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""

#: reference/executionmodel.rst:113
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations."
msgstr ""

#: reference/executionmodel.rst:120
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"name specified in the statement refer to the binding of that name in the top-"
"level namespace.  Names are resolved in the top-level namespace by searching "
"the global namespace, i.e. the namespace of the module containing the code "
"block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the name is not "
"found there, the builtins namespace is searched.  The :keyword:`global` "
"statement must precede all uses of the name."
msgstr ""

#: reference/executionmodel.rst:129
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""

#: reference/executionmodel.rst:135
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope."
msgstr ""

#: reference/executionmodel.rst:142
msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""

#: reference/executionmodel.rst:145
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods -- this includes comprehensions and generator "
"expressions since they are implemented using a function scope.  This means "
"that the following will fail::"
msgstr ""

#: reference/executionmodel.rst:163
msgid "Builtins and restricted execution"
msgstr ""

#: reference/executionmodel.rst:167
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself.  ``__builtins__`` can be set to a user-created "
"dictionary to create a weak form of restricted execution."
msgstr ""

#: reference/executionmodel.rst:178
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""

#: reference/executionmodel.rst:186
msgid "Interaction with dynamic features"
msgstr ""

#: reference/executionmodel.rst:188
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""

#: reference/executionmodel.rst:197
msgid ""
"There are several cases where Python statements are illegal when used in "
"conjunction with nested scopes that contain free variables."
msgstr ""

#: reference/executionmodel.rst:200
msgid ""
"If a variable is referenced in an enclosing scope, it is illegal to delete "
"the name.  An error will be reported at compile time."
msgstr ""

#: reference/executionmodel.rst:205
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""

#: reference/executionmodel.rst:216
msgid "Exceptions"
msgstr "Exceptions"

#: reference/executionmodel.rst:227
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""

#: reference/executionmodel.rst:233
msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""

#: reference/executionmodel.rst:243
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""

#: reference/executionmodel.rst:250
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack backtrace, except when the exception is :exc:"
"`SystemExit`."
msgstr ""

#: reference/executionmodel.rst:254
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a base class thereof.  The instance can be received "
"by the handler and can carry additional information about the exceptional "
"condition."
msgstr ""

#: reference/executionmodel.rst:261
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""

#: reference/executionmodel.rst:265
msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""

#: reference/executionmodel.rst:271
msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""

#: reference/expressions.rst:6
msgid "Expressions"
msgstr ""

#: reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""

#: reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""

#: reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""

#: reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr ""

#: reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""

#: reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""

#: reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""

#: reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""

#: reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""

#: reference/expressions.rst:49
msgid "Atoms"
msgstr ""

#: reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""

#: reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr ""

#: reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""

#: reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""

#: reference/expressions.rst:84
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""

#: reference/expressions.rst:100 reference/lexical_analysis.rst:390
msgid "Literals"
msgstr ""

#: reference/expressions.rst:104
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""

#: reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: reference/expressions.rst:119
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""

#: reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr ""

#: reference/expressions.rst:133
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""

#: reference/expressions.rst:138
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""

#: reference/expressions.rst:144
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the rules for literals apply (i.e., two occurrences of the empty "
"tuple may or may not yield the same object)."
msgstr ""

#: reference/expressions.rst:152
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""

#: reference/expressions.rst:161
msgid "Displays for lists, sets and dictionaries"
msgstr ""

#: reference/expressions.rst:163
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""

#: reference/expressions.rst:166
msgid "either the container contents are listed explicitly, or"
msgstr ""

#: reference/expressions.rst:168
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""

#: reference/expressions.rst:171
msgid "Common syntax elements for comprehensions are:"
msgstr ""

#: reference/expressions.rst:179
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if` "
"clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr ""

#: reference/expressions.rst:186
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" into the enclosing scope."
msgstr ""

#: reference/expressions.rst:193
msgid "List displays"
msgstr ""

#: reference/expressions.rst:201
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""

#: reference/expressions.rst:207
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""

#: reference/expressions.rst:217
msgid "Set displays"
msgstr ""

#: reference/expressions.rst:222
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""

#: reference/expressions.rst:228
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""

#: reference/expressions.rst:234
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""

#: reference/expressions.rst:241
msgid "Dictionary displays"
msgstr ""

#: reference/expressions.rst:247
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""

#: reference/expressions.rst:256
msgid "A dictionary display yields a new dictionary object."
msgstr ""

#: reference/expressions.rst:258
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""

#: reference/expressions.rst:264
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""

#: reference/expressions.rst:272
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""

#: reference/expressions.rst:282
#, fuzzy
msgid "Generator expressions"
msgstr "Expressions et générateurs"

#: reference/expressions.rst:287
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""

#: reference/expressions.rst:292
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""

#: reference/expressions.rst:296
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the leftmost :keyword:`for` "
"clause is immediately evaluated, so that an error produced by it can be seen "
"before any other possible error in the code that handles the generator "
"expression. Subsequent :keyword:`for` clauses cannot be evaluated "
"immediately since they may depend on the previous :keyword:`for` loop. For "
"example: ``(x*y for x in range(10) for y in bar(x))``."
msgstr ""

#: reference/expressions.rst:305
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""

#: reference/expressions.rst:312
msgid "Yield expressions"
msgstr ""

#: reference/expressions.rst:323
msgid ""
"The yield expression is only used when defining a :term:`generator` function "
"and thus can only be used in the body of a function definition.  Using a "
"yield expression in a function's body causes that function to be a generator."
msgstr ""

#: reference/expressions.rst:327
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`expression_list` "
"to the generator's caller.  By suspended, we mean that all local state is "
"retained, including the current bindings of local variables, the instruction "
"pointer, the internal evaluation stack, and the state of any exception "
"handling.  When the execution is resumed by calling one of the generator's "
"methods, the function can proceed exactly as if the yield expression were "
"just another external call.  The value of the yield expression after "
"resuming depends on the method which resumed the execution.  If :meth:"
"`~generator.__next__` is used (typically via either a :keyword:`for` or the :"
"func:`next` builtin) then the result is :const:`None`.  Otherwise, if :meth:"
"`~generator.send` is used, then the result will be the value passed in to "
"that method."
msgstr ""

#: reference/expressions.rst:346
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""

#: reference/expressions.rst:352
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""

#: reference/expressions.rst:358
msgid ""
"When ``yield from <expr>`` is used, it treats the supplied expression as a "
"subiterator. All values produced by that subiterator are passed directly to "
"the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""

#: reference/expressions.rst:367
msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the sub-iterator is a generator (by "
"returning a value from the sub-generator)."
msgstr ""

#: reference/expressions.rst:373
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""

#: reference/expressions.rst:376
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""

#: reference/expressions.rst:382
msgid "PEP 0255 - Simple Generators"
msgstr ""

#: reference/expressions.rst:382
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""

#: reference/expressions.rst:386
msgid "PEP 0342 - Coroutines via Enhanced Generators"
msgstr ""

#: reference/expressions.rst:385
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""

#: reference/expressions.rst:389
msgid "PEP 0380 - Syntax for Delegating to a Subgenerator"
msgstr ""

#: reference/expressions.rst:389
msgid ""
"The proposal to introduce the :token:`yield_from` syntax, making delegation "
"to sub-generators easy."
msgstr ""

#: reference/expressions.rst:395
msgid "Generator-iterator methods"
msgstr ""

#: reference/expressions.rst:397
msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""

#: reference/expressions.rst:400
msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""

#: reference/expressions.rst:408
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`expression_list` is returned to :meth:`__next__`'s caller.  If the "
"generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised."
msgstr ""

#: reference/expressions.rst:417
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""

#: reference/expressions.rst:423
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""

#: reference/expressions.rst:434
msgid ""
"Raises an exception of type ``type`` at the point where the generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in "
"exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""

#: reference/expressions.rst:445
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then raises :exc:`StopIteration` (by "
"exiting normally, or due to already being closed) or :exc:`GeneratorExit` "
"(by not catching the exception), close returns to its caller.  If the "
"generator yields a value, a :exc:`RuntimeError` is raised.  If the generator "
"raises any other exception, it is propagated to the caller.  :meth:`close` "
"does nothing if the generator has already exited due to an exception or "
"normal exit."
msgstr ""

#: reference/expressions.rst:456
msgid "Examples"
msgstr "Exemples"

#: reference/expressions.rst:458
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""

#: reference/expressions.rst:485
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""

#: reference/expressions.rst:492
msgid "Primaries"
msgstr ""

#: reference/expressions.rst:496
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""

#: reference/expressions.rst:506
msgid "Attribute references"
msgstr ""

#: reference/expressions.rst:510
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""

#: reference/expressions.rst:520
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier.  This production can be customized "
"by overriding the :meth:`__getattr__` method.  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""

#: reference/expressions.rst:532
msgid "Subscriptions"
msgstr ""

#: reference/expressions.rst:545
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""

#: reference/expressions.rst:551
msgid ""
"The primary must evaluate to an object that supports subscription (lists or "
"dictionaries for example).  User-defined objects can support subscription by "
"defining a :meth:`__getitem__` method."
msgstr ""

#: reference/expressions.rst:555
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr ""

#: reference/expressions.rst:557
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list "
"is a tuple except if it has exactly one item.)"
msgstr ""

#: reference/expressions.rst:562
msgid ""
"If the primary is a sequence, the expression (list) must evaluate to an "
"integer or a slice (as discussed in the following section)."
msgstr ""

#: reference/expressions.rst:565
msgid ""
"The formal syntax makes no special provision for negative indices in "
"sequences; however, built-in sequences all provide a :meth:`__getitem__` "
"method that interprets negative indices by adding the length of the sequence "
"to the index (so that ``x[-1]`` selects the last item of ``x``).  The "
"resulting value must be a nonnegative integer less than the number of items "
"in the sequence, and the subscription selects the item whose index is that "
"value (counting from zero). Since the support for negative indices and "
"slicing occurs in the object's :meth:`__getitem__` method, subclasses "
"overriding this method will need to explicitly add that support."
msgstr ""

#: reference/expressions.rst:579
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr ""

#: reference/expressions.rst:586
msgid "Slicings"
msgstr ""

#: reference/expressions.rst:598
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""

#: reference/expressions.rst:611
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""

#: reference/expressions.rst:623
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`__getitem__` method as normal subscription) with a key that "
"is constructed from the slice list, as follows.  If the slice list contains "
"at least one comma, the key is a tuple containing the conversion of the "
"slice items; otherwise, the conversion of the lone slice item is the key.  "
"The conversion of a slice item that is an expression is that expression.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""

#: reference/expressions.rst:644
msgid "Calls"
msgstr "Appels"

#: reference/expressions.rst:646
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""

#: reference/expressions.rst:662
msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""

#: reference/expressions.rst:668
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""

#: reference/expressions.rst:676
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""

#: reference/expressions.rst:696
msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""

#: reference/expressions.rst:702
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""

#: reference/expressions.rst:708
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""

#: reference/expressions.rst:718
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an iterable.  Elements from this iterable are treated as if "
"they were additional positional arguments; if there are positional arguments "
"*x1*, ..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, "
"*y1*, ..., *yM*."
msgstr ""

#: reference/expressions.rst:725
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* some keyword arguments, it is processed *before* the keyword "
"arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""

#: reference/expressions.rst:741
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""

#: reference/expressions.rst:747
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a mapping, the contents of which are treated as additional "
"keyword arguments.  In the case of a keyword appearing in both "
"``expression`` and as an explicit keyword argument, a :exc:`TypeError` "
"exception is raised."
msgstr ""

#: reference/expressions.rst:752
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""

#: reference/expressions.rst:755
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""

#: reference/expressions.rst:759
msgid "If it is---"
msgstr ""

#: reference/expressions.rst:772
msgid "a user-defined function:"
msgstr ""

#: reference/expressions.rst:768
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""

#: reference/expressions.rst:786
msgid "a built-in function or method:"
msgstr ""

#: reference/expressions.rst:785
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""

#: reference/expressions.rst:793
msgid "a class object:"
msgstr ""

#: reference/expressions.rst:793
msgid "A new instance of that class is returned."
msgstr ""

#: reference/expressions.rst:803
msgid "a class instance method:"
msgstr ""

#: reference/expressions.rst:801
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""

#: reference/expressions.rst:812
msgid "a class instance:"
msgstr ""

#: reference/expressions.rst:810
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""

#: reference/expressions.rst:817
msgid "The power operator"
msgstr ""

#: reference/expressions.rst:819
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""

#: reference/expressions.rst:825
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""

#: reference/expressions.rst:829
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""

#: reference/expressions.rst:834
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""

#: reference/expressions.rst:839
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""

#: reference/expressions.rst:847
msgid "Unary arithmetic and bitwise operations"
msgstr ""

#: reference/expressions.rst:853
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""

#: reference/expressions.rst:862
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""

#: reference/expressions.rst:866
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""

#: reference/expressions.rst:871
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers."
msgstr ""

#: reference/expressions.rst:877
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""

#: reference/expressions.rst:884
msgid "Binary arithmetic operations"
msgstr ""

#: reference/expressions.rst:888
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""

#: reference/expressions.rst:900
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""

#: reference/expressions.rst:910
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""

#: reference/expressions.rst:919
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""

#: reference/expressions.rst:928
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""

#: reference/expressions.rst:933
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""

#: reference/expressions.rst:938
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: reference/expressions.rst:944
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and "
"then added together. In the latter case, the sequences are concatenated."
msgstr ""

#: reference/expressions.rst:951
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""

#: reference/expressions.rst:958
msgid "Shifting operations"
msgstr ""

#: reference/expressions.rst:962
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""

#: reference/expressions.rst:967
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""

#: reference/expressions.rst:972
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""

#: reference/expressions.rst:977
msgid ""
"In the current implementation, the right-hand operand is required to be at "
"most :attr:`sys.maxsize`.  If the right-hand operand is larger than :attr:"
"`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""

#: reference/expressions.rst:984
msgid "Binary bitwise operations"
msgstr ""

#: reference/expressions.rst:988
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""

#: reference/expressions.rst:997
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers."
msgstr ""

#: reference/expressions.rst:1004
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers."
msgstr ""

#: reference/expressions.rst:1011
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers."
msgstr ""

#: reference/expressions.rst:1018
msgid "Comparisons"
msgstr ""

#: reference/expressions.rst:1024
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""

#: reference/expressions.rst:1034
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""

#: reference/expressions.rst:1038
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""

#: reference/expressions.rst:1042
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""

#: reference/expressions.rst:1047
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""

#: reference/expressions.rst:1052
msgid "Value comparisons"
msgstr ""

#: reference/expressions.rst:1054
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""

#: reference/expressions.rst:1057
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""

#: reference/expressions.rst:1066
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""

#: reference/expressions.rst:1072
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""

#: reference/expressions.rst:1079
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""

#: reference/expressions.rst:1083
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""

#: reference/expressions.rst:1089
msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""

#: reference/expressions.rst:1092
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""

#: reference/expressions.rst:1099
msgid ""
"The not-a-number values :const:`float('NaN')` and :const:`Decimal('NaN')` "
"are special.  They are identical to themselves (``x is x`` is true) but are "
"not equal to themselves (``x == x`` is false).  Additionally, comparing any "
"number to a not-a-number value will return ``False``.  For example, both ``3 "
"< float('NaN')`` and ``float('NaN') < 3`` will return ``False``."
msgstr ""

#: reference/expressions.rst:1106
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""

#: reference/expressions.rst:1110
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""

#: reference/expressions.rst:1114
msgid "Strings and binary sequences cannot be directly compared."
msgstr ""

#: reference/expressions.rst:1116
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in unequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""

#: reference/expressions.rst:1122
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements, whereby reflexivity of the elements is enforced."
msgstr ""

#: reference/expressions.rst:1125
msgid ""
"In enforcing reflexivity of elements, the comparison of collections assumes "
"that for a collection element ``x``, ``x == x`` is always true.  Based on "
"that assumption, element identity is compared first, and element comparison "
"is performed only for distinct elements.  This approach yields the same "
"result as a strict element comparison would, if the compared elements are "
"reflexive.  For non-reflexive elements, the result is different than for "
"strict element comparison, and may be surprising:  The non-reflexive not-a-"
"number values for example result in the following comparison behavior when "
"used in a list::"
msgstr ""

#: reference/expressions.rst:1143
msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""

#: reference/expressions.rst:1145
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""

#: reference/expressions.rst:1150
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""

#: reference/expressions.rst:1156
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal `(key, value)` pairs. Equality comparison of the keys and elements "
"enforces reflexivity."
msgstr ""

#: reference/expressions.rst:1160
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""

#: reference/expressions.rst:1162
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""

#: reference/expressions.rst:1165
msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""

#: reference/expressions.rst:1173
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr ""

#: reference/expressions.rst:1175
msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""

#: reference/expressions.rst:1178
msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""

#: reference/expressions.rst:1181
msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""

#: reference/expressions.rst:1184
msgid "``x is y`` implies ``x == y``"
msgstr ""

#: reference/expressions.rst:1186
msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""

#: reference/expressions.rst:1189
msgid "``x == y`` and ``y == x``"
msgstr ""

#: reference/expressions.rst:1191
msgid "``x != y`` and ``y != x``"
msgstr ""

#: reference/expressions.rst:1193
msgid "``x < y`` and ``y > x``"
msgstr ""

#: reference/expressions.rst:1195
msgid "``x <= y`` and ``y >= x``"
msgstr ""

#: reference/expressions.rst:1197
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""

#: reference/expressions.rst:1200
msgid "``x > y and y > z`` implies ``x > z``"
msgstr ""

#: reference/expressions.rst:1202
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr ""

#: reference/expressions.rst:1204
msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""

#: reference/expressions.rst:1207
msgid "``x == y`` and ``not x != y``"
msgstr ""

#: reference/expressions.rst:1209
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr ""

#: reference/expressions.rst:1211
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr ""

#: reference/expressions.rst:1213
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""

#: reference/expressions.rst:1217
msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""

#: reference/expressions.rst:1226
msgid "Membership test operations"
msgstr ""

#: reference/expressions.rst:1228
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to true if *x* is a member of *s*, and false otherwise.  "
"``x not in s`` returns the negation of ``x in s``.  All built-in sequences "
"and set types support this as well as dictionary, for which :keyword:`in` "
"tests whether the dictionary has a given key. For container types such as "
"list, tuple, set, frozenset, dict, or collections.deque, the expression ``x "
"in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""

#: reference/expressions.rst:1236
msgid ""
"For the string and bytes types, ``x in y`` is true if and only if *x* is a "
"substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty strings "
"are always considered to be a substring of any other string, so ``\"\" in "
"\"abc\"`` will return ``True``."
msgstr ""

#: reference/expressions.rst:1241
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` is true if and only if ``y.__contains__(x)`` is true."
msgstr ""

#: reference/expressions.rst:1244
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is true if some value ``z`` with ``x == "
"z`` is produced while iterating over ``y``.  If an exception is raised "
"during the iteration, it is as if :keyword:`in` raised that exception."
msgstr ""

#: reference/expressions.rst:1249
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is true if and only if there is a non-negative "
"integer index *i* such that ``x == y[i]``, and all lower integer indices do "
"not raise :exc:`IndexError` exception.  (If any other exception is raised, "
"it is as if :keyword:`in` raised that exception)."
msgstr ""

#: reference/expressions.rst:1261
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of :"
"keyword:`in`."
msgstr ""

#: reference/expressions.rst:1274
msgid "Identity comparisons"
msgstr ""

#: reference/expressions.rst:1276
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr ""

#: reference/expressions.rst:1287
msgid "Boolean operations"
msgstr ""

#: reference/expressions.rst:1298
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""

#: reference/expressions.rst:1307
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""

#: reference/expressions.rst:1312
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: reference/expressions.rst:1317
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: reference/expressions.rst:1320
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""

#: reference/expressions.rst:1330
msgid "Conditional expressions"
msgstr ""

#: reference/expressions.rst:1341
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""

#: reference/expressions.rst:1344
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""

#: reference/expressions.rst:1348
msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""

#: reference/expressions.rst:1355
msgid "Lambdas"
msgstr ""

#: reference/expressions.rst:1366
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda arguments: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with ::"
msgstr ""

#: reference/expressions.rst:1373
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""

#: reference/expressions.rst:1381
msgid "Expression lists"
msgstr ""

#: reference/expressions.rst:1390
msgid ""
"An expression list containing at least one comma yields a tuple.  The length "
"of the tuple is the number of expressions in the list.  The expressions are "
"evaluated from left to right."
msgstr ""

#: reference/expressions.rst:1396
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""

#: reference/expressions.rst:1406
msgid "Evaluation order"
msgstr ""

#: reference/expressions.rst:1410
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""

#: reference/expressions.rst:1413
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""

#: reference/expressions.rst:1427
msgid "Operator precedence"
msgstr ""

#: reference/expressions.rst:1431
msgid ""
"The following table summarizes the operator precedence in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation, which groups from right to left)."
msgstr ""

#: reference/expressions.rst:1437
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""

#: reference/expressions.rst:1443
msgid "Operator"
msgstr ""

#: reference/expressions.rst:1443
msgid "Description"
msgstr ""

#: reference/expressions.rst:1445
msgid ":keyword:`lambda`"
msgstr ""

#: reference/expressions.rst:1445
#, fuzzy
msgid "Lambda expression"
msgstr "Fonctions anonymes"

#: reference/expressions.rst:1447
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ""

#: reference/expressions.rst:1447
msgid "Conditional expression"
msgstr ""

#: reference/expressions.rst:1449
msgid ":keyword:`or`"
msgstr ""

#: reference/expressions.rst:1449
msgid "Boolean OR"
msgstr ""

#: reference/expressions.rst:1451
msgid ":keyword:`and`"
msgstr ""

#: reference/expressions.rst:1451
msgid "Boolean AND"
msgstr ""

#: reference/expressions.rst:1453
msgid ":keyword:`not` ``x``"
msgstr ""

#: reference/expressions.rst:1453
msgid "Boolean NOT"
msgstr ""

#: reference/expressions.rst:1455
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""

#: reference/expressions.rst:1455
msgid "Comparisons, including membership tests and identity tests"
msgstr ""

#: reference/expressions.rst:1459
msgid "``|``"
msgstr ""

#: reference/expressions.rst:1459
msgid "Bitwise OR"
msgstr ""

#: reference/expressions.rst:1461
msgid "``^``"
msgstr ""

#: reference/expressions.rst:1461
msgid "Bitwise XOR"
msgstr ""

#: reference/expressions.rst:1463
msgid "``&``"
msgstr ""

#: reference/expressions.rst:1463
msgid "Bitwise AND"
msgstr ""

#: reference/expressions.rst:1465
msgid "``<<``, ``>>``"
msgstr ""

#: reference/expressions.rst:1465
msgid "Shifts"
msgstr ""

#: reference/expressions.rst:1467
msgid "``+``, ``-``"
msgstr ""

#: reference/expressions.rst:1467
msgid "Addition and subtraction"
msgstr ""

#: reference/expressions.rst:1469
msgid "``*``, ``/``, ``//``, ``%``"
msgstr ""

#: reference/expressions.rst:1469
msgid "Multiplication, division, remainder [#]_"
msgstr ""

#: reference/expressions.rst:1472
msgid "``+x``, ``-x``, ``~x``"
msgstr ""

#: reference/expressions.rst:1472
msgid "Positive, negative, bitwise NOT"
msgstr ""

#: reference/expressions.rst:1474
msgid "``**``"
msgstr ""

#: reference/expressions.rst:1474
msgid "Exponentiation [#]_"
msgstr ""

#: reference/expressions.rst:1476
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""

#: reference/expressions.rst:1476
msgid "Subscription, slicing, call, attribute reference"
msgstr ""

#: reference/expressions.rst:1479
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"
msgstr ""

#: reference/expressions.rst:1479
msgid "Binding or tuple display, list display, dictionary display, set display"
msgstr ""

#: reference/expressions.rst:1488
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""

#: reference/expressions.rst:1497
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""

#: reference/expressions.rst:1502
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""

#: reference/expressions.rst:1513
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""

#: reference/expressions.rst:1518
msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""

#: reference/expressions.rst:1521
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""

#: reference/expressions.rst:1526
msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""

#: reference/expressions.rst:1529
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""

#: reference/grammar.rst:2
msgid "Full Grammar specification"
msgstr ""

#: reference/grammar.rst:4
msgid ""
"This is the full Python grammar, as it is read by the parser generator and "
"used to parse Python source files:"
msgstr ""

#: reference/import.rst:6
msgid "The import system"
msgstr ""

#: reference/import.rst:10
msgid ""
"Python code in one :term:`module` gains access to the code in another module "
"by the process of :term:`importing` it.  The :keyword:`import` statement is "
"the most common way of invoking the import machinery, but it is not the only "
"way.  Functions such as :func:`importlib.import_module` and built-in :func:"
"`__import__` can also be used to invoke the import machinery."
msgstr ""

#: reference/import.rst:16
msgid ""
"The :keyword:`import` statement combines two operations; it searches for the "
"named module, then it binds the results of that search to a name in the "
"local scope.  The search operation of the :keyword:`import` statement is "
"defined as a call to the :func:`__import__` function, with the appropriate "
"arguments. The return value of :func:`__import__` is used to perform the "
"name binding operation of the :keyword:`import` statement.  See the :keyword:"
"`import` statement for the exact details of that name binding operation."
msgstr ""

#: reference/import.rst:25
msgid ""
"A direct call to :func:`__import__` performs only the module search and, if "
"found, the module creation operation.  While certain side-effects may occur, "
"such as the importing of parent packages, and the updating of various caches "
"(including :data:`sys.modules`), only the :keyword:`import` statement "
"performs a name binding operation."
msgstr ""

#: reference/import.rst:31
msgid ""
"When calling :func:`__import__` as part of an import statement, the import "
"system first checks the module global namespace for a function by that name. "
"If it is not found, then the standard builtin :func:`__import__` is called. "
"Other mechanisms for invoking the import system (such as :func:`importlib."
"import_module`) do not perform this check and will always use the standard "
"import system."
msgstr ""

#: reference/import.rst:38
msgid ""
"When a module is first imported, Python searches for the module and if "
"found, it creates a module object [#fnmo]_, initializing it.  If the named "
"module cannot be found, an :exc:`ImportError` is raised.  Python implements "
"various strategies to search for the named module when the import machinery "
"is invoked.  These strategies can be modified and extended by using various "
"hooks described in the sections below."
msgstr ""

#: reference/import.rst:45
msgid ""
"The import system has been updated to fully implement the second phase of :"
"pep:`302`. There is no longer any implicit import machinery - the full "
"import system is exposed through :data:`sys.meta_path`. In addition, native "
"namespace package support has been implemented (see :pep:`420`)."
msgstr ""

#: reference/import.rst:53
msgid ":mod:`importlib`"
msgstr ""

#: reference/import.rst:55
msgid ""
"The :mod:`importlib` module provides a rich API for interacting with the "
"import system.  For example :func:`importlib.import_module` provides a "
"recommended, simpler API than built-in :func:`__import__` for invoking the "
"import machinery.  Refer to the :mod:`importlib` library documentation for "
"additional detail."
msgstr ""

#: reference/import.rst:64
msgid "Packages"
msgstr "Les paquets"

#: reference/import.rst:69
msgid ""
"Python has only one type of module object, and all modules are of this type, "
"regardless of whether the module is implemented in Python, C, or something "
"else.  To help organize modules and provide a naming hierarchy, Python has a "
"concept of :term:`packages <package>`."
msgstr ""

#: reference/import.rst:74
msgid ""
"You can think of packages as the directories on a file system and modules as "
"files within directories, but don't take this analogy too literally since "
"packages and modules need not originate from the file system.  For the "
"purposes of this documentation, we'll use this convenient analogy of "
"directories and files.  Like file system directories, packages are organized "
"hierarchically, and packages may themselves contain subpackages, as well as "
"regular modules."
msgstr ""

#: reference/import.rst:82
msgid ""
"It's important to keep in mind that all packages are modules, but not all "
"modules are packages.  Or put another way, packages are just a special kind "
"of module.  Specifically, any module that contains a ``__path__`` attribute "
"is considered a package."
msgstr ""

#: reference/import.rst:87
msgid ""
"All modules have a name.  Subpackage names are separated from their parent "
"package name by dots, akin to Python's standard attribute access syntax.  "
"Thus you might have a module called :mod:`sys` and a package called :mod:"
"`email`, which in turn has a subpackage called :mod:`email.mime` and a "
"module within that subpackage called :mod:`email.mime.text`."
msgstr ""

#: reference/import.rst:95
msgid "Regular packages"
msgstr ""

#: reference/import.rst:100
msgid ""
"Python defines two types of packages, :term:`regular packages <regular "
"package>` and :term:`namespace packages <namespace package>`.  Regular "
"packages are traditional packages as they existed in Python 3.2 and earlier. "
"A regular package is typically implemented as a directory containing an "
"``__init__.py`` file.  When a regular package is imported, this ``__init__."
"py`` file is implicitly executed, and the objects it defines are bound to "
"names in the package's namespace.  The ``__init__.py`` file can contain the "
"same Python code that any other module can contain, and Python will add some "
"additional attributes to the module when it is imported."
msgstr ""

#: reference/import.rst:110
msgid ""
"For example, the following file system layout defines a top level ``parent`` "
"package with three subpackages::"
msgstr ""

#: reference/import.rst:122
msgid ""
"Importing ``parent.one`` will implicitly execute ``parent/__init__.py`` and "
"``parent/one/__init__.py``.  Subsequent imports of ``parent.two`` or "
"``parent.three`` will execute ``parent/two/__init__.py`` and ``parent/three/"
"__init__.py`` respectively."
msgstr ""

#: reference/import.rst:129
msgid "Namespace packages"
msgstr ""

#: reference/import.rst:135
msgid ""
"A namespace package is a composite of various :term:`portions <portion>`, "
"where each portion contributes a subpackage to the parent package.  Portions "
"may reside in different locations on the file system.  Portions may also be "
"found in zip files, on the network, or anywhere else that Python searches "
"during import.  Namespace packages may or may not correspond directly to "
"objects on the file system; they may be virtual modules that have no "
"concrete representation."
msgstr ""

#: reference/import.rst:143
msgid ""
"Namespace packages do not use an ordinary list for their ``__path__`` "
"attribute. They instead use a custom iterable type which will automatically "
"perform a new search for package portions on the next import attempt within "
"that package if the path of their parent package (or :data:`sys.path` for a "
"top level package) changes."
msgstr ""

#: reference/import.rst:149
msgid ""
"With namespace packages, there is no ``parent/__init__.py`` file.  In fact, "
"there may be multiple ``parent`` directories found during import search, "
"where each one is provided by a different portion.  Thus ``parent/one`` may "
"not be physically located next to ``parent/two``.  In this case, Python will "
"create a namespace package for the top-level ``parent`` package whenever it "
"or one of its subpackages is imported."
msgstr ""

#: reference/import.rst:156
msgid "See also :pep:`420` for the namespace package specification."
msgstr ""

#: reference/import.rst:160
msgid "Searching"
msgstr ""

#: reference/import.rst:162
msgid ""
"To begin the search, Python needs the :term:`fully qualified <qualified "
"name>` name of the module (or package, but for the purposes of this "
"discussion, the difference is immaterial) being imported.  This name may "
"come from various arguments to the :keyword:`import` statement, or from the "
"parameters to the :func:`importlib.import_module` or :func:`__import__` "
"functions."
msgstr ""

#: reference/import.rst:168
msgid ""
"This name will be used in various phases of the import search, and it may be "
"the dotted path to a submodule, e.g. ``foo.bar.baz``.  In this case, Python "
"first tries to import ``foo``, then ``foo.bar``, and finally ``foo.bar."
"baz``. If any of the intermediate imports fail, an :exc:`ImportError` is "
"raised."
msgstr ""

#: reference/import.rst:175
msgid "The module cache"
msgstr ""

#: reference/import.rst:180
msgid ""
"The first place checked during import search is :data:`sys.modules`.  This "
"mapping serves as a cache of all modules that have been previously imported, "
"including the intermediate paths.  So if ``foo.bar.baz`` was previously "
"imported, :data:`sys.modules` will contain entries for ``foo``, ``foo.bar``, "
"and ``foo.bar.baz``.  Each key will have as its value the corresponding "
"module object."
msgstr ""

#: reference/import.rst:187
msgid ""
"During import, the module name is looked up in :data:`sys.modules` and if "
"present, the associated value is the module satisfying the import, and the "
"process completes.  However, if the value is ``None``, then an :exc:"
"`ImportError` is raised.  If the module name is missing, Python will "
"continue searching for the module."
msgstr ""

#: reference/import.rst:193
msgid ""
":data:`sys.modules` is writable.  Deleting a key may not destroy the "
"associated module (as other modules may hold references to it), but it will "
"invalidate the cache entry for the named module, causing Python to search "
"anew for the named module upon its next import. The key can also be assigned "
"to ``None``, forcing the next import of the module to result in an :exc:"
"`ImportError`."
msgstr ""

#: reference/import.rst:200
msgid ""
"Beware though, as if you keep a reference to the module object, invalidate "
"its cache entry in :data:`sys.modules`, and then re-import the named module, "
"the two module objects will *not* be the same. By contrast, :func:`importlib."
"reload` will reuse the *same* module object, and simply reinitialise the "
"module contents by rerunning the module's code."
msgstr ""

#: reference/import.rst:208
msgid "Finders and loaders"
msgstr ""

#: reference/import.rst:215
msgid ""
"If the named module is not found in :data:`sys.modules`, then Python's "
"import protocol is invoked to find and load the module.  This protocol "
"consists of two conceptual objects, :term:`finders <finder>` and :term:"
"`loaders <loader>`. A finder's job is to determine whether it can find the "
"named module using whatever strategy it knows about. Objects that implement "
"both of these interfaces are referred to as :term:`importers <importer>` - "
"they return themselves when they find that they can load the requested "
"module."
msgstr ""

#: reference/import.rst:223
msgid ""
"Python includes a number of default finders and importers.  The first one "
"knows how to locate built-in modules, and the second knows how to locate "
"frozen modules.  A third default finder searches an :term:`import path` for "
"modules.  The :term:`import path` is a list of locations that may name file "
"system paths or zip files.  It can also be extended to search for any "
"locatable resource, such as those identified by URLs."
msgstr ""

#: reference/import.rst:230
msgid ""
"The import machinery is extensible, so new finders can be added to extend "
"the range and scope of module searching."
msgstr ""

#: reference/import.rst:233
msgid ""
"Finders do not actually load modules.  If they can find the named module, "
"they return a :dfn:`module spec`, an encapsulation of the module's import-"
"related information, which the import machinery then uses when loading the "
"module."
msgstr ""

#: reference/import.rst:237
msgid ""
"The following sections describe the protocol for finders and loaders in more "
"detail, including how you can create and register new ones to extend the "
"import machinery."
msgstr ""

#: reference/import.rst:241
msgid ""
"In previous versions of Python, finders returned :term:`loaders <loader>` "
"directly, whereas now they return module specs which *contain* loaders. "
"Loaders are still used during import but have fewer responsibilities."
msgstr ""

#: reference/import.rst:247
msgid "Import hooks"
msgstr ""

#: reference/import.rst:257
msgid ""
"The import machinery is designed to be extensible; the primary mechanism for "
"this are the *import hooks*.  There are two types of import hooks: *meta "
"hooks* and *import path hooks*."
msgstr ""

#: reference/import.rst:261
msgid ""
"Meta hooks are called at the start of import processing, before any other "
"import processing has occurred, other than :data:`sys.modules` cache look "
"up. This allows meta hooks to override :data:`sys.path` processing, frozen "
"modules, or even built-in modules.  Meta hooks are registered by adding new "
"finder objects to :data:`sys.meta_path`, as described below."
msgstr ""

#: reference/import.rst:267
msgid ""
"Import path hooks are called as part of :data:`sys.path` (or ``package."
"__path__``) processing, at the point where their associated path item is "
"encountered.  Import path hooks are registered by adding new callables to :"
"data:`sys.path_hooks` as described below."
msgstr ""

#: reference/import.rst:274
msgid "The meta path"
msgstr ""

#: reference/import.rst:280
msgid ""
"When the named module is not found in :data:`sys.modules`, Python next "
"searches :data:`sys.meta_path`, which contains a list of meta path finder "
"objects.  These finders are queried in order to see if they know how to "
"handle the named module.  Meta path finders must implement a method called :"
"meth:`~importlib.abc.MetaPathFinder.find_spec()` which takes three "
"arguments: a name, an import path, and (optionally) a target module.  The "
"meta path finder can use any strategy it wants to determine whether it can "
"handle the named module or not."
msgstr ""

#: reference/import.rst:289
msgid ""
"If the meta path finder knows how to handle the named module, it returns a "
"spec object.  If it cannot handle the named module, it returns ``None``.  "
"If :data:`sys.meta_path` processing reaches the end of its list without "
"returning a spec, then an :exc:`ImportError` is raised.  Any other "
"exceptions raised are simply propagated up, aborting the import process."
msgstr ""

#: reference/import.rst:295
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec()` method of meta path "
"finders is called with two or three arguments.  The first is the fully "
"qualified name of the module being imported, for example ``foo.bar.baz``. "
"The second argument is the path entries to use for the module search.  For "
"top-level modules, the second argument is ``None``, but for submodules or "
"subpackages, the second argument is the value of the parent package's "
"``__path__`` attribute. If the appropriate ``__path__`` attribute cannot be "
"accessed, an :exc:`ImportError` is raised.  The third argument is an "
"existing module object that will be the target of loading later.  The import "
"system passes in a target module only during reload."
msgstr ""

#: reference/import.rst:306
msgid ""
"The meta path may be traversed multiple times for a single import request. "
"For example, assuming none of the modules involved has already been cached, "
"importing ``foo.bar.baz`` will first perform a top level import, calling "
"``mpf.find_spec(\"foo\", None, None)`` on each meta path finder (``mpf``). "
"After ``foo`` has been imported, ``foo.bar`` will be imported by traversing "
"the meta path a second time, calling ``mpf.find_spec(\"foo.bar\", foo."
"__path__, None)``. Once ``foo.bar`` has been imported, the final traversal "
"will call ``mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)``."
msgstr ""

#: reference/import.rst:316
msgid ""
"Some meta path finders only support top level imports. These importers will "
"always return ``None`` when anything other than ``None`` is passed as the "
"second argument."
msgstr ""

#: reference/import.rst:320
msgid ""
"Python's default :data:`sys.meta_path` has three meta path finders, one that "
"knows how to import built-in modules, one that knows how to import frozen "
"modules, and one that knows how to import modules from an :term:`import "
"path` (i.e. the :term:`path based finder`)."
msgstr ""

#: reference/import.rst:325
msgid ""
"The :meth:`~importlib.abc.MetaPathFinder.find_spec` method of meta path "
"finders replaced :meth:`~importlib.abc.MetaPathFinder.find_module`, which is "
"now deprecated.  While it will continue to work without change, the import "
"machinery will try it only if the finder does not implement ``find_spec()``."
msgstr ""

#: reference/import.rst:334
msgid "Loading"
msgstr ""

#: reference/import.rst:336
msgid ""
"If and when a module spec is found, the import machinery will use it (and "
"the loader it contains) when loading the module.  Here is an approximation "
"of what happens during the loading portion of import::"
msgstr ""

#: reference/import.rst:370
msgid "Note the following details:"
msgstr ""

#: reference/import.rst:372
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, import will have already returned it."
msgstr ""

#: reference/import.rst:375
msgid ""
"The module will exist in :data:`sys.modules` before the loader executes the "
"module code.  This is crucial because the module code may (directly or "
"indirectly) import itself; adding it to :data:`sys.modules` beforehand "
"prevents unbounded recursion in the worst case and multiple loading in the "
"best."
msgstr ""

#: reference/import.rst:381
msgid ""
"If loading fails, the failing module -- and only the failing module -- gets "
"removed from :data:`sys.modules`.  Any module already in the :data:`sys."
"modules` cache, and any module that was successfully loaded as a side-"
"effect, must remain in the cache.  This contrasts with reloading where even "
"the failing module is left in :data:`sys.modules`."
msgstr ""

#: reference/import.rst:387
msgid ""
"After the module is created but before execution, the import machinery sets "
"the import-related module attributes (\"_init_module_attrs\" in the pseudo-"
"code example above), as summarized in a :ref:`later section <import-mod-"
"attrs>`."
msgstr ""

#: reference/import.rst:392
msgid ""
"Module execution is the key moment of loading in which the module's "
"namespace gets populated.  Execution is entirely delegated to the loader, "
"which gets to decide what gets populated and how."
msgstr ""

#: reference/import.rst:396
msgid ""
"The module created during loading and passed to exec_module() may not be the "
"one returned at the end of import [#fnlo]_."
msgstr ""

#: reference/import.rst:399
msgid ""
"The import system has taken over the boilerplate responsibilities of "
"loaders.  These were previously performed by the :meth:`importlib.abc.Loader."
"load_module` method."
msgstr ""

#: reference/import.rst:405
msgid "Loaders"
msgstr ""

#: reference/import.rst:407
msgid ""
"Module loaders provide the critical function of loading: module execution. "
"The import machinery calls the :meth:`importlib.abc.Loader.exec_module` "
"method with a single argument, the module object to execute.  Any value "
"returned from :meth:`~importlib.abc.Loader.exec_module` is ignored."
msgstr ""

#: reference/import.rst:412
msgid "Loaders must satisfy the following requirements:"
msgstr ""

#: reference/import.rst:414
msgid ""
"If the module is a Python module (as opposed to a built-in module or a "
"dynamically loaded extension), the loader should execute the module's code "
"in the module's global name space (``module.__dict__``)."
msgstr ""

#: reference/import.rst:418
msgid ""
"If the loader cannot execute the module, it should raise an :exc:"
"`ImportError`, although any other exception raised during :meth:`~importlib."
"abc.Loader.exec_module` will be propagated."
msgstr ""

#: reference/import.rst:422
msgid ""
"In many cases, the finder and loader can be the same object; in such cases "
"the :meth:`~importlib.abc.MetaPathFinder.find_spec` method would just return "
"a spec with the loader set to ``self``."
msgstr ""

#: reference/import.rst:426
msgid ""
"Module loaders may opt in to creating the module object during loading by "
"implementing a :meth:`~importlib.abc.Loader.create_module` method. It takes "
"one argument, the module spec, and returns the new module object to use "
"during loading.  ``create_module()`` does not need to set any attributes on "
"the module object.  If the loader does not define ``create_module()``, the "
"import machinery will create the new module itself."
msgstr ""

#: reference/import.rst:433
msgid "The create_module() method of loaders."
msgstr ""

#: reference/import.rst:436
msgid ""
"The :meth:`~importlib.abc.Loader.load_module` method was replaced by :meth:"
"`~importlib.abc.Loader.exec_module` and the import machinery assumed all the "
"boilerplate responsibilities of loading."
msgstr ""

#: reference/import.rst:441
msgid ""
"For compatibility with existing loaders, the import machinery will use the "
"``load_module()`` method of loaders if it exists and the loader does not "
"also implement ``exec_module()``.  However, ``load_module()`` has been "
"deprecated and loaders should implement ``exec_module()`` instead."
msgstr ""

#: reference/import.rst:446
msgid ""
"The ``load_module()`` method must implement all the boilerplate loading "
"functionality described above in addition to executing the module.  All the "
"same constraints apply, with some additional clarification:"
msgstr ""

#: reference/import.rst:450
msgid ""
"If there is an existing module object with the given name in :data:`sys."
"modules`, the loader must use that existing module. (Otherwise, :func:"
"`importlib.reload` will not work correctly.)  If the named module does not "
"exist in :data:`sys.modules`, the loader must create a new module object and "
"add it to :data:`sys.modules`."
msgstr ""

#: reference/import.rst:456
msgid ""
"The module *must* exist in :data:`sys.modules` before the loader executes "
"the module code, to prevent unbounded recursion or multiple loading."
msgstr ""

#: reference/import.rst:460
msgid ""
"If loading fails, the loader must remove any modules it has inserted into :"
"data:`sys.modules`, but it must remove **only** the failing module, and only "
"if the loader itself has loaded it explicitly."
msgstr ""

#: reference/import.rst:465
msgid "Submodules"
msgstr ""

#: reference/import.rst:467
msgid ""
"When a submodule is loaded using any mechanism (e.g. ``importlib`` APIs, the "
"``import`` or ``import-from`` statements, or built-in ``__import__()``) a "
"binding is placed in the parent module's namespace to the submodule object. "
"For example, if package ``spam`` has a submodule ``foo``, after importing "
"``spam.foo``, ``spam`` will have an attribute ``foo`` which is bound to the "
"submodule.  Let's say you have the following directory structure::"
msgstr ""

#: reference/import.rst:479
msgid "and ``spam/__init__.py`` has the following lines in it::"
msgstr ""

#: reference/import.rst:484
msgid ""
"then executing the following puts a name binding to ``foo`` and ``bar`` in "
"the ``spam`` module::"
msgstr ""

#: reference/import.rst:493
msgid ""
"Given Python's familiar name binding rules this might seem surprising, but "
"it's actually a fundamental feature of the import system.  The invariant "
"holding is that if you have ``sys.modules['spam']`` and ``sys.modules['spam."
"foo']`` (as you would after the above import), the latter must appear as the "
"``foo`` attribute of the former."
msgstr ""

#: reference/import.rst:500
msgid "Module spec"
msgstr ""

#: reference/import.rst:502
msgid ""
"The import machinery uses a variety of information about each module during "
"import, especially before loading.  Most of the information is common to all "
"modules.  The purpose of a module's spec is to encapsulate this import-"
"related information on a per-module basis."
msgstr ""

#: reference/import.rst:507
msgid ""
"Using a spec during import allows state to be transferred between import "
"system components, e.g. between the finder that creates the module spec and "
"the loader that executes it.  Most importantly, it allows the import "
"machinery to perform the boilerplate operations of loading, whereas without "
"a module spec the loader had that responsibility."
msgstr ""

#: reference/import.rst:513
msgid ""
"See :class:`~importlib.machinery.ModuleSpec` for more specifics on what "
"information a module's spec may hold."
msgstr ""

#: reference/import.rst:521
msgid "Import-related module attributes"
msgstr ""

#: reference/import.rst:523
msgid ""
"The import machinery fills in these attributes on each module object during "
"loading, based on the module's spec, before the loader executes the module."
msgstr ""

#: reference/import.rst:529
msgid ""
"The ``__name__`` attribute must be set to the fully-qualified name of the "
"module.  This name is used to uniquely identify the module in the import "
"system."
msgstr ""

#: reference/import.rst:535
msgid ""
"The ``__loader__`` attribute must be set to the loader object that the "
"import machinery used when loading the module.  This is mostly for "
"introspection, but can be used for additional loader-specific functionality, "
"for example getting data associated with a loader."
msgstr ""

#: reference/import.rst:542
msgid ""
"The module's ``__package__`` attribute must be set.  Its value must be a "
"string, but it can be the same value as its ``__name__``.  When the module "
"is a package, its ``__package__`` value should be set to its ``__name__``.  "
"When the module is not a package, ``__package__`` should be set to the empty "
"string for top-level modules, or for submodules, to the parent package's "
"name.  See :pep:`366` for further details."
msgstr ""

#: reference/import.rst:550
msgid ""
"This attribute is used instead of ``__name__`` to calculate explicit "
"relative imports for main modules, as defined in :pep:`366`."
msgstr ""

#: reference/import.rst:555
msgid ""
"The ``__spec__`` attribute must be set to the module spec that was used when "
"importing the module.  This is used primarily for introspection and during "
"reloading.  Setting ``__spec__`` appropriately applies equally to :ref:"
"`modules initialized during interpreter startup <programs>`.  The one "
"exception is ``__main__``, where ``__spec__`` is :ref:`set to None in some "
"cases <main_spec>`."
msgstr ""

#: reference/import.rst:566
msgid ""
"If the module is a package (either regular or namespace), the module "
"object's ``__path__`` attribute must be set.  The value must be iterable, "
"but may be empty if ``__path__`` has no further significance. If "
"``__path__`` is not empty, it must produce strings when iterated over. More "
"details on the semantics of ``__path__`` are given :ref:`below <package-path-"
"rules>`."
msgstr ""

#: reference/import.rst:573
msgid "Non-package modules should not have a ``__path__`` attribute."
msgstr ""

#: reference/import.rst:578
msgid ""
"``__file__`` is optional. If set, this attribute's value must be a string.  "
"The import system may opt to leave ``__file__`` unset if it has no semantic "
"meaning (e.g. a module loaded from a database)."
msgstr ""

#: reference/import.rst:582
msgid ""
"If ``__file__`` is set, it may also be appropriate to set the ``__cached__`` "
"attribute which is the path to any compiled version of the code (e.g. byte-"
"compiled file). The file does not need to exist to set this attribute; the "
"path can simply point to where the compiled file would exist (see :pep:"
"`3147`)."
msgstr ""

#: reference/import.rst:588
msgid ""
"It is also appropriate to set ``__cached__`` when ``__file__`` is not set.  "
"However, that scenario is quite atypical.  Ultimately, the loader is what "
"makes use of ``__file__`` and/or ``__cached__``.  So if a loader can load "
"from a cached module but otherwise does not load from a file, that atypical "
"scenario may be appropriate."
msgstr ""

#: reference/import.rst:597
msgid "module.__path__"
msgstr ""

#: reference/import.rst:599
msgid ""
"By definition, if a module has an ``__path__`` attribute, it is a package, "
"regardless of its value."
msgstr ""

#: reference/import.rst:602
msgid ""
"A package's ``__path__`` attribute is used during imports of its "
"subpackages. Within the import machinery, it functions much the same as :"
"data:`sys.path`, i.e. providing a list of locations to search for modules "
"during import. However, ``__path__`` is typically much more constrained "
"than :data:`sys.path`."
msgstr ""

#: reference/import.rst:608
msgid ""
"``__path__`` must be an iterable of strings, but it may be empty. The same "
"rules used for :data:`sys.path` also apply to a package's ``__path__``, and :"
"data:`sys.path_hooks` (described below) are consulted when traversing a "
"package's ``__path__``."
msgstr ""

#: reference/import.rst:613
msgid ""
"A package's ``__init__.py`` file may set or alter the package's ``__path__`` "
"attribute, and this was typically the way namespace packages were "
"implemented prior to :pep:`420`.  With the adoption of :pep:`420`, namespace "
"packages no longer need to supply ``__init__.py`` files containing only "
"``__path__`` manipulation code; the import machinery automatically sets "
"``__path__`` correctly for the namespace package."
msgstr ""

#: reference/import.rst:621
msgid "Module reprs"
msgstr ""

#: reference/import.rst:623
msgid ""
"By default, all modules have a usable repr, however depending on the "
"attributes set above, and in the module's spec, you can more explicitly "
"control the repr of module objects."
msgstr ""

#: reference/import.rst:627
msgid ""
"If the module has a spec (``__spec__``), the import machinery will try to "
"generate a repr from it.  If that fails or there is no spec, the import "
"system will craft a default repr using whatever information is available on "
"the module.  It will try to use the ``module.__name__``, ``module."
"__file__``, and ``module.__loader__`` as input into the repr, with defaults "
"for whatever information is missing."
msgstr ""

#: reference/import.rst:634
msgid "Here are the exact rules used:"
msgstr ""

#: reference/import.rst:636
msgid ""
"If the module has a ``__spec__`` attribute, the information in the spec is "
"used to generate the repr.  The \"name\", \"loader\", \"origin\", and "
"\"has_location\" attributes are consulted."
msgstr ""

#: reference/import.rst:640
msgid ""
"If the module has a ``__file__`` attribute, this is used as part of the "
"module's repr."
msgstr ""

#: reference/import.rst:643
msgid ""
"If the module has no ``__file__`` but does have a ``__loader__`` that is not "
"``None``, then the loader's repr is used as part of the module's repr."
msgstr ""

#: reference/import.rst:646
msgid "Otherwise, just use the module's ``__name__`` in the repr."
msgstr ""

#: reference/import.rst:648
msgid ""
"Use of :meth:`loader.module_repr() <importlib.abc.Loader.module_repr>` has "
"been deprecated and the module spec is now used by the import machinery to "
"generate a module repr."
msgstr ""

#: reference/import.rst:653
msgid ""
"For backward compatibility with Python 3.3, the module repr will be "
"generated by calling the loader's :meth:`~importlib.abc.Loader.module_repr` "
"method, if defined, before trying either approach described above.  However, "
"the method is deprecated."
msgstr ""

#: reference/import.rst:660
msgid "The Path Based Finder"
msgstr ""

#: reference/import.rst:665
msgid ""
"As mentioned previously, Python comes with several default meta path "
"finders. One of these, called the :term:`path based finder` (:class:"
"`~importlib.machinery.PathFinder`), searches an :term:`import path`, which "
"contains a list of :term:`path entries <path entry>`.  Each path entry names "
"a location to search for modules."
msgstr ""

#: reference/import.rst:671
msgid ""
"The path based finder itself doesn't know how to import anything. Instead, "
"it traverses the individual path entries, associating each of them with a "
"path entry finder that knows how to handle that particular kind of path."
msgstr ""

#: reference/import.rst:675
msgid ""
"The default set of path entry finders implement all the semantics for "
"finding modules on the file system, handling special file types such as "
"Python source code (``.py`` files), Python byte code (``.pyc`` and ``.pyo`` "
"files) and shared libraries (e.g. ``.so`` files). When supported by the :mod:"
"`zipimport` module in the standard library, the default path entry finders "
"also handle loading all of these file types (other than shared libraries) "
"from zipfiles."
msgstr ""

#: reference/import.rst:682
msgid ""
"Path entries need not be limited to file system locations.  They can refer "
"to URLs, database queries, or any other location that can be specified as a "
"string."
msgstr ""

#: reference/import.rst:686
msgid ""
"The path based finder provides additional hooks and protocols so that you "
"can extend and customize the types of searchable path entries.  For example, "
"if you wanted to support path entries as network URLs, you could write a "
"hook that implements HTTP semantics to find modules on the web.  This hook "
"(a callable) would return a :term:`path entry finder` supporting the "
"protocol described below, which was then used to get a loader for the module "
"from the web."
msgstr ""

#: reference/import.rst:694
msgid ""
"A word of warning: this section and the previous both use the term *finder*, "
"distinguishing between them by using the terms :term:`meta path finder` and :"
"term:`path entry finder`.  These two types of finders are very similar, "
"support similar protocols, and function in similar ways during the import "
"process, but it's important to keep in mind that they are subtly different. "
"In particular, meta path finders operate at the beginning of the import "
"process, as keyed off the :data:`sys.meta_path` traversal."
msgstr ""

#: reference/import.rst:702
msgid ""
"By contrast, path entry finders are in a sense an implementation detail of "
"the path based finder, and in fact, if the path based finder were to be "
"removed from :data:`sys.meta_path`, none of the path entry finder semantics "
"would be invoked."
msgstr ""

#: reference/import.rst:709
msgid "Path entry finders"
msgstr ""

#: reference/import.rst:717
msgid ""
"The :term:`path based finder` is responsible for finding and loading Python "
"modules and packages whose location is specified with a string :term:`path "
"entry`.  Most path entries name locations in the file system, but they need "
"not be limited to this."
msgstr ""

#: reference/import.rst:722
msgid ""
"As a meta path finder, the :term:`path based finder` implements the :meth:"
"`~importlib.abc.MetaPathFinder.find_spec` protocol previously described, "
"however it exposes additional hooks that can be used to customize how "
"modules are found and loaded from the :term:`import path`."
msgstr ""

#: reference/import.rst:727
msgid ""
"Three variables are used by the :term:`path based finder`, :data:`sys."
"path`, :data:`sys.path_hooks` and :data:`sys.path_importer_cache`.  The "
"``__path__`` attributes on package objects are also used.  These provide "
"additional ways that the import machinery can be customized."
msgstr ""

#: reference/import.rst:732
msgid ""
":data:`sys.path` contains a list of strings providing search locations for "
"modules and packages.  It is initialized from the :data:`PYTHONPATH` "
"environment variable and various other installation- and implementation-"
"specific defaults.  Entries in :data:`sys.path` can name directories on the "
"file system, zip files, and potentially other \"locations\" (see the :mod:"
"`site` module) that should be searched for modules, such as URLs, or "
"database queries.  Only strings and bytes should be present on :data:`sys."
"path`; all other data types are ignored.  The encoding of bytes entries is "
"determined by the individual :term:`path entry finders <path entry finder>`."
msgstr ""

#: reference/import.rst:743
msgid ""
"The :term:`path based finder` is a :term:`meta path finder`, so the import "
"machinery begins the :term:`import path` search by calling the path based "
"finder's :meth:`~importlib.machinery.PathFinder.find_spec` method as "
"described previously.  When the ``path`` argument to :meth:`~importlib."
"machinery.PathFinder.find_spec` is given, it will be a list of string paths "
"to traverse - typically a package's ``__path__`` attribute for an import "
"within that package.  If the ``path`` argument is ``None``, this indicates a "
"top level import and :data:`sys.path` is used."
msgstr ""

#: reference/import.rst:752
msgid ""
"The path based finder iterates over every entry in the search path, and for "
"each of these, looks for an appropriate :term:`path entry finder` (:class:"
"`~importlib.abc.PathEntryFinder`) for the path entry.  Because this can be "
"an expensive operation (e.g. there may be `stat()` call overheads for this "
"search), the path based finder maintains a cache mapping path entries to "
"path entry finders.  This cache is maintained in :data:`sys."
"path_importer_cache` (despite the name, this cache actually stores finder "
"objects rather than being limited to :term:`importer` objects). In this way, "
"the expensive search for a particular :term:`path entry` location's :term:"
"`path entry finder` need only be done once.  User code is free to remove "
"cache entries from :data:`sys.path_importer_cache` forcing the path based "
"finder to perform the path entry search again [#fnpic]_."
msgstr ""

#: reference/import.rst:765
msgid ""
"If the path entry is not present in the cache, the path based finder "
"iterates over every callable in :data:`sys.path_hooks`.  Each of the :term:"
"`path entry hooks <path entry hook>` in this list is called with a single "
"argument, the path entry to be searched.  This callable may either return a :"
"term:`path entry finder` that can handle the path entry, or it may raise :"
"exc:`ImportError`.  An :exc:`ImportError` is used by the path based finder "
"to signal that the hook cannot find a :term:`path entry finder`. for that :"
"term:`path entry`.  The exception is ignored and :term:`import path` "
"iteration continues.  The hook should expect either a string or bytes "
"object; the encoding of bytes objects is up to the hook (e.g. it may be a "
"file system encoding, UTF-8, or something else), and if the hook cannot "
"decode the argument, it should raise :exc:`ImportError`."
msgstr ""

#: reference/import.rst:779
msgid ""
"If :data:`sys.path_hooks` iteration ends with no :term:`path entry finder` "
"being returned, then the path based finder's :meth:`~importlib.machinery."
"PathFinder.find_spec` method will store ``None`` in :data:`sys."
"path_importer_cache` (to indicate that there is no finder for this path "
"entry) and return ``None``, indicating that this :term:`meta path finder` "
"could not find the module."
msgstr ""

#: reference/import.rst:786
msgid ""
"If a :term:`path entry finder` *is* returned by one of the :term:`path entry "
"hook` callables on :data:`sys.path_hooks`, then the following protocol is "
"used to ask the finder for a module spec, which is then used when loading "
"the module."
msgstr ""

#: reference/import.rst:792
msgid "Path entry finder protocol"
msgstr ""

#: reference/import.rst:794
msgid ""
"In order to support imports of modules and initialized packages and also to "
"contribute portions to namespace packages, path entry finders must implement "
"the :meth:`~importlib.abc.PathEntryFinder.find_spec` method."
msgstr ""

#: reference/import.rst:798
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` takes two argument, the "
"fully qualified name of the module being imported, and the (optional) target "
"module.  ``find_spec()`` returns a fully populated spec for the module. This "
"spec will always have \"loader\" set (with one exception)."
msgstr ""

#: reference/import.rst:803
msgid ""
"To indicate to the import machinery that the spec represents a namespace :"
"term:`portion`. the path entry finder sets \"loader\" on the spec to "
"``None`` and \"submodule_search_locations\" to a list containing the portion."
msgstr ""

#: reference/import.rst:808
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_spec` replaced :meth:`~importlib."
"abc.PathEntryFinder.find_loader` and :meth:`~importlib.abc.PathEntryFinder."
"find_module`, both of which are now deprecated, but will be used if "
"``find_spec()`` is not defined."
msgstr ""

#: reference/import.rst:814
msgid ""
"Older path entry finders may implement one of these two deprecated methods "
"instead of ``find_spec()``.  The methods are still respected for the sake of "
"backward compatibility.  Howevever, if ``find_spec()`` is implemented on the "
"path entry finder, the legacy methods are ignored."
msgstr ""

#: reference/import.rst:819
msgid ""
":meth:`~importlib.abc.PathEntryFinder.find_loader` takes one argument, the "
"fully qualified name of the module being imported.  ``find_loader()`` "
"returns a 2-tuple where the first item is the loader and the second item is "
"a namespace :term:`portion`.  When the first item (i.e. the loader) is "
"``None``, this means that while the path entry finder does not have a loader "
"for the named module, it knows that the path entry contributes to a "
"namespace portion for the named module.  This will almost always be the case "
"where Python is asked to import a namespace package that has no physical "
"presence on the file system.  When a path entry finder returns ``None`` for "
"the loader, the second item of the 2-tuple return value must be a sequence, "
"although it can be empty."
msgstr ""

#: reference/import.rst:831
msgid ""
"If ``find_loader()`` returns a non-``None`` loader value, the portion is "
"ignored and the loader is returned from the path based finder, terminating "
"the search through the path entries."
msgstr ""

#: reference/import.rst:835
msgid ""
"For backwards compatibility with other implementations of the import "
"protocol, many path entry finders also support the same, traditional "
"``find_module()`` method that meta path finders support. However path entry "
"finder ``find_module()`` methods are never called with a ``path`` argument "
"(they are expected to record the appropriate path information from the "
"initial call to the path hook)."
msgstr ""

#: reference/import.rst:842
msgid ""
"The ``find_module()`` method on path entry finders is deprecated, as it does "
"not allow the path entry finder to contribute portions to namespace "
"packages.  If both ``find_loader()`` and ``find_module()`` exist on a path "
"entry finder, the import system will always call ``find_loader()`` in "
"preference to ``find_module()``."
msgstr ""

#: reference/import.rst:850
msgid "Replacing the standard import system"
msgstr ""

#: reference/import.rst:852
msgid ""
"The most reliable mechanism for replacing the entire import system is to "
"delete the default contents of :data:`sys.meta_path`, replacing them "
"entirely with a custom meta path hook."
msgstr ""

#: reference/import.rst:856
msgid ""
"If it is acceptable to only alter the behaviour of import statements without "
"affecting other APIs that access the import system, then replacing the "
"builtin :func:`__import__` function may be sufficient. This technique may "
"also be employed at the module level to only alter the behaviour of import "
"statements within that module."
msgstr ""

#: reference/import.rst:862
msgid ""
"To selectively prevent import of some modules from a hook early on the meta "
"path (rather than disabling the standard import system entirely), it is "
"sufficient to raise :exc:`ImportError` directly from :meth:`~importlib.abc."
"MetaPathFinder.find_spec` instead of returning ``None``. The latter "
"indicates that the meta path search should continue, while raising an "
"exception terminates it immediately."
msgstr ""

#: reference/import.rst:871
msgid "Special considerations for __main__"
msgstr ""

#: reference/import.rst:873
msgid ""
"The :mod:`__main__` module is a special case relative to Python's import "
"system.  As noted :ref:`elsewhere <programs>`, the ``__main__`` module is "
"directly initialized at interpreter startup, much like :mod:`sys` and :mod:"
"`builtins`.  However, unlike those two, it doesn't strictly qualify as a "
"built-in module.  This is because the manner in which ``__main__`` is "
"initialized depends on the flags and other options with which the "
"interpreter is invoked."
msgstr ""

#: reference/import.rst:884
msgid "__main__.__spec__"
msgstr ""

#: reference/import.rst:886
msgid ""
"Depending on how :mod:`__main__` is initialized, ``__main__.__spec__`` gets "
"set appropriately or to ``None``."
msgstr ""

#: reference/import.rst:889
msgid ""
"When Python is started with the :option:`-m` option, ``__spec__`` is set to "
"the module spec of the corresponding module or package. ``__spec__`` is also "
"populated when the ``__main__`` module is loaded as part of executing a "
"directory, zipfile or other :data:`sys.path` entry."
msgstr ""

#: reference/import.rst:894
msgid ""
"In :ref:`the remaining cases <using-on-interface-options>` ``__main__."
"__spec__`` is set to ``None``, as the code used to populate the :mod:"
"`__main__` does not correspond directly with an importable module:"
msgstr ""

#: reference/import.rst:898
msgid "interactive prompt"
msgstr ""

#: reference/import.rst:899
msgid "-c switch"
msgstr ""

#: reference/import.rst:900
msgid "running from stdin"
msgstr ""

#: reference/import.rst:901
msgid "running directly from a source or bytecode file"
msgstr ""

#: reference/import.rst:903
msgid ""
"Note that ``__main__.__spec__`` is always ``None`` in the last case, *even "
"if* the file could technically be imported directly as a module instead. Use "
"the :option:`-m` switch if valid module metadata is desired in :mod:"
"`__main__`."
msgstr ""

#: reference/import.rst:908
msgid ""
"Note also that even when ``__main__`` corresponds with an importable module "
"and ``__main__.__spec__`` is set accordingly, they're still considered "
"*distinct* modules. This is due to the fact that blocks guarded by ``if "
"__name__ == \"__main__\":`` checks only execute when the module is used to "
"populate the ``__main__`` namespace, and not during normal import."
msgstr ""

#: reference/import.rst:916
msgid "Open issues"
msgstr ""

#: reference/import.rst:918
msgid "XXX It would be really nice to have a diagram."
msgstr ""

#: reference/import.rst:920
msgid ""
"XXX * (import_machinery.rst) how about a section devoted just to the "
"attributes of modules and packages, perhaps expanding upon or supplanting "
"the related entries in the data model reference page?"
msgstr ""

#: reference/import.rst:924
msgid ""
"XXX runpy, pkgutil, et al in the library manual should all get \"See Also\" "
"links at the top pointing to the new import system section."
msgstr ""

#: reference/import.rst:927
msgid ""
"XXX Add more explanation regarding the different ways in which ``__main__`` "
"is initialized?"
msgstr ""

#: reference/import.rst:930
msgid ""
"XXX Add more info on ``__main__`` quirks/pitfalls (i.e. copy from :pep:"
"`395`)."
msgstr ""

#: reference/import.rst:935
msgid "References"
msgstr ""

#: reference/import.rst:937
msgid ""
"The import machinery has evolved considerably since Python's early days.  "
"The original `specification for packages <http://legacy.python.org/doc/"
"essays/packages.html>`_ is still available to read, although some details "
"have changed since the writing of that document."
msgstr ""

#: reference/import.rst:942
msgid ""
"The original specification for :data:`sys.meta_path` was :pep:`302`, with "
"subsequent extension in :pep:`420`."
msgstr ""

#: reference/import.rst:945
msgid ""
":pep:`420` introduced :term:`namespace packages <namespace package>` for "
"Python 3.3.  :pep:`420` also introduced the :meth:`find_loader` protocol as "
"an alternative to :meth:`find_module`."
msgstr ""

#: reference/import.rst:949
msgid ""
":pep:`366` describes the addition of the ``__package__`` attribute for "
"explicit relative imports in main modules."
msgstr ""

#: reference/import.rst:952
msgid ""
":pep:`328` introduced absolute and explicit relative imports and initially "
"proposed ``__name__`` for semantics :pep:`366` would eventually specify for "
"``__package__``."
msgstr ""

#: reference/import.rst:956
msgid ":pep:`338` defines executing modules as scripts."
msgstr ""

#: reference/import.rst:958
msgid ""
":pep:`451` adds the encapsulation of per-module import state in spec "
"objects.  It also off-loads most of the boilerplate responsibilities of "
"loaders back onto the import machinery.  These changes allow the deprecation "
"of several APIs in the import system and also addition of new methods to "
"finders and loaders."
msgstr ""

#: reference/import.rst:966
msgid "See :class:`types.ModuleType`."
msgstr ""

#: reference/import.rst:968
msgid ""
"The importlib implementation avoids using the return value directly. "
"Instead, it gets the module object by looking the module name up in :data:"
"`sys.modules`.  The indirect effect of this is that an imported module may "
"replace itself in :data:`sys.modules`.  This is implementation-specific "
"behavior that is not guaranteed to work in other Python implementations."
msgstr ""

#: reference/import.rst:975
msgid ""
"In legacy code, it is possible to find instances of :class:`imp."
"NullImporter` in the :data:`sys.path_importer_cache`.  It is recommended "
"that code be changed to use ``None`` instead.  See :ref:`portingpythoncode` "
"for more details."
msgstr ""

#: reference/index.rst:5
msgid "The Python Language Reference"
msgstr ""

#: reference/index.rst:7
msgid ""
"This reference manual describes the syntax and \"core semantics\" of the "
"language. It is terse, but attempts to be exact and complete. The semantics "
"of non-essential built-in object types and of the built-in functions and "
"modules are described in :ref:`library-index`. For an informal introduction "
"to the language, see :ref:`tutorial-index`. For C or C++ programmers, two "
"additional manuals exist: :ref:`extending-index` describes the high-level "
"picture of how to write a Python extension module, and the :ref:`c-api-"
"index` describes the interfaces available to C/C++ programmers in detail."
msgstr ""

#: reference/introduction.rst:6
msgid "Introduction"
msgstr "Introduction"

#: reference/introduction.rst:8
msgid ""
"This reference manual describes the Python programming language. It is not "
"intended as a tutorial."
msgstr ""

#: reference/introduction.rst:11
msgid ""
"While I am trying to be as precise as possible, I chose to use English "
"rather than formal specifications for everything except syntax and lexical "
"analysis. This should make the document more understandable to the average "
"reader, but will leave room for ambiguities. Consequently, if you were "
"coming from Mars and tried to re-implement Python from this document alone, "
"you might have to guess things and in fact you would probably end up "
"implementing quite a different language. On the other hand, if you are using "
"Python and wonder what the precise rules about a particular area of the "
"language are, you should definitely be able to find them here. If you would "
"like to see a more formal definition of the language, maybe you could "
"volunteer your time --- or invent a cloning machine :-)."
msgstr ""

#: reference/introduction.rst:23
msgid ""
"It is dangerous to add too many implementation details to a language "
"reference document --- the implementation may change, and other "
"implementations of the same language may work differently.  On the other "
"hand, CPython is the one Python implementation in widespread use (although "
"alternate implementations continue to gain support), and its particular "
"quirks are sometimes worth being mentioned, especially where the "
"implementation imposes additional limitations. Therefore, you'll find short "
"\"implementation notes\" sprinkled throughout the text."
msgstr ""

#: reference/introduction.rst:32
msgid ""
"Every Python implementation comes with a number of built-in and standard "
"modules.  These are documented in :ref:`library-index`.  A few built-in "
"modules are mentioned when they interact in a significant way with the "
"language definition."
msgstr ""

#: reference/introduction.rst:41
msgid "Alternate Implementations"
msgstr ""

#: reference/introduction.rst:43
msgid ""
"Though there is one Python implementation which is by far the most popular, "
"there are some alternate implementations which are of particular interest to "
"different audiences."
msgstr ""

#: reference/introduction.rst:47
msgid "Known implementations include:"
msgstr ""

#: reference/introduction.rst:51
msgid "CPython"
msgstr "CPython"

#: reference/introduction.rst:50
msgid ""
"This is the original and most-maintained implementation of Python, written "
"in C. New language features generally appear here first."
msgstr ""

#: reference/introduction.rst:57
msgid "Jython"
msgstr ""

#: reference/introduction.rst:54
msgid ""
"Python implemented in Java.  This implementation can be used as a scripting "
"language for Java applications, or can be used to create applications using "
"the Java class libraries.  It is also often used to create tests for Java "
"libraries. More information can be found at `the Jython website <http://www."
"jython.org/>`_."
msgstr ""

#: reference/introduction.rst:63
msgid "Python for .NET"
msgstr ""

#: reference/introduction.rst:60
msgid ""
"This implementation actually uses the CPython implementation, but is a "
"managed .NET application and makes .NET libraries available.  It was created "
"by Brian Lloyd.  For more information, see the `Python for .NET home page "
"<http://pythonnet.sourceforge.net>`_."
msgstr ""

#: reference/introduction.rst:69
msgid "IronPython"
msgstr ""

#: reference/introduction.rst:66
msgid ""
"An alternate Python for .NET.  Unlike Python.NET, this is a complete Python "
"implementation that generates IL, and compiles Python code directly to .NET "
"assemblies.  It was created by Jim Hugunin, the original creator of Jython.  "
"For more information, see `the IronPython website <http://ironpython.net/>`_."
msgstr ""

#: reference/introduction.rst:77
msgid "PyPy"
msgstr ""

#: reference/introduction.rst:72
msgid ""
"An implementation of Python written completely in Python. It supports "
"several advanced features not found in other implementations like stackless "
"support and a Just in Time compiler. One of the goals of the project is to "
"encourage experimentation with the language itself by making it easier to "
"modify the interpreter (since it is written in Python).  Additional "
"information is available on `the PyPy project's home page <http://pypy.org/"
">`_."
msgstr ""

#: reference/introduction.rst:79
msgid ""
"Each of these implementations varies in some way from the language as "
"documented in this manual, or introduces specific information beyond what's "
"covered in the standard Python documentation.  Please refer to the "
"implementation-specific documentation to determine what else you need to "
"know about the specific implementation you're using."
msgstr ""

#: reference/introduction.rst:89
msgid "Notation"
msgstr ""

#: reference/introduction.rst:93
msgid ""
"The descriptions of lexical analysis and syntax use a modified BNF grammar "
"notation.  This uses the following style of definition:"
msgstr ""

#: reference/introduction.rst:100
msgid ""
"The first line says that a ``name`` is an ``lc_letter`` followed by a "
"sequence of zero or more ``lc_letter``\\ s and underscores.  An "
"``lc_letter`` in turn is any of the single characters ``'a'`` through "
"``'z'``.  (This rule is actually adhered to for the names defined in lexical "
"and grammar rules in this document.)"
msgstr ""

#: reference/introduction.rst:105
msgid ""
"Each rule begins with a name (which is the name defined by the rule) and ``::"
"=``.  A vertical bar (``|``) is used to separate alternatives; it is the "
"least binding operator in this notation.  A star (``*``) means zero or more "
"repetitions of the preceding item; likewise, a plus (``+``) means one or "
"more repetitions, and a phrase enclosed in square brackets (``[ ]``) means "
"zero or one occurrences (in other words, the enclosed phrase is optional).  "
"The ``*`` and ``+`` operators bind as tightly as possible; parentheses are "
"used for grouping.  Literal strings are enclosed in quotes.  White space is "
"only meaningful to separate tokens. Rules are normally contained on a single "
"line; rules with many alternatives may be formatted alternatively with each "
"line after the first beginning with a vertical bar."
msgstr ""

#: reference/introduction.rst:119
msgid ""
"In lexical definitions (as the example above), two more conventions are "
"used: Two literal characters separated by three dots mean a choice of any "
"single character in the given (inclusive) range of ASCII characters.  A "
"phrase between angular brackets (``<...>``) gives an informal description of "
"the symbol defined; e.g., this could be used to describe the notion of "
"'control character' if needed."
msgstr ""

#: reference/introduction.rst:126
msgid ""
"Even though the notation used is almost the same, there is a big difference "
"between the meaning of lexical and syntactic definitions: a lexical "
"definition operates on the individual characters of the input source, while "
"a syntax definition operates on the stream of tokens generated by the "
"lexical analysis. All uses of BNF in the next chapter (\"Lexical Analysis\") "
"are lexical definitions; uses in subsequent chapters are syntactic "
"definitions."
msgstr ""

#: reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr ""

#: reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""

#: reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""

#: reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr ""

#: reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr ""

#: reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr ""

#: reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""

#: reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr ""

#: reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files, any of the standard platform line termination "
"sequences can be used - the Unix form using ASCII LF (linefeed), the Windows "
"form using the ASCII sequence CR LF (return followed by linefeed), or the "
"old Macintosh form using the ASCII CR (return) character.  All of these "
"forms can be used equally, regardless of platform."
msgstr ""

#: reference/lexical_analysis.rst:56
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""

#: reference/lexical_analysis.rst:64
msgid "Comments"
msgstr ""

#: reference/lexical_analysis.rst:68
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax; they are not tokens."
msgstr ""

#: reference/lexical_analysis.rst:77
msgid "Encoding declarations"
msgstr ""

#: reference/lexical_analysis.rst:81
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""

#: reference/lexical_analysis.rst:90
msgid "which is recognized also by GNU Emacs, and ::"
msgstr ""

#: reference/lexical_analysis.rst:94
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr ""

#: reference/lexical_analysis.rst:96
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""

#: reference/lexical_analysis.rst:101
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, including string literals, "
"comments and identifiers."
msgstr ""

#: reference/lexical_analysis.rst:111
msgid "Explicit line joining"
msgstr ""

#: reference/lexical_analysis.rst:115
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""

#: reference/lexical_analysis.rst:126
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""

#: reference/lexical_analysis.rst:136
msgid "Implicit line joining"
msgstr ""

#: reference/lexical_analysis.rst:138
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""

#: reference/lexical_analysis.rst:146
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""

#: reference/lexical_analysis.rst:156
msgid "Blank lines"
msgstr ""

#: reference/lexical_analysis.rst:160
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""

#: reference/lexical_analysis.rst:171
msgid "Indentation"
msgstr ""

#: reference/lexical_analysis.rst:175
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""

#: reference/lexical_analysis.rst:179
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""

#: reference/lexical_analysis.rst:187
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""

#: reference/lexical_analysis.rst:191
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""

#: reference/lexical_analysis.rst:196
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""

#: reference/lexical_analysis.rst:203
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""

#: reference/lexical_analysis.rst:206
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""

#: reference/lexical_analysis.rst:217
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""

#: reference/lexical_analysis.rst:232
msgid "The following example shows various indentation errors::"
msgstr ""

#: reference/lexical_analysis.rst:242
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""

#: reference/lexical_analysis.rst:250
msgid "Whitespace between tokens"
msgstr ""

#: reference/lexical_analysis.rst:252
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""

#: reference/lexical_analysis.rst:262
msgid "Other tokens"
msgstr ""

#: reference/lexical_analysis.rst:264
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""

#: reference/lexical_analysis.rst:274
msgid "Identifiers and keywords"
msgstr ""

#: reference/lexical_analysis.rst:278
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""

#: reference/lexical_analysis.rst:281
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""

#: reference/lexical_analysis.rst:285
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""

#: reference/lexical_analysis.rst:290
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""

#: reference/lexical_analysis.rst:294
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""

#: reference/lexical_analysis.rst:303
msgid "The Unicode category codes mentioned above stand for:"
msgstr ""

#: reference/lexical_analysis.rst:305
msgid "*Lu* - uppercase letters"
msgstr ""

#: reference/lexical_analysis.rst:306
msgid "*Ll* - lowercase letters"
msgstr ""

#: reference/lexical_analysis.rst:307
msgid "*Lt* - titlecase letters"
msgstr ""

#: reference/lexical_analysis.rst:308
msgid "*Lm* - modifier letters"
msgstr ""

#: reference/lexical_analysis.rst:309
msgid "*Lo* - other letters"
msgstr ""

#: reference/lexical_analysis.rst:310
msgid "*Nl* - letter numbers"
msgstr ""

#: reference/lexical_analysis.rst:311
msgid "*Mn* - nonspacing marks"
msgstr ""

#: reference/lexical_analysis.rst:312
msgid "*Mc* - spacing combining marks"
msgstr ""

#: reference/lexical_analysis.rst:313
msgid "*Nd* - decimal numbers"
msgstr ""

#: reference/lexical_analysis.rst:314
msgid "*Pc* - connector punctuations"
msgstr ""

#: reference/lexical_analysis.rst:315
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <http://www."
"unicode.org/Public/6.3.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""

#: reference/lexical_analysis.rst:318
msgid "*Other_ID_Continue* - likewise"
msgstr ""

#: reference/lexical_analysis.rst:320
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""

#: reference/lexical_analysis.rst:323
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at http://www.dcl.hpi.uni-potsdam.de/home/loewis/"
"table-3131.html."
msgstr ""

#: reference/lexical_analysis.rst:331
msgid "Keywords"
msgstr ""

#: reference/lexical_analysis.rst:337
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""

#: reference/lexical_analysis.rst:354
msgid "Reserved classes of identifiers"
msgstr ""

#: reference/lexical_analysis.rst:356
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""

#: reference/lexical_analysis.rst:370
msgid "_*"
msgstr ""

#: reference/lexical_analysis.rst:361
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""

#: reference/lexical_analysis.rst:368
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""

#: reference/lexical_analysis.rst:378
msgid "__*__"
msgstr ""

#: reference/lexical_analysis.rst:373
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr ""

#: reference/lexical_analysis.rst:385
msgid "__*"
msgstr ""

#: reference/lexical_analysis.rst:381
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""

#: reference/lexical_analysis.rst:394
msgid "Literals are notations for constant values of some built-in types."
msgstr ""

#: reference/lexical_analysis.rst:400
msgid "String and Bytes literals"
msgstr ""

#: reference/lexical_analysis.rst:404
msgid "String literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:428
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or :token:"
"`bytesprefix` and the rest of the literal. The source character set is "
"defined by the encoding declaration; it is UTF-8 if no encoding declaration "
"is given in the source file; see section :ref:`encodings`."
msgstr ""

#: reference/lexical_analysis.rst:436
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""

#: reference/lexical_analysis.rst:443
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""

#: reference/lexical_analysis.rst:448
msgid ""
"As of Python 3.3 it is possible again to prefix string literals with a ``u`` "
"prefix to simplify maintenance of dual 2.x and 3.x codebases."
msgstr ""

#: reference/lexical_analysis.rst:451
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""

#: reference/lexical_analysis.rst:458
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""

#: reference/lexical_analysis.rst:462
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""

#: reference/lexical_analysis.rst:467
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""

#: reference/lexical_analysis.rst:473
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""

#: reference/lexical_analysis.rst:478 reference/lexical_analysis.rst:511
msgid "Escape Sequence"
msgstr ""

#: reference/lexical_analysis.rst:478 reference/lexical_analysis.rst:511
msgid "Notes"
msgstr "Notes"

#: reference/lexical_analysis.rst:480
msgid "``\\newline``"
msgstr ""

#: reference/lexical_analysis.rst:480
msgid "Backslash and newline ignored"
msgstr ""

#: reference/lexical_analysis.rst:482
msgid "``\\\\``"
msgstr ""

#: reference/lexical_analysis.rst:482
msgid "Backslash (``\\``)"
msgstr ""

#: reference/lexical_analysis.rst:484
msgid "``\\'``"
msgstr ""

#: reference/lexical_analysis.rst:484
msgid "Single quote (``'``)"
msgstr ""

#: reference/lexical_analysis.rst:486
msgid "``\\\"``"
msgstr ""

#: reference/lexical_analysis.rst:486
msgid "Double quote (``\"``)"
msgstr ""

#: reference/lexical_analysis.rst:488
msgid "``\\a``"
msgstr ""

#: reference/lexical_analysis.rst:488
msgid "ASCII Bell (BEL)"
msgstr ""

#: reference/lexical_analysis.rst:490
msgid "``\\b``"
msgstr "``\\b``"

#: reference/lexical_analysis.rst:490
msgid "ASCII Backspace (BS)"
msgstr ""

#: reference/lexical_analysis.rst:492
msgid "``\\f``"
msgstr ""

#: reference/lexical_analysis.rst:492
msgid "ASCII Formfeed (FF)"
msgstr ""

#: reference/lexical_analysis.rst:494
msgid "``\\n``"
msgstr "``\\n``"

#: reference/lexical_analysis.rst:494
msgid "ASCII Linefeed (LF)"
msgstr ""

#: reference/lexical_analysis.rst:496
msgid "``\\r``"
msgstr "``\\r``"

#: reference/lexical_analysis.rst:496
msgid "ASCII Carriage Return (CR)"
msgstr ""

#: reference/lexical_analysis.rst:498
msgid "``\\t``"
msgstr ""

#: reference/lexical_analysis.rst:498
msgid "ASCII Horizontal Tab (TAB)"
msgstr ""

#: reference/lexical_analysis.rst:500
msgid "``\\v``"
msgstr ""

#: reference/lexical_analysis.rst:500
msgid "ASCII Vertical Tab (VT)"
msgstr ""

#: reference/lexical_analysis.rst:502
msgid "``\\ooo``"
msgstr ""

#: reference/lexical_analysis.rst:502
msgid "Character with octal value *ooo*"
msgstr ""

#: reference/lexical_analysis.rst:502
msgid "(1,3)"
msgstr ""

#: reference/lexical_analysis.rst:505
msgid "``\\xhh``"
msgstr ""

#: reference/lexical_analysis.rst:505
msgid "Character with hex value *hh*"
msgstr ""

#: reference/lexical_analysis.rst:505
msgid "(2,3)"
msgstr ""

#: reference/lexical_analysis.rst:508
msgid "Escape sequences only recognized in string literals are:"
msgstr ""

#: reference/lexical_analysis.rst:513
msgid "``\\N{name}``"
msgstr ""

#: reference/lexical_analysis.rst:513
msgid "Character named *name* in the Unicode database"
msgstr ""

#: reference/lexical_analysis.rst:513
msgid "\\(4)"
msgstr "\\(4)"

#: reference/lexical_analysis.rst:516
msgid "``\\uxxxx``"
msgstr ""

#: reference/lexical_analysis.rst:516
msgid "Character with 16-bit hex value *xxxx*"
msgstr ""

#: reference/lexical_analysis.rst:516
msgid "\\(5)"
msgstr "\\(5)"

#: reference/lexical_analysis.rst:519
msgid "``\\Uxxxxxxxx``"
msgstr ""

#: reference/lexical_analysis.rst:519
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr ""

#: reference/lexical_analysis.rst:519
msgid "\\(6)"
msgstr "\\(6)"

#: reference/lexical_analysis.rst:523
msgid "Notes:"
msgstr "Notes : "

#: reference/lexical_analysis.rst:526
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""

#: reference/lexical_analysis.rst:529
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""

#: reference/lexical_analysis.rst:532
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""

#: reference/lexical_analysis.rst:537
msgid "Support for name aliases [#]_ has been added."
msgstr ""

#: reference/lexical_analysis.rst:541
msgid ""
"Individual code units which form parts of a surrogate pair can be encoded "
"using this escape sequence.  Exactly four hex digits are required."
msgstr ""

#: reference/lexical_analysis.rst:545
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""

#: reference/lexical_analysis.rst:551
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""

#: reference/lexical_analysis.rst:558
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""

#: reference/lexical_analysis.rst:571
msgid "String literal concatenation"
msgstr ""

#: reference/lexical_analysis.rst:573
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""

#: reference/lexical_analysis.rst:584
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings)."
msgstr ""

#: reference/lexical_analysis.rst:593
msgid "Numeric literals"
msgstr ""

#: reference/lexical_analysis.rst:599
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""

#: reference/lexical_analysis.rst:603
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""

#: reference/lexical_analysis.rst:611
msgid "Integer literals"
msgstr ""

#: reference/lexical_analysis.rst:613
msgid "Integer literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:627
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""

#: reference/lexical_analysis.rst:630
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""

#: reference/lexical_analysis.rst:634
msgid "Some examples of integer literals::"
msgstr ""

#: reference/lexical_analysis.rst:643
msgid "Floating point literals"
msgstr ""

#: reference/lexical_analysis.rst:645
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:655
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent. Some examples of floating point literals::"
msgstr ""

#: reference/lexical_analysis.rst:662
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator ``-`` and the literal "
"``1``."
msgstr ""

#: reference/lexical_analysis.rst:670
msgid "Imaginary literals"
msgstr ""

#: reference/lexical_analysis.rst:672
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""

#: reference/lexical_analysis.rst:677
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""

#: reference/lexical_analysis.rst:689
msgid "Operators"
msgstr ""

#: reference/lexical_analysis.rst:693
msgid "The following tokens are operators::"
msgstr ""

#: reference/lexical_analysis.rst:703
msgid "Delimiters"
msgstr ""

#: reference/lexical_analysis.rst:707
msgid "The following tokens serve as delimiters in the grammar::"
msgstr ""

#: reference/lexical_analysis.rst:714
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""

#: reference/lexical_analysis.rst:719
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer::"
msgstr ""

#: reference/lexical_analysis.rst:724
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error::"
msgstr ""

#: reference/lexical_analysis.rst:732
msgid "http://www.unicode.org/Public/6.3.0/ucd/NameAliases.txt"
msgstr ""

#: reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr ""

#: reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several simple "
"statements may occur on a single line separated by semicolons.  The syntax "
"for simple statements is:"
msgstr ""

#: reference/simple_stmts.rst:34
msgid "Expression statements"
msgstr ""

#: reference/simple_stmts.rst:41
msgid ""
"Expression statements are used (mostly interactively) to compute and write a "
"value, or (usually) to call a procedure (a function that returns no "
"meaningful result; in Python, procedures return the value ``None``).  Other "
"uses of expression statements are allowed and occasionally useful.  The "
"syntax for an expression statement is:"
msgstr ""

#: reference/simple_stmts.rst:50
msgid ""
"An expression statement evaluates the expression list (which may be a single "
"expression)."
msgstr ""

#: reference/simple_stmts.rst:62
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string is "
"written to standard output on a line by itself (except if the result is "
"``None``, so that procedure calls do not cause any output.)"
msgstr ""

#: reference/simple_stmts.rst:70
msgid "Assignment statements"
msgstr ""

#: reference/simple_stmts.rst:80
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr ""

#: reference/simple_stmts.rst:94
msgid ""
"(See section :ref:`primaries` for the syntax definitions for *attributeref*, "
"*subscription*, and *slicing*.)"
msgstr ""

#: reference/simple_stmts.rst:97
msgid ""
"An assignment statement evaluates the expression list (remember that this "
"can be a single expression or a comma-separated list, the latter yielding a "
"tuple) and assigns the single resulting object to each of the target lists, "
"from left to right."
msgstr ""

#: reference/simple_stmts.rst:106
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute reference, "
"subscription or slicing), the mutable object must ultimately perform the "
"assignment and decide about its validity, and may raise an exception if the "
"assignment is unacceptable.  The rules observed by various types and the "
"exceptions raised are given with the definition of the object types (see "
"section :ref:`types`)."
msgstr ""

#: reference/simple_stmts.rst:115
msgid ""
"Assignment of an object to a target list, optionally enclosed in parentheses "
"or square brackets, is recursively defined as follows."
msgstr ""

#: reference/simple_stmts.rst:118
msgid ""
"If the target list is a single target: The object is assigned to that target."
msgstr ""

#: reference/simple_stmts.rst:120
msgid ""
"If the target list is a comma-separated list of targets: The object must be "
"an iterable with the same number of items as there are targets in the target "
"list, and the items are assigned, from left to right, to the corresponding "
"targets."
msgstr ""

#: reference/simple_stmts.rst:124
msgid ""
"If the target list contains one target prefixed with an asterisk, called a "
"\"starred\" target: The object must be a sequence with at least as many "
"items as there are targets in the target list, minus one.  The first items "
"of the sequence are assigned, from left to right, to the targets before the "
"starred target.  The final items of the sequence are assigned to the targets "
"after the starred target.  A list of the remaining items in the sequence is "
"then assigned to the starred target (the list can be empty)."
msgstr ""

#: reference/simple_stmts.rst:132
msgid ""
"Else: The object must be a sequence with the same number of items as there "
"are targets in the target list, and the items are assigned, from left to "
"right, to the corresponding targets."
msgstr ""

#: reference/simple_stmts.rst:136
msgid ""
"Assignment of an object to a single target is recursively defined as follows."
msgstr ""

#: reference/simple_stmts.rst:138
msgid "If the target is an identifier (name):"
msgstr ""

#: reference/simple_stmts.rst:140
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in the "
"current local namespace."
msgstr ""

#: reference/simple_stmts.rst:144
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the "
"outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""

#: reference/simple_stmts.rst:149
msgid ""
"The name is rebound if it was already bound.  This may cause the reference "
"count for the object previously bound to the name to reach zero, causing the "
"object to be deallocated and its destructor (if it has one) to be called."
msgstr ""

#: reference/simple_stmts.rst:153
msgid ""
"If the target is a target list enclosed in parentheses or in square "
"brackets: The object must be an iterable with the same number of items as "
"there are targets in the target list, and its items are assigned, from left "
"to right, to the corresponding targets."
msgstr ""

#: reference/simple_stmts.rst:160
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given attribute; "
"if it cannot perform the assignment, it raises an exception (usually but not "
"necessarily :exc:`AttributeError`)."
msgstr ""

#: reference/simple_stmts.rst:169
msgid ""
"Note: If the object is a class instance and the attribute reference occurs "
"on both sides of the assignment operator, the RHS expression, ``a.x`` can "
"access either an instance attribute or (if no instance attribute exists) a "
"class attribute.  The LHS target ``a.x`` is always set as an instance "
"attribute, creating it if necessary.  Thus, the two occurrences of ``a.x`` "
"do not necessarily refer to the same attribute: if the RHS expression refers "
"to a class attribute, the LHS creates a new instance attribute as the target "
"of the assignment::"
msgstr ""

#: reference/simple_stmts.rst:183
msgid ""
"This description does not necessarily apply to descriptor attributes, such "
"as properties created with :func:`property`."
msgstr ""

#: reference/simple_stmts.rst:190
msgid ""
"If the target is a subscription: The primary expression in the reference is "
"evaluated.  It should yield either a mutable sequence object (such as a "
"list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""

#: reference/simple_stmts.rst:199
msgid ""
"If the primary is a mutable sequence object (such as a list), the subscript "
"must yield an integer.  If it is negative, the sequence's length is added to "
"it.  The resulting value must be a nonnegative integer less than the "
"sequence's length, and the sequence is asked to assign the assigned object "
"to its item with that index.  If the index is out of range, :exc:"
"`IndexError` is raised (assignment to a subscripted sequence cannot add new "
"items to a list)."
msgstr ""

#: reference/simple_stmts.rst:210
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping is "
"then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with "
"the same key value, or insert a new key/value pair (if no key with the same "
"value existed)."
msgstr ""

#: reference/simple_stmts.rst:216
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr ""

#: reference/simple_stmts.rst:221
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  The "
"assigned object should be a sequence object of the same type.  Next, the "
"lower and upper bound expressions are evaluated, insofar they are present; "
"defaults are zero and the sequence's length.  The bounds should evaluate to "
"integers. If either bound is negative, the sequence's length is added to "
"it.  The resulting bounds are clipped to lie between zero and the sequence's "
"length, inclusive.  Finally, the sequence object is asked to replace the "
"slice with the items of the assigned sequence.  The length of the slice may "
"be different from the length of the assigned sequence, thus changing the "
"length of the target sequence, if the target sequence allows it."
msgstr ""

#: reference/simple_stmts.rst:235
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""

#: reference/simple_stmts.rst:239
msgid ""
"Although the definition of assignment implies that overlaps between the left-"
"hand side and the right-hand side are 'simultanenous' (for example ``a, b = "
"b, a`` swaps two variables), overlaps *within* the collection of assigned-to "
"variables occur left-to-right, sometimes resulting in confusion.  For "
"instance, the following program prints ``[0, 2]``::"
msgstr ""

#: reference/simple_stmts.rst:253
msgid "PEP 3132 - Extended Iterable Unpacking"
msgstr ""

#: reference/simple_stmts.rst:254
msgid "The specification for the ``*target`` feature."
msgstr ""

#: reference/simple_stmts.rst:260
msgid "Augmented assignment statements"
msgstr ""

#: reference/simple_stmts.rst:278
msgid ""
"Augmented assignment is the combination, in a single statement, of a binary "
"operation and an assignment statement:"
msgstr ""

#: reference/simple_stmts.rst:287
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last three "
"symbols.)"
msgstr ""

#: reference/simple_stmts.rst:290
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the two "
"operands, and assigns the result to the original target.  The target is only "
"evaluated once."
msgstr ""

#: reference/simple_stmts.rst:295
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as ``x = "
"x + 1`` to achieve a similar, but not exactly equal effect. In the augmented "
"version, ``x`` is only evaluated once. Also, when possible, the actual "
"operation is performed *in-place*, meaning that rather than creating a new "
"object and assigning that to the target, the old object is modified instead."
msgstr ""

#: reference/simple_stmts.rst:301
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand side "
"*before* evaluating the right-hand side.  For example, ``a[i] += f(x)`` "
"first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs the "
"addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""

#: reference/simple_stmts.rst:306
msgid ""
"With the exception of assigning to tuples and multiple targets in a single "
"statement, the assignment done by augmented assignment statements is handled "
"the same way as normal assignments. Similarly, with the exception of the "
"possible *in-place* behavior, the binary operation performed by augmented "
"assignment is the same as the normal binary operations."
msgstr ""

#: reference/simple_stmts.rst:312
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""

#: reference/simple_stmts.rst:319
msgid "The :keyword:`assert` statement"
msgstr ""

#: reference/simple_stmts.rst:325
msgid ""
"Assert statements are a convenient way to insert debugging assertions into a "
"program:"
msgstr ""

#: reference/simple_stmts.rst:331
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr ""

#: reference/simple_stmts.rst:336
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to ::"
msgstr ""

#: reference/simple_stmts.rst:345
msgid ""
"These equivalences assume that :const:`__debug__` and :exc:`AssertionError` "
"refer to the built-in variables with those names.  In the current "
"implementation, the built-in variable :const:`__debug__` is ``True`` under "
"normal circumstances, ``False`` when optimization is requested (command line "
"option -O).  The current code generator emits no code for an assert "
"statement when optimization is requested at compile time.  Note that it is "
"unnecessary to include the source code for the expression that failed in the "
"error message; it will be displayed as part of the stack trace."
msgstr ""

#: reference/simple_stmts.rst:354
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-in "
"variable is determined when the interpreter starts."
msgstr ""

#: reference/simple_stmts.rst:361
msgid "The :keyword:`pass` statement"
msgstr ""

#: reference/simple_stmts.rst:371
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""

#: reference/simple_stmts.rst:383
msgid "The :keyword:`del` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/simple_stmts.rst:393
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some hints."
msgstr ""

#: reference/simple_stmts.rst:396
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr ""

#: reference/simple_stmts.rst:402
msgid ""
"Deletion of a name removes the binding of that name from the local or global "
"namespace, depending on whether the name occurs in a :keyword:`global` "
"statement in the same code block.  If the name is unbound, a :exc:"
"`NameError` exception will be raised."
msgstr ""

#: reference/simple_stmts.rst:409
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to "
"the primary object involved; deletion of a slicing is in general equivalent "
"to assignment of an empty slice of the right type (but even this is "
"determined by the sliced object)."
msgstr ""

#: reference/simple_stmts.rst:414
msgid ""
"Previously it was illegal to delete a name from the local namespace if it "
"occurs as a free variable in a nested block."
msgstr ""

#: reference/simple_stmts.rst:422
msgid "The :keyword:`return` statement"
msgstr ""

#: reference/simple_stmts.rst:432
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ""

#: reference/simple_stmts.rst:435
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr ""

#: reference/simple_stmts.rst:437
msgid ""
":keyword:`return` leaves the current function call with the expression list "
"(or ``None``) as return value."
msgstr ""

#: reference/simple_stmts.rst:442
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the function."
msgstr ""

#: reference/simple_stmts.rst:446
msgid ""
"In a generator function, the :keyword:`return` statement indicates that the "
"generator is done and will cause :exc:`StopIteration` to be raised. The "
"returned value (if any) is used as an argument to construct :exc:"
"`StopIteration` and becomes the :attr:`StopIteration.value` attribute."
msgstr ""

#: reference/simple_stmts.rst:455
#, fuzzy
msgid "The :keyword:`yield` statement"
msgstr "L'instruction :keyword:`del`"

#: reference/simple_stmts.rst:467
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""

#: reference/simple_stmts.rst:475
msgid "are equivalent to the yield expression statements ::"
msgstr ""

#: reference/simple_stmts.rst:480
msgid ""
"Yield expressions and statements are only used when defining a :term:"
"`generator` function, and are only used in the body of the generator "
"function.  Using yield in a function definition is sufficient to cause that "
"definition to create a generator function instead of a normal function."
msgstr ""

#: reference/simple_stmts.rst:485
msgid ""
"For full details of :keyword:`yield` semantics, refer to the :ref:"
"`yieldexpr` section."
msgstr ""

#: reference/simple_stmts.rst:491
msgid "The :keyword:`raise` statement"
msgstr ""

#: reference/simple_stmts.rst:502
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last exception "
"that was active in the current scope.  If no exception is active in the "
"current scope, a :exc:`RuntimeError` exception is raised indicating that "
"this is an error."
msgstr ""

#: reference/simple_stmts.rst:507
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the exception "
"object.  It must be either a subclass or an instance of :class:"
"`BaseException`. If it is a class, the exception instance will be obtained "
"when needed by instantiating the class with no arguments."
msgstr ""

#: reference/simple_stmts.rst:512
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the :dfn:"
"`value` is the instance itself."
msgstr ""

#: reference/simple_stmts.rst:517
msgid ""
"A traceback object is normally created automatically when an exception is "
"raised and attached to it as the :attr:`__traceback__` attribute, which is "
"writable. You can create an exception and set your own traceback in one step "
"using the :meth:`with_traceback` exception method (which returns the same "
"exception instance, with its traceback set to its argument), like so::"
msgstr ""

#: reference/simple_stmts.rst:529
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance, which will then be "
"attached to the raised exception as the :attr:`__cause__` attribute (which "
"is writable).  If the raised exception is not handled, both exceptions will "
"be printed::"
msgstr ""

#: reference/simple_stmts.rst:550
msgid ""
"A similar mechanism works implicitly if an exception is raised inside an "
"exception handler or a :keyword:`finally` clause: the previous exception is "
"then attached as the new exception's :attr:`__context__` attribute::"
msgstr ""

#: reference/simple_stmts.rst:569
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information about handling exceptions is in section :ref:"
"`try`."
msgstr ""

#: reference/simple_stmts.rst:576
msgid "The :keyword:`break` statement"
msgstr ""

#: reference/simple_stmts.rst:587
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` or :"
"keyword:`while` loop, but not nested in a function or class definition "
"within that loop."
msgstr ""

#: reference/simple_stmts.rst:594
msgid ""
"It terminates the nearest enclosing loop, skipping the optional :keyword:"
"`else` clause if the loop has one."
msgstr ""

#: reference/simple_stmts.rst:597
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop control "
"target keeps its current value."
msgstr ""

#: reference/simple_stmts.rst:602
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement with "
"a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really leaving the loop."
msgstr ""

#: reference/simple_stmts.rst:610
msgid "The :keyword:`continue` statement"
msgstr ""

#: reference/simple_stmts.rst:622
msgid ""
":keyword:`continue` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class definition "
"or :keyword:`finally` clause within that loop.  It continues with the next "
"cycle of the nearest enclosing loop."
msgstr ""

#: reference/simple_stmts.rst:627
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is executed "
"before really starting the next loop cycle."
msgstr ""

#: reference/simple_stmts.rst:636
msgid "The :keyword:`import` statement"
msgstr ""

#: reference/simple_stmts.rst:655
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two "
"steps:"
msgstr ""

#: reference/simple_stmts.rst:658
msgid "find a module, loading and initializing it if necessary"
msgstr ""

#: reference/simple_stmts.rst:659
msgid ""
"define a name or names in the local namespace for the scope where the :"
"keyword:`import` statement occurs."
msgstr ""

#: reference/simple_stmts.rst:662
msgid ""
"When the statement contains multiple clauses (separated by commas) the two "
"steps are carried out separately for each clause, just as though the clauses "
"had been separated out into individiual import statements."
msgstr ""

#: reference/simple_stmts.rst:667
msgid ""
"The details of the first step, finding and loading modules are described in "
"greater detail in the section on the :ref:`import system <importsystem>`, "
"which also describes the various types of packages and modules that can be "
"imported, as well as all the hooks that can be used to customize the import "
"system. Note that failures in this step may indicate either that the module "
"could not be located, *or* that an error occurred while initializing the "
"module, which includes execution of the module's code."
msgstr ""

#: reference/simple_stmts.rst:675
msgid ""
"If the requested module is retrieved successfully, it will be made available "
"in the local namespace in one of three ways:"
msgstr ""

#: reference/simple_stmts.rst:680
msgid ""
"If the module name is followed by :keyword:`as`, then the name following :"
"keyword:`as` is bound directly to the imported module."
msgstr ""

#: reference/simple_stmts.rst:682
msgid ""
"If no other name is specified, and the module being imported is a top level "
"module, the module's name is bound in the local namespace as a reference to "
"the imported module"
msgstr ""

#: reference/simple_stmts.rst:685
msgid ""
"If the module being imported is *not* a top level module, then the name of "
"the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module must "
"be accessed using its full qualified name rather than directly"
msgstr ""

#: reference/simple_stmts.rst:696
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ""

#: reference/simple_stmts.rst:698
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ""

#: reference/simple_stmts.rst:700
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ""

#: reference/simple_stmts.rst:702
msgid "check if the imported module has an attribute by that name"
msgstr ""

#: reference/simple_stmts.rst:703
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr ""

#: reference/simple_stmts.rst:705
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr ""

#: reference/simple_stmts.rst:706
msgid ""
"otherwise, a reference to that value is stored in the local namespace, using "
"the name in the :keyword:`as` clause if it is present, otherwise using the "
"attribute name"
msgstr ""

#: reference/simple_stmts.rst:710
msgid "Examples::"
msgstr "Exemples ::"

#: reference/simple_stmts.rst:718
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public names "
"defined in the module are bound in the local namespace for the scope where "
"the :keyword:`import` statement occurs."
msgstr ""

#: reference/simple_stmts.rst:724
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must be "
"a sequence of strings which are names defined or imported by that module.  "
"The names given in ``__all__`` are all considered public and are required to "
"exist.  If ``__all__`` is not defined, the set of public names includes all "
"names found in the module's namespace which do not begin with an underscore "
"character (``'_'``).  ``__all__`` should contain the entire public API. It "
"is intended to avoid accidentally exporting items that are not part of the "
"API (such as library modules which were imported and used within the module)."
msgstr ""

#: reference/simple_stmts.rst:734
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""

#: reference/simple_stmts.rst:741
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within "
"another package it is possible to make a relative import within the same top "
"package without having to mention the package name. By using leading dots in "
"the specified module or package after :keyword:`from` you can specify how "
"high to traverse up the current package hierarchy without specifying exact "
"names. One leading dot means the current package where the module making the "
"import exists. Two dots means up one package level. Three dots is up two "
"levels, etc. So if you execute ``from . import mod`` from a module in the "
"``pkg`` package then you will end up importing ``pkg.mod``. If you execute "
"``from ..subpkg2 import mod`` from within ``pkg.subpkg1`` you will import "
"``pkg.subpkg2.mod``. The specification for relative imports is contained "
"within :pep:`328`."
msgstr ""

#: reference/simple_stmts.rst:754
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr ""

#: reference/simple_stmts.rst:761
msgid "Future statements"
msgstr ""

#: reference/simple_stmts.rst:765
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a particular "
"module should be compiled using syntax or semantics that will be available "
"in a specified future release of Python where the feature becomes standard."
msgstr ""

#: reference/simple_stmts.rst:769
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows use "
"of the new features on a per-module basis before the release in which the "
"feature becomes standard."
msgstr ""

#: reference/simple_stmts.rst:782
msgid ""
"A future statement must appear near the top of the module.  The only lines "
"that can appear before a future statement are:"
msgstr ""

#: reference/simple_stmts.rst:785
msgid "the module docstring (if any),"
msgstr ""

#: reference/simple_stmts.rst:786
msgid "comments,"
msgstr ""

#: reference/simple_stmts.rst:787
msgid "blank lines, and"
msgstr ""

#: reference/simple_stmts.rst:788
msgid "other future statements."
msgstr ""

#: reference/simple_stmts.rst:792
msgid ""
"The features recognized by Python 3.0 are ``absolute_import``, ``division``, "
"``generators``, ``unicode_literals``, ``print_function``, ``nested_scopes`` "
"and ``with_statement``.  They are all redundant because they are always "
"enabled, and only kept for backwards compatibility."
msgstr ""

#: reference/simple_stmts.rst:797
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in which "
"case the compiler may need to parse the module differently.  Such decisions "
"cannot be pushed off until runtime."
msgstr ""

#: reference/simple_stmts.rst:804
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a "
"feature not known to it."
msgstr ""

#: reference/simple_stmts.rst:808
msgid ""
"The direct runtime semantics are the same as for any import statement: there "
"is a standard module :mod:`__future__`, described later, and it will be "
"imported in the usual way at the time the future statement is executed."
msgstr ""

#: reference/simple_stmts.rst:812
msgid ""
"The interesting runtime semantics depend on the specific feature enabled by "
"the future statement."
msgstr ""

#: reference/simple_stmts.rst:815
msgid "Note that there is nothing special about the statement::"
msgstr ""

#: reference/simple_stmts.rst:819
msgid ""
"That is not a future statement; it's an ordinary import statement with no "
"special semantics or syntax restrictions."
msgstr ""

#: reference/simple_stmts.rst:822
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and :func:"
"`compile` that occur in a module :mod:`M` containing a future statement "
"will, by default, use the new syntax or semantics associated with the future "
"statement.  This can be controlled by optional arguments to :func:`compile` "
"--- see the documentation of that function for details."
msgstr ""

#: reference/simple_stmts.rst:828
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute, "
"and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""

#: reference/simple_stmts.rst:836
msgid "PEP 236 - Back to the __future__"
msgstr "PEP 236 - Retour vers le __future__"

#: reference/simple_stmts.rst:837
msgid "The original proposal for the __future__ mechanism."
msgstr ""

#: reference/simple_stmts.rst:843
msgid "The :keyword:`global` statement"
msgstr ""

#: reference/simple_stmts.rst:852
msgid ""
"The :keyword:`global` statement is a declaration which holds for the entire "
"current code block.  It means that the listed identifiers are to be "
"interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`global`, although free variables may refer to "
"globals without being declared global."
msgstr ""

#: reference/simple_stmts.rst:858
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the same "
"code block textually preceding that :keyword:`global` statement."
msgstr ""

#: reference/simple_stmts.rst:861
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as formal "
"parameters or in a :keyword:`for` loop control target, :keyword:`class` "
"definition, function definition, or :keyword:`import` statement."
msgstr ""

#: reference/simple_stmts.rst:867
msgid ""
"The current implementation does not enforce the two restrictions, but "
"programs should not abuse this freedom, as future implementations may "
"enforce them or silently change the meaning of the program."
msgstr ""

#: reference/simple_stmts.rst:876
msgid ""
"**Programmer's note:** the :keyword:`global` is a directive to the parser.  "
"It applies only to code parsed at the same time as the :keyword:`global` "
"statement. In particular, a :keyword:`global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does "
"not affect the code block *containing* the function call, and code contained "
"in such a string is unaffected by :keyword:`global` statements in the code "
"containing the function call.  The same applies to the :func:`eval` and :"
"func:`compile` functions."
msgstr ""

#: reference/simple_stmts.rst:888
msgid "The :keyword:`nonlocal` statement"
msgstr ""

#: reference/simple_stmts.rst:899
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer to "
"previously bound variables in the nearest enclosing scope excluding globals. "
"This is important because the default behavior for binding is to search the "
"local namespace first.  The statement allows encapsulated code to rebind "
"variables outside of the local scope besides the global (module) scope."
msgstr ""

#: reference/simple_stmts.rst:909
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a :"
"keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created cannot "
"be determined unambiguously)."
msgstr ""

#: reference/simple_stmts.rst:914
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with pre-"
"existing bindings in the local scope."
msgstr ""

#: reference/simple_stmts.rst:919
msgid "PEP 3104 - Access to Names in Outer Scopes"
msgstr ""

#: reference/simple_stmts.rst:920
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ""

#: reference/toplevel_components.rst:6
msgid "Top-level components"
msgstr ""

#: reference/toplevel_components.rst:10
msgid ""
"The Python interpreter can get its input from a number of sources: from a "
"script passed to it as standard input or as program argument, typed in "
"interactively, from a module source file, etc.  This chapter gives the "
"syntax used in these cases."
msgstr ""

#: reference/toplevel_components.rst:19
msgid "Complete Python programs"
msgstr ""

#: reference/toplevel_components.rst:28
msgid ""
"While a language specification need not prescribe how the language "
"interpreter is invoked, it is useful to have a notion of a complete Python "
"program.  A complete Python program is executed in a minimally initialized "
"environment: all built-in and standard modules are available, but none have "
"been initialized, except for :mod:`sys` (various system services), :mod:"
"`builtins` (built-in functions, exceptions and ``None``) and :mod:"
"`__main__`.  The latter is used to provide the local and global namespace "
"for execution of the complete program."
msgstr ""

#: reference/toplevel_components.rst:36
msgid ""
"The syntax for a complete Python program is that for file input, described "
"in the next section."
msgstr ""

#: reference/toplevel_components.rst:43
msgid ""
"The interpreter may also be invoked in interactive mode; in this case, it "
"does not read and execute a complete program but reads and executes one "
"statement (possibly compound) at a time.  The initial environment is "
"identical to that of a complete program; each statement is executed in the "
"namespace of :mod:`__main__`."
msgstr ""

#: reference/toplevel_components.rst:54
msgid ""
"Under Unix, a complete program can be passed to the interpreter in three "
"forms: with the :option:`-c` *string* command line option, as a file passed "
"as the first command line argument, or as standard input.  If the file or "
"standard input is a tty device, the interpreter enters interactive mode; "
"otherwise, it executes the file as a complete program."
msgstr ""

#: reference/toplevel_components.rst:64
msgid "File input"
msgstr ""

#: reference/toplevel_components.rst:66
msgid "All input read from non-interactive files has the same form:"
msgstr ""

#: reference/toplevel_components.rst:71
msgid "This syntax is used in the following situations:"
msgstr ""

#: reference/toplevel_components.rst:73
msgid "when parsing a complete Python program (from a file or from a string);"
msgstr ""

#: reference/toplevel_components.rst:75
msgid "when parsing a module;"
msgstr ""

#: reference/toplevel_components.rst:77
msgid "when parsing a string passed to the :func:`exec` function;"
msgstr ""

#: reference/toplevel_components.rst:83
msgid "Interactive input"
msgstr ""

#: reference/toplevel_components.rst:85
msgid "Input in interactive mode is parsed using the following grammar:"
msgstr ""

#: reference/toplevel_components.rst:90
msgid ""
"Note that a (top-level) compound statement must be followed by a blank line "
"in interactive mode; this is needed to help the parser detect the end of the "
"input."
msgstr ""

#: reference/toplevel_components.rst:97
msgid "Expression input"
msgstr ""

#: reference/toplevel_components.rst:102
msgid ""
":func:`eval` is used for expression input.  It ignores leading whitespace. "
"The string argument to :func:`eval` must have the following form:"
msgstr ""
